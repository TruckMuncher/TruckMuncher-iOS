// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

internal struct SearchRoot {
  internal static var sharedInstance : SearchRoot {
   struct Static {
       static let instance : SearchRoot = SearchRoot()
   }
   return Static.instance
  }
  var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    TrucksRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    MenuRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  internal func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

internal func == (lhs: SimpleSearchRequest, rhs: SimpleSearchRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasQuery == rhs.hasQuery) && (!lhs.hasQuery || lhs.query == rhs.query)
  fieldCheck = fieldCheck && (lhs.hasLimit == rhs.hasLimit) && (!lhs.hasLimit || lhs.limit == rhs.limit)
  fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
  fieldCheck = fieldCheck && (lhs.hasSkipCorrection == rhs.hasSkipCorrection) && (!lhs.hasSkipCorrection || lhs.skipCorrection == rhs.skipCorrection)
  fieldCheck = fieldCheck && (lhs.hasGlutenFree == rhs.hasGlutenFree) && (!lhs.hasGlutenFree || lhs.glutenFree == rhs.glutenFree)
  fieldCheck = fieldCheck && (lhs.hasPeanutFree == rhs.hasPeanutFree) && (!lhs.hasPeanutFree || lhs.peanutFree == rhs.peanutFree)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: SimpleSearchResponse, rhs: SimpleSearchResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.searchResponse == rhs.searchResponse)
  fieldCheck = fieldCheck && (lhs.hasCorrectedQuery == rhs.hasCorrectedQuery) && (!lhs.hasCorrectedQuery || lhs.correctedQuery == rhs.correctedQuery)
  fieldCheck = fieldCheck && (lhs.suggestions == rhs.suggestions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: SearchResponse, rhs: SearchResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBlurb == rhs.hasBlurb) && (!lhs.hasBlurb || lhs.blurb == rhs.blurb)
  fieldCheck = fieldCheck && (lhs.hasTruck == rhs.hasTruck) && (!lhs.hasTruck || lhs.truck == rhs.truck)
  fieldCheck = fieldCheck && (lhs.hasMenu == rhs.hasMenu) && (!lhs.hasMenu || lhs.menu == rhs.menu)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final internal class SimpleSearchRequest : GeneratedMessage {
  private(set) var hasQuery:Bool = false
  private(set) var query:String = ""

  private(set) var hasLimit:Bool = false
  private(set) var limit:Int32 = Int32(20)

  private(set) var hasOffset:Bool = false
  private(set) var offset:Int32 = Int32(0)

  private(set) var hasSkipCorrection:Bool = false
  private(set) var skipCorrection:Bool = false

  private(set) var hasGlutenFree:Bool = false
  private(set) var glutenFree:Bool = false

  private(set) var hasPeanutFree:Bool = false
  private(set) var peanutFree:Bool = false

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
    if !hasQuery {
      return false
    }
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasQuery {
      output.writeString(1, value:query)
    }
    if hasLimit {
      output.writeInt32(2, value:limit)
    }
    if hasOffset {
      output.writeInt32(3, value:offset)
    }
    if hasSkipCorrection {
      output.writeBool(4, value:skipCorrection)
    }
    if hasGlutenFree {
      output.writeBool(5, value:glutenFree)
    }
    if hasPeanutFree {
      output.writeBool(6, value:peanutFree)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasQuery {
      size += WireFormat.computeStringSize(1, value:query)
    }
    if hasLimit {
      size += WireFormat.computeInt32Size(2, value:limit)
    }
    if hasOffset {
      size += WireFormat.computeInt32Size(3, value:offset)
    }
    if hasSkipCorrection {
      size += WireFormat.computeBoolSize(4, value:skipCorrection)
    }
    if hasGlutenFree {
      size += WireFormat.computeBoolSize(5, value:glutenFree)
    }
    if hasPeanutFree {
      size += WireFormat.computeBoolSize(6, value:peanutFree)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  internal class func parseFromData(data:[Byte]) -> SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromData(data).build()
  }
  internal class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SimpleSearchRequest {
    return SimpleSearchRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> SimpleSearchRequestBuilder {
    return SimpleSearchRequest.classBuilder() as SimpleSearchRequestBuilder
  }
  internal func builder() -> SimpleSearchRequestBuilder {
    return classBuilder() as SimpleSearchRequestBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return SimpleSearchRequestBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return SimpleSearchRequest.builder()
  }
  internal func toBuilder() -> SimpleSearchRequestBuilder {
    return SimpleSearchRequest.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:SimpleSearchRequest) -> SimpleSearchRequestBuilder {
    return SimpleSearchRequest.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasQuery {
      output += "\(indent) query: \(query) \n"
    }
    if hasLimit {
      output += "\(indent) limit: \(limit) \n"
    }
    if hasOffset {
      output += "\(indent) offset: \(offset) \n"
    }
    if hasSkipCorrection {
      output += "\(indent) skipCorrection: \(skipCorrection) \n"
    }
    if hasGlutenFree {
      output += "\(indent) glutenFree: \(glutenFree) \n"
    }
    if hasPeanutFree {
      output += "\(indent) peanutFree: \(peanutFree) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasQuery {
             hashCode = (hashCode &* 31) &+ query.hashValue
          }
          if hasLimit {
             hashCode = (hashCode &* 31) &+ limit.hashValue
          }
          if hasOffset {
             hashCode = (hashCode &* 31) &+ offset.hashValue
          }
          if hasSkipCorrection {
             hashCode = (hashCode &* 31) &+ skipCorrection.hashValue
          }
          if hasGlutenFree {
             hashCode = (hashCode &* 31) &+ glutenFree.hashValue
          }
          if hasPeanutFree {
             hashCode = (hashCode &* 31) &+ peanutFree.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "SimpleSearchRequest"
  }
  override internal func className() -> String {
      return "SimpleSearchRequest"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return SimpleSearchRequest.self
  }


  //Meta information declaration end

}

final internal class SimpleSearchRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:SimpleSearchRequest

  required override internal init () {
     builderResult = SimpleSearchRequest()
     super.init()
  }
  var hasQuery:Bool {
       get {
            return builderResult.hasQuery
       }
  }
  var query:String {
       get {
            return builderResult.query
       }
       set (value) {
           builderResult.hasQuery = true
           builderResult.query = value
       }
  }
  internal func clearQuery() -> SimpleSearchRequestBuilder{
       builderResult.hasQuery = false
       builderResult.query = ""
       return self
  }
  var hasLimit:Bool {
       get {
            return builderResult.hasLimit
       }
  }
  var limit:Int32 {
       get {
            return builderResult.limit
       }
       set (value) {
           builderResult.hasLimit = true
           builderResult.limit = value
       }
  }
  internal func clearLimit() -> SimpleSearchRequestBuilder{
       builderResult.hasLimit = false
       builderResult.limit = Int32(20)
       return self
  }
  var hasOffset:Bool {
       get {
            return builderResult.hasOffset
       }
  }
  var offset:Int32 {
       get {
            return builderResult.offset
       }
       set (value) {
           builderResult.hasOffset = true
           builderResult.offset = value
       }
  }
  internal func clearOffset() -> SimpleSearchRequestBuilder{
       builderResult.hasOffset = false
       builderResult.offset = Int32(0)
       return self
  }
  var hasSkipCorrection:Bool {
       get {
            return builderResult.hasSkipCorrection
       }
  }
  var skipCorrection:Bool {
       get {
            return builderResult.skipCorrection
       }
       set (value) {
           builderResult.hasSkipCorrection = true
           builderResult.skipCorrection = value
       }
  }
  internal func clearSkipCorrection() -> SimpleSearchRequestBuilder{
       builderResult.hasSkipCorrection = false
       builderResult.skipCorrection = false
       return self
  }
  var hasGlutenFree:Bool {
       get {
            return builderResult.hasGlutenFree
       }
  }
  var glutenFree:Bool {
       get {
            return builderResult.glutenFree
       }
       set (value) {
           builderResult.hasGlutenFree = true
           builderResult.glutenFree = value
       }
  }
  internal func clearGlutenFree() -> SimpleSearchRequestBuilder{
       builderResult.hasGlutenFree = false
       builderResult.glutenFree = false
       return self
  }
  var hasPeanutFree:Bool {
       get {
            return builderResult.hasPeanutFree
       }
  }
  var peanutFree:Bool {
       get {
            return builderResult.peanutFree
       }
       set (value) {
           builderResult.hasPeanutFree = true
           builderResult.peanutFree = value
       }
  }
  internal func clearPeanutFree() -> SimpleSearchRequestBuilder{
       builderResult.hasPeanutFree = false
       builderResult.peanutFree = false
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> SimpleSearchRequestBuilder {
    builderResult = SimpleSearchRequest()
    return self
  }
  internal override func clone() -> SimpleSearchRequestBuilder {
    return SimpleSearchRequest.builderWithPrototype(builderResult)
  }
  internal override func build() -> SimpleSearchRequest {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> SimpleSearchRequest {
    var returnMe:SimpleSearchRequest = builderResult
    return returnMe
  }
  internal func mergeFrom(other:SimpleSearchRequest) -> SimpleSearchRequestBuilder {
    if (other == SimpleSearchRequest()) {
     return self
    }
    if other.hasQuery {
         query = other.query
    }
    if other.hasLimit {
         limit = other.limit
    }
    if other.hasOffset {
         offset = other.offset
    }
    if other.hasSkipCorrection {
         skipCorrection = other.skipCorrection
    }
    if other.hasGlutenFree {
         glutenFree = other.glutenFree
    }
    if other.hasPeanutFree {
         peanutFree = other.peanutFree
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->SimpleSearchRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SimpleSearchRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        query = input.readString()

      case 16 :
        limit = input.readInt32()

      case 24 :
        offset = input.readInt32()

      case 32 :
        skipCorrection = input.readBool()

      case 40 :
        glutenFree = input.readBool()

      case 48 :
        peanutFree = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final internal class SimpleSearchResponse : GeneratedMessage {
  private(set) var hasCorrectedQuery:Bool = false
  private(set) var correctedQuery:String = ""

  private(set) var searchResponse:Array<SearchResponse>  = Array<SearchResponse>()
  private(set) var suggestions:Array<String> = Array<String>()
  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
    if !hasCorrectedQuery {
      return false
    }
    var isInitsearchResponse:Bool = true
    for oneElementsearchResponse in searchResponse {
        if (!oneElementsearchResponse.isInitialized()) {
            isInitsearchResponse = false
            break 
        }
    }
    if !isInitsearchResponse {
     return isInitsearchResponse
     }
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    for oneElementsearchResponse in searchResponse {
        output.writeMessage(1, value:oneElementsearchResponse)
    }
    if hasCorrectedQuery {
      output.writeString(2, value:correctedQuery)
    }
    if !suggestions.isEmpty {
      for oneValuesuggestions in suggestions {
        output.writeString(3, value:oneValuesuggestions)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for oneElementsearchResponse in searchResponse {
        size += WireFormat.computeMessageSize(1, value:oneElementsearchResponse)
    }
    if hasCorrectedQuery {
      size += WireFormat.computeStringSize(2, value:correctedQuery)
    }
    var dataSizeSuggestions:Int32 = 0
    for oneValuesuggestions in suggestions {
        dataSizeSuggestions += WireFormat.computeStringSizeNoTag(oneValuesuggestions)
    }
    size += dataSizeSuggestions
    size += 1 * Int32(suggestions.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  internal class func parseFromData(data:[Byte]) -> SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromData(data).build()
  }
  internal class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SimpleSearchResponse {
    return SimpleSearchResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> SimpleSearchResponseBuilder {
    return SimpleSearchResponse.classBuilder() as SimpleSearchResponseBuilder
  }
  internal func builder() -> SimpleSearchResponseBuilder {
    return classBuilder() as SimpleSearchResponseBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return SimpleSearchResponseBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return SimpleSearchResponse.builder()
  }
  internal func toBuilder() -> SimpleSearchResponseBuilder {
    return SimpleSearchResponse.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:SimpleSearchResponse) -> SimpleSearchResponseBuilder {
    return SimpleSearchResponse.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    var searchResponseElementIndex:Int = 0
    for oneElementsearchResponse in searchResponse {
        output += "\(indent) searchResponse[\(searchResponseElementIndex)] {\n"
        oneElementsearchResponse.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        searchResponseElementIndex++
    }
    if hasCorrectedQuery {
      output += "\(indent) correctedQuery: \(correctedQuery) \n"
    }
    var suggestionsElementIndex:Int = 0
    for oneValuesuggestions in suggestions  {
        output += "\(indent) suggestions[\(suggestionsElementIndex)]: \(oneValuesuggestions)\n"
        suggestionsElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementsearchResponse in searchResponse {
              hashCode = (hashCode &* 31) &+ oneElementsearchResponse.hashValue
          }
          if hasCorrectedQuery {
             hashCode = (hashCode &* 31) &+ correctedQuery.hashValue
          }
          for oneValuesuggestions in suggestions {
              hashCode = (hashCode &* 31) &+ oneValuesuggestions.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "SimpleSearchResponse"
  }
  override internal func className() -> String {
      return "SimpleSearchResponse"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return SimpleSearchResponse.self
  }


  //Meta information declaration end

}

final internal class SimpleSearchResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:SimpleSearchResponse

  required override internal init () {
     builderResult = SimpleSearchResponse()
     super.init()
  }
  var searchResponse:Array<SearchResponse> {
       get {
           return builderResult.searchResponse
       }
       set (value) {
           builderResult.searchResponse = value
       }
  }
  internal func clearSearchResponse() -> SimpleSearchResponseBuilder {
    builderResult.searchResponse.removeAll(keepCapacity: false)
    return self
  }
  var hasCorrectedQuery:Bool {
       get {
            return builderResult.hasCorrectedQuery
       }
  }
  var correctedQuery:String {
       get {
            return builderResult.correctedQuery
       }
       set (value) {
           builderResult.hasCorrectedQuery = true
           builderResult.correctedQuery = value
       }
  }
  internal func clearCorrectedQuery() -> SimpleSearchResponseBuilder{
       builderResult.hasCorrectedQuery = false
       builderResult.correctedQuery = ""
       return self
  }
  var suggestions:Array<String> {
       get {
           return builderResult.suggestions
       }
       set (array) {
           builderResult.suggestions = array
       }
  }
  internal func clearSuggestions() -> SimpleSearchResponseBuilder {
     builderResult.suggestions.removeAll(keepCapacity: false)
     return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> SimpleSearchResponseBuilder {
    builderResult = SimpleSearchResponse()
    return self
  }
  internal override func clone() -> SimpleSearchResponseBuilder {
    return SimpleSearchResponse.builderWithPrototype(builderResult)
  }
  internal override func build() -> SimpleSearchResponse {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> SimpleSearchResponse {
    var returnMe:SimpleSearchResponse = builderResult
    return returnMe
  }
  internal func mergeFrom(other:SimpleSearchResponse) -> SimpleSearchResponseBuilder {
    if (other == SimpleSearchResponse()) {
     return self
    }
    if !other.searchResponse.isEmpty  {
       builderResult.searchResponse += other.searchResponse
    }
    if other.hasCorrectedQuery {
         correctedQuery = other.correctedQuery
    }
    if !other.suggestions.isEmpty {
        builderResult.suggestions += other.suggestions
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->SimpleSearchResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SimpleSearchResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = SearchResponse.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        searchResponse += [subBuilder.buildPartial()]

      case 18 :
        correctedQuery = input.readString()

      case 26 :
        suggestions += [input.readString()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final internal class SearchResponse : GeneratedMessage {
  private(set) var hasBlurb:Bool = false
  private(set) var blurb:String = ""

  private(set) var hasTruck:Bool = false
  private(set) var truck:Truck = Truck()
  private(set) var hasMenu:Bool = false
  private(set) var menu:Menu = Menu()
  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
    if !hasBlurb {
      return false
    }
    if !hasTruck {
      return false
    }
    if !hasMenu {
      return false
    }
    if !menu.isInitialized() {
      return false
    }
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasBlurb {
      output.writeString(1, value:blurb)
    }
    if hasTruck {
      output.writeMessage(2, value:truck)
    }
    if hasMenu {
      output.writeMessage(3, value:menu)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasBlurb {
      size += WireFormat.computeStringSize(1, value:blurb)
    }
    if hasTruck {
      size += WireFormat.computeMessageSize(2, value:truck)
    }
    if hasMenu {
      size += WireFormat.computeMessageSize(3, value:menu)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  internal class func parseFromData(data:[Byte]) -> SearchResponse {
    return SearchResponse.builder().mergeFromData(data).build()
  }
  internal class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> SearchResponse {
    return SearchResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> SearchResponse {
    return SearchResponse.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->SearchResponse {
    return SearchResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> SearchResponse {
    return SearchResponse.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SearchResponse {
    return SearchResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> SearchResponseBuilder {
    return SearchResponse.classBuilder() as SearchResponseBuilder
  }
  internal func builder() -> SearchResponseBuilder {
    return classBuilder() as SearchResponseBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return SearchResponseBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return SearchResponse.builder()
  }
  internal func toBuilder() -> SearchResponseBuilder {
    return SearchResponse.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:SearchResponse) -> SearchResponseBuilder {
    return SearchResponse.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasBlurb {
      output += "\(indent) blurb: \(blurb) \n"
    }
    if hasTruck {
      output += "\(indent) truck {\n"
      truck.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasMenu {
      output += "\(indent) menu {\n"
      menu.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBlurb {
             hashCode = (hashCode &* 31) &+ blurb.hashValue
          }
          if hasTruck {
            hashCode = (hashCode &* 31) &+ truck.hashValue
          }
          if hasMenu {
            hashCode = (hashCode &* 31) &+ menu.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "SearchResponse"
  }
  override internal func className() -> String {
      return "SearchResponse"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return SearchResponse.self
  }


  //Meta information declaration end

}

final internal class SearchResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:SearchResponse

  required override internal init () {
     builderResult = SearchResponse()
     super.init()
  }
  var hasBlurb:Bool {
       get {
            return builderResult.hasBlurb
       }
  }
  var blurb:String {
       get {
            return builderResult.blurb
       }
       set (value) {
           builderResult.hasBlurb = true
           builderResult.blurb = value
       }
  }
  internal func clearBlurb() -> SearchResponseBuilder{
       builderResult.hasBlurb = false
       builderResult.blurb = ""
       return self
  }
  var hasTruck:Bool {
       get {
           return builderResult.hasTruck
       }
  }
  var truck:Truck {
       get {
           return builderResult.truck
       }
       set (value) {
           builderResult.hasTruck = true
           builderResult.truck = value
       }
  }
  internal func setTruckBuilder(builderForValue:TruckBuilder) -> SearchResponseBuilder {
    truck = builderForValue.build()
    return self
  }
  internal func mergeTruck(value:Truck) -> SearchResponseBuilder {
    if (builderResult.hasTruck) {
      builderResult.truck = Truck.builderWithPrototype(builderResult.truck).mergeFrom(value).buildPartial()
    } else {
      builderResult.truck = value
    }
    builderResult.hasTruck = true
    return self
  }
  internal func clearTruck() -> SearchResponseBuilder {
    builderResult.hasTruck = false
    builderResult.truck = Truck()
    return self
  }
  var hasMenu:Bool {
       get {
           return builderResult.hasMenu
       }
  }
  var menu:Menu {
       get {
           return builderResult.menu
       }
       set (value) {
           builderResult.hasMenu = true
           builderResult.menu = value
       }
  }
  internal func setMenuBuilder(builderForValue:MenuBuilder) -> SearchResponseBuilder {
    menu = builderForValue.build()
    return self
  }
  internal func mergeMenu(value:Menu) -> SearchResponseBuilder {
    if (builderResult.hasMenu) {
      builderResult.menu = Menu.builderWithPrototype(builderResult.menu).mergeFrom(value).buildPartial()
    } else {
      builderResult.menu = value
    }
    builderResult.hasMenu = true
    return self
  }
  internal func clearMenu() -> SearchResponseBuilder {
    builderResult.hasMenu = false
    builderResult.menu = Menu()
    return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> SearchResponseBuilder {
    builderResult = SearchResponse()
    return self
  }
  internal override func clone() -> SearchResponseBuilder {
    return SearchResponse.builderWithPrototype(builderResult)
  }
  internal override func build() -> SearchResponse {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> SearchResponse {
    var returnMe:SearchResponse = builderResult
    return returnMe
  }
  internal func mergeFrom(other:SearchResponse) -> SearchResponseBuilder {
    if (other == SearchResponse()) {
     return self
    }
    if other.hasBlurb {
         blurb = other.blurb
    }
    if (other.hasTruck) {
        mergeTruck(other.truck)
    }
    if (other.hasMenu) {
        mergeMenu(other.menu)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->SearchResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SearchResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        blurb = input.readString()

      case 18 :
        var subBuilder:TruckBuilder = Truck.builder()
        if hasTruck {
          subBuilder.mergeFrom(truck)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        truck = subBuilder.buildPartial()

      case 26 :
        var subBuilder:MenuBuilder = Menu.builder()
        if hasMenu {
          subBuilder.mergeFrom(menu)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        menu = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


internal extension SimpleSearchRequest {
    class func parseFromNSData(data:NSData) -> SimpleSearchRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SimpleSearchRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> SimpleSearchRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SimpleSearchRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
internal extension SimpleSearchResponse {
    class func parseFromNSData(data:NSData) -> SimpleSearchResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SimpleSearchResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> SimpleSearchResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SimpleSearchResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
internal extension SearchResponse {
    class func parseFromNSData(data:NSData) -> SearchResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SearchResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> SearchResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SearchResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
