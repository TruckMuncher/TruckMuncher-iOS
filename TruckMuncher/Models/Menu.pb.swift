// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

private class MenuRoot {
var extensionRegistry:ExtensionRegistry

init() {
extensionRegistry = ExtensionRegistry()
registerAllExtensions(extensionRegistry)
}
func registerAllExtensions(registry:ExtensionRegistry) {
}
}

func == (lhs: MenuItemAvailabilityDiffRequest, rhs: MenuItemAvailabilityDiffRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemAvailabilityDiffResponse, rhs: MenuItemAvailabilityDiffResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.diff == rhs.diff)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FullMenusRequest, rhs: FullMenusRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasIncludeAvailability == rhs.hasIncludeAvailability) && (!lhs.hasIncludeAvailability || lhs.includeAvailability == rhs.includeAvailability)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FullMenusResponse.Menu, rhs: FullMenusResponse.Menu) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTruckId == rhs.hasTruckId) && (!lhs.hasTruckId || lhs.truckId == rhs.truckId)
  fieldCheck = fieldCheck && (lhs.hasMenuId == rhs.hasMenuId) && (!lhs.hasMenuId || lhs.menuId == rhs.menuId)
  fieldCheck = fieldCheck && (lhs.category == rhs.category)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FullMenusResponse, rhs: FullMenusResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.menu == rhs.menu)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuAvailabilityRequest, rhs: MenuAvailabilityRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.diff == rhs.diff)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuAvailabilityResponse, rhs: MenuAvailabilityResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemRequest, rhs: MenuItemRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCategoryId == rhs.hasCategoryId) && (!lhs.hasCategoryId || lhs.categoryId == rhs.categoryId)
  fieldCheck = fieldCheck && (lhs.hasMenuItem == rhs.hasMenuItem) && (!lhs.hasMenuItem || lhs.menuItem == rhs.menuItem)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemResponse, rhs: MenuItemResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMenuItem == rhs.hasMenuItem) && (!lhs.hasMenuItem || lhs.menuItem == rhs.menuItem)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: DeleteMenuItemRequest, rhs: DeleteMenuItemRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMenuItemId == rhs.hasMenuItemId) && (!lhs.hasMenuItemId || lhs.menuItemId == rhs.menuItemId)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: DeleteMenuItemResponse, rhs: DeleteMenuItemResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: CategoryRequest, rhs: CategoryRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.hasOrderInMenu == rhs.hasOrderInMenu) && (!lhs.hasOrderInMenu || lhs.orderInMenu == rhs.orderInMenu)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: CategoryResponse, rhs: CategoryResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.hasOrderInMenu == rhs.hasOrderInMenu) && (!lhs.hasOrderInMenu || lhs.orderInMenu == rhs.orderInMenu)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: DeleteCategoryRequest, rhs: DeleteCategoryRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCategoryId == rhs.hasCategoryId) && (!lhs.hasCategoryId || lhs.categoryId == rhs.categoryId)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: DeleteCategoryResponse, rhs: DeleteCategoryResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Category, rhs: Category) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.hasOrderInMenu == rhs.hasOrderInMenu) && (!lhs.hasOrderInMenu || lhs.orderInMenu == rhs.orderInMenu)
  fieldCheck = fieldCheck && (lhs.menuItem == rhs.menuItem)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItem, rhs: MenuItem) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasPrice == rhs.hasPrice) && (!lhs.hasPrice || lhs.price == rhs.price)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.tag == rhs.tag)
  fieldCheck = fieldCheck && (lhs.hasOrderInCategory == rhs.hasOrderInCategory) && (!lhs.hasOrderInCategory || lhs.orderInCategory == rhs.orderInCategory)
  fieldCheck = fieldCheck && (lhs.hasIsAvailable == rhs.hasIsAvailable) && (!lhs.hasIsAvailable || lhs.isAvailable == rhs.isAvailable)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemAvailabilityDiff, rhs: MenuItemAvailabilityDiff) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMenuItemId == rhs.hasMenuItemId) && (!lhs.hasMenuItemId || lhs.menuItemId == rhs.menuItemId)
  fieldCheck = fieldCheck && (lhs.hasIsAvailable == rhs.hasIsAvailable) && (!lhs.hasIsAvailable || lhs.isAvailable == rhs.isAvailable)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final class MenuItemAvailabilityDiffRequest : GeneratedMessage {
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Double = 0

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Double = 0

  private(set) var hasVersion:Bool = false
  private(set) var version:Int64 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasLatitude {
      output.writeDouble(1, value:latitude)
    }
    if hasLongitude {
      output.writeDouble(2, value:longitude)
    }
    if hasVersion {
      output.writeInt64(3, value:version)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasLatitude {
      size += WireFormat.computeDoubleSize(1, value:latitude)
    }
    if hasLongitude {
      size += WireFormat.computeDoubleSize(2, value:longitude)
    }
    if hasVersion {
      size += WireFormat.computeInt64Size(3, value:version)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffRequest {
    return MenuItemAvailabilityDiffRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityDiffRequestBuilder {
    return MenuItemAvailabilityDiffRequestBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailabilityDiffRequest) -> MenuItemAvailabilityDiffRequestBuilder {
    return MenuItemAvailabilityDiffRequest.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityDiffRequestBuilder {
    return MenuItemAvailabilityDiffRequest.builder()
  }
  func toBuilder() -> MenuItemAvailabilityDiffRequestBuilder {
    return MenuItemAvailabilityDiffRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemAvailabilityDiffRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailabilityDiffRequest

  required override init () {
     builderResult = MenuItemAvailabilityDiffRequest()
     super.init()
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Double {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func clearLatitude() -> MenuItemAvailabilityDiffRequestBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = 0
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Double {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func clearLongitude() -> MenuItemAvailabilityDiffRequestBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = 0
       return self
  }
  var hasVersion:Bool {
       get {
            return builderResult.hasVersion
       }
  }
  var version:Int64 {
       get {
            return builderResult.version
       }
       set (value) {
           builderResult.hasVersion = true
           builderResult.version = value
       }
  }
  func clearVersion() -> MenuItemAvailabilityDiffRequestBuilder{
       builderResult.hasVersion = false
       builderResult.version = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityDiffRequestBuilder {
    builderResult = MenuItemAvailabilityDiffRequest()
    return self
  }
  override func clone() -> MenuItemAvailabilityDiffRequestBuilder {
    return MenuItemAvailabilityDiffRequest.builderWithPrototype(builderResult)
  }
  func build() -> MenuItemAvailabilityDiffRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailabilityDiffRequest {
    var returnMe:MenuItemAvailabilityDiffRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailabilityDiffRequest) -> MenuItemAvailabilityDiffRequestBuilder {
    if (other == MenuItemAvailabilityDiffRequest()) {
      return self
    }
  if other.hasLatitude {
       latitude = other.latitude
  }
  if other.hasLongitude {
       longitude = other.longitude
  }
  if other.hasVersion {
       version = other.version
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityDiffRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 9 :
        latitude = input.readDouble()

      case 17 :
        longitude = input.readDouble()

      case 24 :
        version = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuItemAvailabilityDiffResponse : GeneratedMessage {
  private(set) var hasVersion:Bool = false
  private(set) var version:Int64 = 0

  private(set) var diff:Array<MenuItemAvailabilityDiff>  = Array<MenuItemAvailabilityDiff>()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasVersion {
      return false
    }
    var isInitdiff:Bool = true
    for element in diff {
        if (!element.isInitialized()) {
            isInitdiff = false
            break 
        }
    }
    if !isInitdiff {
     return isInitdiff
     }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in diff {
        output.writeMessage(1, value:element)
    }
    if hasVersion {
      output.writeInt64(2, value:version)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in diff {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    if hasVersion {
      size += WireFormat.computeInt64Size(2, value:version)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffResponse {
    return MenuItemAvailabilityDiffResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityDiffResponseBuilder {
    return MenuItemAvailabilityDiffResponseBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailabilityDiffResponse) -> MenuItemAvailabilityDiffResponseBuilder {
    return MenuItemAvailabilityDiffResponse.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityDiffResponseBuilder {
    return MenuItemAvailabilityDiffResponse.builder()
  }
  func toBuilder() -> MenuItemAvailabilityDiffResponseBuilder {
    return MenuItemAvailabilityDiffResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    var diffElementIndex:Int = 0
    for element in diff {
        output += "\(indent) diff[\(diffElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        diffElementIndex++
    }
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in diff {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemAvailabilityDiffResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailabilityDiffResponse

  required override init () {
     builderResult = MenuItemAvailabilityDiffResponse()
     super.init()
  }
  var diff:Array<MenuItemAvailabilityDiff> {
       get {
           return builderResult.diff
       }
       set (value) {
           builderResult.diff = value
       }
  }
  func clearDiff() -> MenuItemAvailabilityDiffResponseBuilder {
    builderResult.diff.removeAll(keepCapacity: false)
    return self
  }
  var hasVersion:Bool {
       get {
            return builderResult.hasVersion
       }
  }
  var version:Int64 {
       get {
            return builderResult.version
       }
       set (value) {
           builderResult.hasVersion = true
           builderResult.version = value
       }
  }
  func clearVersion() -> MenuItemAvailabilityDiffResponseBuilder{
       builderResult.hasVersion = false
       builderResult.version = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityDiffResponseBuilder {
    builderResult = MenuItemAvailabilityDiffResponse()
    return self
  }
  override func clone() -> MenuItemAvailabilityDiffResponseBuilder {
    return MenuItemAvailabilityDiffResponse.builderWithPrototype(builderResult)
  }
  func build() -> MenuItemAvailabilityDiffResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailabilityDiffResponse {
    var returnMe:MenuItemAvailabilityDiffResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailabilityDiffResponse) -> MenuItemAvailabilityDiffResponseBuilder {
    if (other == MenuItemAvailabilityDiffResponse()) {
      return self
    }
  if !other.diff.isEmpty  {
     builderResult.diff += other.diff
  }
  if other.hasVersion {
       version = other.version
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityDiffResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = MenuItemAvailabilityDiff.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        diff += [subBuilder.buildPartial()]

      case 16 :
        version = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class FullMenusRequest : GeneratedMessage {
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Double = 0

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Double = 0

  private(set) var hasIncludeAvailability:Bool = false
  private(set) var includeAvailability:Bool = false

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasLatitude {
      output.writeDouble(1, value:latitude)
    }
    if hasLongitude {
      output.writeDouble(2, value:longitude)
    }
    if hasIncludeAvailability {
      output.writeBool(3, value:includeAvailability)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasLatitude {
      size += WireFormat.computeDoubleSize(1, value:latitude)
    }
    if hasLongitude {
      size += WireFormat.computeDoubleSize(2, value:longitude)
    }
    if hasIncludeAvailability {
      size += WireFormat.computeBoolSize(3, value:includeAvailability)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FullMenusRequest {
    return FullMenusRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FullMenusRequestBuilder {
    return FullMenusRequestBuilder()
  }
  class func builderWithPrototype(prototype:FullMenusRequest) -> FullMenusRequestBuilder {
    return FullMenusRequest.builder().mergeFrom(prototype)
  }
  func builder() -> FullMenusRequestBuilder {
    return FullMenusRequest.builder()
  }
  func toBuilder() -> FullMenusRequestBuilder {
    return FullMenusRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    if hasIncludeAvailability {
      output += "\(indent) includeAvailability: \(includeAvailability) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          if hasIncludeAvailability {
             hashCode = (hashCode &* 31) &+ includeAvailability.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class FullMenusRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:FullMenusRequest

  required override init () {
     builderResult = FullMenusRequest()
     super.init()
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Double {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func clearLatitude() -> FullMenusRequestBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = 0
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Double {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func clearLongitude() -> FullMenusRequestBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = 0
       return self
  }
  var hasIncludeAvailability:Bool {
       get {
            return builderResult.hasIncludeAvailability
       }
  }
  var includeAvailability:Bool {
       get {
            return builderResult.includeAvailability
       }
       set (value) {
           builderResult.hasIncludeAvailability = true
           builderResult.includeAvailability = value
       }
  }
  func clearIncludeAvailability() -> FullMenusRequestBuilder{
       builderResult.hasIncludeAvailability = false
       builderResult.includeAvailability = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FullMenusRequestBuilder {
    builderResult = FullMenusRequest()
    return self
  }
  override func clone() -> FullMenusRequestBuilder {
    return FullMenusRequest.builderWithPrototype(builderResult)
  }
  func build() -> FullMenusRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FullMenusRequest {
    var returnMe:FullMenusRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:FullMenusRequest) -> FullMenusRequestBuilder {
    if (other == FullMenusRequest()) {
      return self
    }
  if other.hasLatitude {
       latitude = other.latitude
  }
  if other.hasLongitude {
       longitude = other.longitude
  }
  if other.hasIncludeAvailability {
       includeAvailability = other.includeAvailability
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FullMenusRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 9 :
        latitude = input.readDouble()

      case 17 :
        longitude = input.readDouble()

      case 24 :
        includeAvailability = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class FullMenusResponse : GeneratedMessage {


  //Nested type declaration start 

    final class Menu : GeneratedMessage {
      private(set) var hasTruckId:Bool = false
      private(set) var truckId:Int64 = 0

      private(set) var hasMenuId:Bool = false
      private(set) var menuId:Int64 = 0

      private(set) var category:Array<Category>  = Array<Category>()
      required init() {
           super.init()
      }
      override func isInitialized() -> Bool {
        if !hasTruckId {
          return false
        }
        if !hasMenuId {
          return false
        }
        var isInitcategory:Bool = true
        for element in category {
            if (!element.isInitialized()) {
                isInitcategory = false
                break 
            }
        }
        if !isInitcategory {
         return isInitcategory
         }
       return true
      }
      override func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasTruckId {
          output.writeInt64(1, value:truckId)
        }
        if hasMenuId {
          output.writeInt64(2, value:menuId)
        }
        for element in category {
            output.writeMessage(3, value:element)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasTruckId {
          size += WireFormat.computeInt64Size(1, value:truckId)
        }
        if hasMenuId {
          size += WireFormat.computeInt64Size(2, value:menuId)
        }
        for element in category {
            size += WireFormat.computeMessageSize(3, value:element)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponse.Menu {
        return FullMenusResponse.Menu.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> MenuBuilder {
        return MenuBuilder()
      }
      class func builderWithPrototype(prototype:Menu) -> MenuBuilder {
        return Menu.builder().mergeFrom(prototype)
      }
      func builder() -> MenuBuilder {
        return Menu.builder()
      }
      func toBuilder() -> MenuBuilder {
        return Menu.builderWithPrototype(self)
      }
      override func writeDescriptionTo(inout output:String, indent:String) {
        if hasTruckId {
          output += "\(indent) truckId: \(truckId) \n"
        }
        if hasMenuId {
          output += "\(indent) menuId: \(menuId) \n"
        }
        var categoryElementIndex:Int = 0
        for element in category {
            output += "\(indent) category[\(categoryElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            categoryElementIndex++
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasTruckId {
                 hashCode = (hashCode &* 31) &+ truckId.hashValue
              }
              if hasMenuId {
                 hashCode = (hashCode &* 31) &+ menuId.hashValue
              }
              for element in category {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }
    }

    final class MenuBuilder : GeneratedMessageBuilder {
      private var builderResult:FullMenusResponse.Menu

      required override init () {
         builderResult = FullMenusResponse.Menu()
         super.init()
      }
      var hasTruckId:Bool {
           get {
                return builderResult.hasTruckId
           }
      }
      var truckId:Int64 {
           get {
                return builderResult.truckId
           }
           set (value) {
               builderResult.hasTruckId = true
               builderResult.truckId = value
           }
      }
      func clearTruckId() -> FullMenusResponse.MenuBuilder{
           builderResult.hasTruckId = false
           builderResult.truckId = 0
           return self
      }
      var hasMenuId:Bool {
           get {
                return builderResult.hasMenuId
           }
      }
      var menuId:Int64 {
           get {
                return builderResult.menuId
           }
           set (value) {
               builderResult.hasMenuId = true
               builderResult.menuId = value
           }
      }
      func clearMenuId() -> FullMenusResponse.MenuBuilder{
           builderResult.hasMenuId = false
           builderResult.menuId = 0
           return self
      }
      var category:Array<Category> {
           get {
               return builderResult.category
           }
           set (value) {
               builderResult.category = value
           }
      }
      func clearCategory() -> FullMenusResponse.MenuBuilder {
        builderResult.category.removeAll(keepCapacity: false)
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> FullMenusResponse.MenuBuilder {
        builderResult = FullMenusResponse.Menu()
        return self
      }
      override func clone() -> FullMenusResponse.MenuBuilder {
        return FullMenusResponse.Menu.builderWithPrototype(builderResult)
      }
      func build() -> FullMenusResponse.Menu {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> FullMenusResponse.Menu {
        var returnMe:FullMenusResponse.Menu = builderResult
        return returnMe
      }
      func mergeFrom(other:FullMenusResponse.Menu) -> FullMenusResponse.MenuBuilder {
        if (other == FullMenusResponse.Menu()) {
          return self
        }
      if other.hasTruckId {
           truckId = other.truckId
      }
      if other.hasMenuId {
           menuId = other.menuId
      }
      if !other.category.isEmpty  {
         builderResult.category += other.category
      }
          mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->FullMenusResponse.MenuBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponse.MenuBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            truckId = input.readInt64()

          case 16 :
            menuId = input.readInt64()

          case 26 :
            var subBuilder = Category.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            category += [subBuilder.buildPartial()]

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end 

  private(set) var menu:Array<FullMenusResponse.Menu>  = Array<FullMenusResponse.Menu>()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    var isInitmenu:Bool = true
    for element in menu {
        if (!element.isInitialized()) {
            isInitmenu = false
            break 
        }
    }
    if !isInitmenu {
     return isInitmenu
     }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in menu {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in menu {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FullMenusResponse {
    return FullMenusResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FullMenusResponseBuilder {
    return FullMenusResponseBuilder()
  }
  class func builderWithPrototype(prototype:FullMenusResponse) -> FullMenusResponseBuilder {
    return FullMenusResponse.builder().mergeFrom(prototype)
  }
  func builder() -> FullMenusResponseBuilder {
    return FullMenusResponse.builder()
  }
  func toBuilder() -> FullMenusResponseBuilder {
    return FullMenusResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    var menuElementIndex:Int = 0
    for element in menu {
        output += "\(indent) menu[\(menuElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        menuElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in menu {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class FullMenusResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:FullMenusResponse

  required override init () {
     builderResult = FullMenusResponse()
     super.init()
  }
  var menu:Array<FullMenusResponse.Menu> {
       get {
           return builderResult.menu
       }
       set (value) {
           builderResult.menu = value
       }
  }
  func clearMenu() -> FullMenusResponseBuilder {
    builderResult.menu.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FullMenusResponseBuilder {
    builderResult = FullMenusResponse()
    return self
  }
  override func clone() -> FullMenusResponseBuilder {
    return FullMenusResponse.builderWithPrototype(builderResult)
  }
  func build() -> FullMenusResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FullMenusResponse {
    var returnMe:FullMenusResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:FullMenusResponse) -> FullMenusResponseBuilder {
    if (other == FullMenusResponse()) {
      return self
    }
  if !other.menu.isEmpty  {
     builderResult.menu += other.menu
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FullMenusResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = FullMenusResponse.Menu.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        menu += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuAvailabilityRequest : GeneratedMessage {
  private(set) var diff:Array<MenuItemAvailabilityDiff>  = Array<MenuItemAvailabilityDiff>()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    var isInitdiff:Bool = true
    for element in diff {
        if (!element.isInitialized()) {
            isInitdiff = false
            break 
        }
    }
    if !isInitdiff {
     return isInitdiff
     }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in diff {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in diff {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityRequest {
    return MenuAvailabilityRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuAvailabilityRequestBuilder {
    return MenuAvailabilityRequestBuilder()
  }
  class func builderWithPrototype(prototype:MenuAvailabilityRequest) -> MenuAvailabilityRequestBuilder {
    return MenuAvailabilityRequest.builder().mergeFrom(prototype)
  }
  func builder() -> MenuAvailabilityRequestBuilder {
    return MenuAvailabilityRequest.builder()
  }
  func toBuilder() -> MenuAvailabilityRequestBuilder {
    return MenuAvailabilityRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    var diffElementIndex:Int = 0
    for element in diff {
        output += "\(indent) diff[\(diffElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        diffElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in diff {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuAvailabilityRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuAvailabilityRequest

  required override init () {
     builderResult = MenuAvailabilityRequest()
     super.init()
  }
  var diff:Array<MenuItemAvailabilityDiff> {
       get {
           return builderResult.diff
       }
       set (value) {
           builderResult.diff = value
       }
  }
  func clearDiff() -> MenuAvailabilityRequestBuilder {
    builderResult.diff.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuAvailabilityRequestBuilder {
    builderResult = MenuAvailabilityRequest()
    return self
  }
  override func clone() -> MenuAvailabilityRequestBuilder {
    return MenuAvailabilityRequest.builderWithPrototype(builderResult)
  }
  func build() -> MenuAvailabilityRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuAvailabilityRequest {
    var returnMe:MenuAvailabilityRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuAvailabilityRequest) -> MenuAvailabilityRequestBuilder {
    if (other == MenuAvailabilityRequest()) {
      return self
    }
  if !other.diff.isEmpty  {
     builderResult.diff += other.diff
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuAvailabilityRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = MenuItemAvailabilityDiff.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        diff += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuAvailabilityResponse : GeneratedMessage {
  private(set) var hasVersion:Bool = false
  private(set) var version:Int64 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasVersion {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasVersion {
      output.writeInt64(1, value:version)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasVersion {
      size += WireFormat.computeInt64Size(1, value:version)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityResponse {
    return MenuAvailabilityResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuAvailabilityResponseBuilder {
    return MenuAvailabilityResponseBuilder()
  }
  class func builderWithPrototype(prototype:MenuAvailabilityResponse) -> MenuAvailabilityResponseBuilder {
    return MenuAvailabilityResponse.builder().mergeFrom(prototype)
  }
  func builder() -> MenuAvailabilityResponseBuilder {
    return MenuAvailabilityResponse.builder()
  }
  func toBuilder() -> MenuAvailabilityResponseBuilder {
    return MenuAvailabilityResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasVersion {
      output += "\(indent) version: \(version) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasVersion {
             hashCode = (hashCode &* 31) &+ version.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuAvailabilityResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuAvailabilityResponse

  required override init () {
     builderResult = MenuAvailabilityResponse()
     super.init()
  }
  var hasVersion:Bool {
       get {
            return builderResult.hasVersion
       }
  }
  var version:Int64 {
       get {
            return builderResult.version
       }
       set (value) {
           builderResult.hasVersion = true
           builderResult.version = value
       }
  }
  func clearVersion() -> MenuAvailabilityResponseBuilder{
       builderResult.hasVersion = false
       builderResult.version = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuAvailabilityResponseBuilder {
    builderResult = MenuAvailabilityResponse()
    return self
  }
  override func clone() -> MenuAvailabilityResponseBuilder {
    return MenuAvailabilityResponse.builderWithPrototype(builderResult)
  }
  func build() -> MenuAvailabilityResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuAvailabilityResponse {
    var returnMe:MenuAvailabilityResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuAvailabilityResponse) -> MenuAvailabilityResponseBuilder {
    if (other == MenuAvailabilityResponse()) {
      return self
    }
  if other.hasVersion {
       version = other.version
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuAvailabilityResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        version = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuItemRequest : GeneratedMessage {
  private(set) var hasCategoryId:Bool = false
  private(set) var categoryId:Int64 = 0

  private(set) var hasMenuItem:Bool = false
  private(set) var menuItem:MenuItem = MenuItem()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasCategoryId {
      return false
    }
    if !hasMenuItem {
      return false
    }
    if !menuItem.isInitialized() {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasCategoryId {
      output.writeInt64(1, value:categoryId)
    }
    if hasMenuItem {
      output.writeMessage(2, value:menuItem)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasCategoryId {
      size += WireFormat.computeInt64Size(1, value:categoryId)
    }
    if hasMenuItem {
      size += WireFormat.computeMessageSize(2, value:menuItem)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemRequest {
    return MenuItemRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemRequest {
    return MenuItemRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemRequest {
    return MenuItemRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemRequest {
    return MenuItemRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemRequest {
    return MenuItemRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemRequest {
    return MenuItemRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemRequestBuilder {
    return MenuItemRequestBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemRequest) -> MenuItemRequestBuilder {
    return MenuItemRequest.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemRequestBuilder {
    return MenuItemRequest.builder()
  }
  func toBuilder() -> MenuItemRequestBuilder {
    return MenuItemRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasCategoryId {
      output += "\(indent) categoryId: \(categoryId) \n"
    }
    if hasMenuItem {
      output += "\(indent) menuItem {\n"
      menuItem.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasCategoryId {
             hashCode = (hashCode &* 31) &+ categoryId.hashValue
          }
          if hasMenuItem {
            hashCode = (hashCode &* 31) &+ menuItem.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemRequest

  required override init () {
     builderResult = MenuItemRequest()
     super.init()
  }
  var hasCategoryId:Bool {
       get {
            return builderResult.hasCategoryId
       }
  }
  var categoryId:Int64 {
       get {
            return builderResult.categoryId
       }
       set (value) {
           builderResult.hasCategoryId = true
           builderResult.categoryId = value
       }
  }
  func clearCategoryId() -> MenuItemRequestBuilder{
       builderResult.hasCategoryId = false
       builderResult.categoryId = 0
       return self
  }
  var hasMenuItem:Bool {
       get {
           return builderResult.hasMenuItem
       }
  }
  var menuItem:MenuItem {
       get {
           return builderResult.menuItem     }
       set (value) {
           builderResult.hasMenuItem = true
           builderResult.menuItem = value
       }
  }
  func setMenuItemBuilder(builderForValue:MenuItemBuilder) -> MenuItemRequestBuilder {
    menuItem = builderForValue.build()
    return self
  }
  func mergeMenuItem(value:MenuItem) -> MenuItemRequestBuilder {
    if (builderResult.hasMenuItem && builderResult.menuItem != MenuItem()) {
      builderResult.menuItem = MenuItem.builderWithPrototype(builderResult.menuItem).mergeFrom(value).buildPartial()
    } else {
      builderResult.menuItem = value
    }
    builderResult.hasMenuItem = true
    return self
  }
  func clearMenuItem() -> MenuItemRequestBuilder {
    builderResult.hasMenuItem = false
    builderResult.menuItem = MenuItem()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemRequestBuilder {
    builderResult = MenuItemRequest()
    return self
  }
  override func clone() -> MenuItemRequestBuilder {
    return MenuItemRequest.builderWithPrototype(builderResult)
  }
  func build() -> MenuItemRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemRequest {
    var returnMe:MenuItemRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemRequest) -> MenuItemRequestBuilder {
    if (other == MenuItemRequest()) {
      return self
    }
  if other.hasCategoryId {
       categoryId = other.categoryId
  }
  if (other.hasMenuItem) {
      mergeMenuItem(other.menuItem)
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        categoryId = input.readInt64()

      case 18 :
        var subBuilder:MenuItemBuilder = MenuItem.builder()
        if hasMenuItem {
          subBuilder.mergeFrom(menuItem)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        menuItem = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuItemResponse : GeneratedMessage {
  private(set) var hasMenuItem:Bool = false
  private(set) var menuItem:MenuItem = MenuItem()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasMenuItem {
      return false
    }
    if !menuItem.isInitialized() {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMenuItem {
      output.writeMessage(1, value:menuItem)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMenuItem {
      size += WireFormat.computeMessageSize(1, value:menuItem)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemResponse {
    return MenuItemResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemResponse {
    return MenuItemResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemResponse {
    return MenuItemResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemResponse {
    return MenuItemResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemResponse {
    return MenuItemResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemResponse {
    return MenuItemResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemResponseBuilder {
    return MenuItemResponseBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemResponse) -> MenuItemResponseBuilder {
    return MenuItemResponse.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemResponseBuilder {
    return MenuItemResponse.builder()
  }
  func toBuilder() -> MenuItemResponseBuilder {
    return MenuItemResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasMenuItem {
      output += "\(indent) menuItem {\n"
      menuItem.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMenuItem {
            hashCode = (hashCode &* 31) &+ menuItem.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemResponse

  required override init () {
     builderResult = MenuItemResponse()
     super.init()
  }
  var hasMenuItem:Bool {
       get {
           return builderResult.hasMenuItem
       }
  }
  var menuItem:MenuItem {
       get {
           return builderResult.menuItem     }
       set (value) {
           builderResult.hasMenuItem = true
           builderResult.menuItem = value
       }
  }
  func setMenuItemBuilder(builderForValue:MenuItemBuilder) -> MenuItemResponseBuilder {
    menuItem = builderForValue.build()
    return self
  }
  func mergeMenuItem(value:MenuItem) -> MenuItemResponseBuilder {
    if (builderResult.hasMenuItem && builderResult.menuItem != MenuItem()) {
      builderResult.menuItem = MenuItem.builderWithPrototype(builderResult.menuItem).mergeFrom(value).buildPartial()
    } else {
      builderResult.menuItem = value
    }
    builderResult.hasMenuItem = true
    return self
  }
  func clearMenuItem() -> MenuItemResponseBuilder {
    builderResult.hasMenuItem = false
    builderResult.menuItem = MenuItem()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemResponseBuilder {
    builderResult = MenuItemResponse()
    return self
  }
  override func clone() -> MenuItemResponseBuilder {
    return MenuItemResponse.builderWithPrototype(builderResult)
  }
  func build() -> MenuItemResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemResponse {
    var returnMe:MenuItemResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemResponse) -> MenuItemResponseBuilder {
    if (other == MenuItemResponse()) {
      return self
    }
  if (other.hasMenuItem) {
      mergeMenuItem(other.menuItem)
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:MenuItemBuilder = MenuItem.builder()
        if hasMenuItem {
          subBuilder.mergeFrom(menuItem)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        menuItem = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class DeleteMenuItemRequest : GeneratedMessage {
  private(set) var hasMenuItemId:Bool = false
  private(set) var menuItemId:Int64 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasMenuItemId {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMenuItemId {
      output.writeInt64(1, value:menuItemId)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMenuItemId {
      size += WireFormat.computeInt64Size(1, value:menuItemId)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemRequest {
    return DeleteMenuItemRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DeleteMenuItemRequestBuilder {
    return DeleteMenuItemRequestBuilder()
  }
  class func builderWithPrototype(prototype:DeleteMenuItemRequest) -> DeleteMenuItemRequestBuilder {
    return DeleteMenuItemRequest.builder().mergeFrom(prototype)
  }
  func builder() -> DeleteMenuItemRequestBuilder {
    return DeleteMenuItemRequest.builder()
  }
  func toBuilder() -> DeleteMenuItemRequestBuilder {
    return DeleteMenuItemRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasMenuItemId {
      output += "\(indent) menuItemId: \(menuItemId) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMenuItemId {
             hashCode = (hashCode &* 31) &+ menuItemId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class DeleteMenuItemRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:DeleteMenuItemRequest

  required override init () {
     builderResult = DeleteMenuItemRequest()
     super.init()
  }
  var hasMenuItemId:Bool {
       get {
            return builderResult.hasMenuItemId
       }
  }
  var menuItemId:Int64 {
       get {
            return builderResult.menuItemId
       }
       set (value) {
           builderResult.hasMenuItemId = true
           builderResult.menuItemId = value
       }
  }
  func clearMenuItemId() -> DeleteMenuItemRequestBuilder{
       builderResult.hasMenuItemId = false
       builderResult.menuItemId = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DeleteMenuItemRequestBuilder {
    builderResult = DeleteMenuItemRequest()
    return self
  }
  override func clone() -> DeleteMenuItemRequestBuilder {
    return DeleteMenuItemRequest.builderWithPrototype(builderResult)
  }
  func build() -> DeleteMenuItemRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DeleteMenuItemRequest {
    var returnMe:DeleteMenuItemRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:DeleteMenuItemRequest) -> DeleteMenuItemRequestBuilder {
    if (other == DeleteMenuItemRequest()) {
      return self
    }
  if other.hasMenuItemId {
       menuItemId = other.menuItemId
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DeleteMenuItemRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        menuItemId = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class DeleteMenuItemResponse : GeneratedMessage {
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemResponse {
    return DeleteMenuItemResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DeleteMenuItemResponseBuilder {
    return DeleteMenuItemResponseBuilder()
  }
  class func builderWithPrototype(prototype:DeleteMenuItemResponse) -> DeleteMenuItemResponseBuilder {
    return DeleteMenuItemResponse.builder().mergeFrom(prototype)
  }
  func builder() -> DeleteMenuItemResponseBuilder {
    return DeleteMenuItemResponse.builder()
  }
  func toBuilder() -> DeleteMenuItemResponseBuilder {
    return DeleteMenuItemResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class DeleteMenuItemResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:DeleteMenuItemResponse

  required override init () {
     builderResult = DeleteMenuItemResponse()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DeleteMenuItemResponseBuilder {
    builderResult = DeleteMenuItemResponse()
    return self
  }
  override func clone() -> DeleteMenuItemResponseBuilder {
    return DeleteMenuItemResponse.builderWithPrototype(builderResult)
  }
  func build() -> DeleteMenuItemResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DeleteMenuItemResponse {
    var returnMe:DeleteMenuItemResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:DeleteMenuItemResponse) -> DeleteMenuItemResponseBuilder {
    if (other == DeleteMenuItemResponse()) {
      return self
    }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DeleteMenuItemResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class CategoryRequest : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:Int64 = -1

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInMenu:Bool = false
  private(set) var orderInMenu:Int32 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeInt64(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasNotes {
      output.writeString(3, value:notes)
    }
    if hasOrderInMenu {
      output.writeInt32(4, value:orderInMenu)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeInt64Size(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(3, value:notes)
    }
    if hasOrderInMenu {
      size += WireFormat.computeInt32Size(4, value:orderInMenu)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> CategoryRequest {
    return CategoryRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> CategoryRequest {
    return CategoryRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> CategoryRequest {
    return CategoryRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->CategoryRequest {
    return CategoryRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> CategoryRequest {
    return CategoryRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryRequest {
    return CategoryRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> CategoryRequestBuilder {
    return CategoryRequestBuilder()
  }
  class func builderWithPrototype(prototype:CategoryRequest) -> CategoryRequestBuilder {
    return CategoryRequest.builder().mergeFrom(prototype)
  }
  func builder() -> CategoryRequestBuilder {
    return CategoryRequest.builder()
  }
  func toBuilder() -> CategoryRequestBuilder {
    return CategoryRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    if hasOrderInMenu {
      output += "\(indent) orderInMenu: \(orderInMenu) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          if hasOrderInMenu {
             hashCode = (hashCode &* 31) &+ orderInMenu.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class CategoryRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:CategoryRequest

  required override init () {
     builderResult = CategoryRequest()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:Int64 {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> CategoryRequestBuilder{
       builderResult.hasId = false
       builderResult.id = -1
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> CategoryRequestBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> CategoryRequestBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var hasOrderInMenu:Bool {
       get {
            return builderResult.hasOrderInMenu
       }
  }
  var orderInMenu:Int32 {
       get {
            return builderResult.orderInMenu
       }
       set (value) {
           builderResult.hasOrderInMenu = true
           builderResult.orderInMenu = value
       }
  }
  func clearOrderInMenu() -> CategoryRequestBuilder{
       builderResult.hasOrderInMenu = false
       builderResult.orderInMenu = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> CategoryRequestBuilder {
    builderResult = CategoryRequest()
    return self
  }
  override func clone() -> CategoryRequestBuilder {
    return CategoryRequest.builderWithPrototype(builderResult)
  }
  func build() -> CategoryRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> CategoryRequest {
    var returnMe:CategoryRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:CategoryRequest) -> CategoryRequestBuilder {
    if (other == CategoryRequest()) {
      return self
    }
  if other.hasId {
       id = other.id
  }
  if other.hasName {
       name = other.name
  }
  if other.hasNotes {
       notes = other.notes
  }
  if other.hasOrderInMenu {
       orderInMenu = other.orderInMenu
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->CategoryRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        id = input.readInt64()

      case 18 :
        name = input.readString()

      case 26 :
        notes = input.readString()

      case 32 :
        orderInMenu = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class CategoryResponse : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:Int64 = 0

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInMenu:Bool = false
  private(set) var orderInMenu:Int32 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasId {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeInt64(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasNotes {
      output.writeString(3, value:notes)
    }
    if hasOrderInMenu {
      output.writeInt32(4, value:orderInMenu)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeInt64Size(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(3, value:notes)
    }
    if hasOrderInMenu {
      size += WireFormat.computeInt32Size(4, value:orderInMenu)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> CategoryResponse {
    return CategoryResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> CategoryResponse {
    return CategoryResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> CategoryResponse {
    return CategoryResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->CategoryResponse {
    return CategoryResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> CategoryResponse {
    return CategoryResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryResponse {
    return CategoryResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> CategoryResponseBuilder {
    return CategoryResponseBuilder()
  }
  class func builderWithPrototype(prototype:CategoryResponse) -> CategoryResponseBuilder {
    return CategoryResponse.builder().mergeFrom(prototype)
  }
  func builder() -> CategoryResponseBuilder {
    return CategoryResponse.builder()
  }
  func toBuilder() -> CategoryResponseBuilder {
    return CategoryResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    if hasOrderInMenu {
      output += "\(indent) orderInMenu: \(orderInMenu) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          if hasOrderInMenu {
             hashCode = (hashCode &* 31) &+ orderInMenu.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class CategoryResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:CategoryResponse

  required override init () {
     builderResult = CategoryResponse()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:Int64 {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> CategoryResponseBuilder{
       builderResult.hasId = false
       builderResult.id = 0
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> CategoryResponseBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> CategoryResponseBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var hasOrderInMenu:Bool {
       get {
            return builderResult.hasOrderInMenu
       }
  }
  var orderInMenu:Int32 {
       get {
            return builderResult.orderInMenu
       }
       set (value) {
           builderResult.hasOrderInMenu = true
           builderResult.orderInMenu = value
       }
  }
  func clearOrderInMenu() -> CategoryResponseBuilder{
       builderResult.hasOrderInMenu = false
       builderResult.orderInMenu = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> CategoryResponseBuilder {
    builderResult = CategoryResponse()
    return self
  }
  override func clone() -> CategoryResponseBuilder {
    return CategoryResponse.builderWithPrototype(builderResult)
  }
  func build() -> CategoryResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> CategoryResponse {
    var returnMe:CategoryResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:CategoryResponse) -> CategoryResponseBuilder {
    if (other == CategoryResponse()) {
      return self
    }
  if other.hasId {
       id = other.id
  }
  if other.hasName {
       name = other.name
  }
  if other.hasNotes {
       notes = other.notes
  }
  if other.hasOrderInMenu {
       orderInMenu = other.orderInMenu
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->CategoryResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        id = input.readInt64()

      case 18 :
        name = input.readString()

      case 26 :
        notes = input.readString()

      case 32 :
        orderInMenu = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class DeleteCategoryRequest : GeneratedMessage {
  private(set) var hasCategoryId:Bool = false
  private(set) var categoryId:Int64 = 0

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasCategoryId {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasCategoryId {
      output.writeInt64(1, value:categoryId)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasCategoryId {
      size += WireFormat.computeInt64Size(1, value:categoryId)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteCategoryRequest {
    return DeleteCategoryRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DeleteCategoryRequestBuilder {
    return DeleteCategoryRequestBuilder()
  }
  class func builderWithPrototype(prototype:DeleteCategoryRequest) -> DeleteCategoryRequestBuilder {
    return DeleteCategoryRequest.builder().mergeFrom(prototype)
  }
  func builder() -> DeleteCategoryRequestBuilder {
    return DeleteCategoryRequest.builder()
  }
  func toBuilder() -> DeleteCategoryRequestBuilder {
    return DeleteCategoryRequest.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasCategoryId {
      output += "\(indent) categoryId: \(categoryId) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasCategoryId {
             hashCode = (hashCode &* 31) &+ categoryId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class DeleteCategoryRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:DeleteCategoryRequest

  required override init () {
     builderResult = DeleteCategoryRequest()
     super.init()
  }
  var hasCategoryId:Bool {
       get {
            return builderResult.hasCategoryId
       }
  }
  var categoryId:Int64 {
       get {
            return builderResult.categoryId
       }
       set (value) {
           builderResult.hasCategoryId = true
           builderResult.categoryId = value
       }
  }
  func clearCategoryId() -> DeleteCategoryRequestBuilder{
       builderResult.hasCategoryId = false
       builderResult.categoryId = 0
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DeleteCategoryRequestBuilder {
    builderResult = DeleteCategoryRequest()
    return self
  }
  override func clone() -> DeleteCategoryRequestBuilder {
    return DeleteCategoryRequest.builderWithPrototype(builderResult)
  }
  func build() -> DeleteCategoryRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DeleteCategoryRequest {
    var returnMe:DeleteCategoryRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:DeleteCategoryRequest) -> DeleteCategoryRequestBuilder {
    if (other == DeleteCategoryRequest()) {
      return self
    }
  if other.hasCategoryId {
       categoryId = other.categoryId
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DeleteCategoryRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteCategoryRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        categoryId = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class DeleteCategoryResponse : GeneratedMessage {
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteCategoryResponse {
    return DeleteCategoryResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DeleteCategoryResponseBuilder {
    return DeleteCategoryResponseBuilder()
  }
  class func builderWithPrototype(prototype:DeleteCategoryResponse) -> DeleteCategoryResponseBuilder {
    return DeleteCategoryResponse.builder().mergeFrom(prototype)
  }
  func builder() -> DeleteCategoryResponseBuilder {
    return DeleteCategoryResponse.builder()
  }
  func toBuilder() -> DeleteCategoryResponseBuilder {
    return DeleteCategoryResponse.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class DeleteCategoryResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:DeleteCategoryResponse

  required override init () {
     builderResult = DeleteCategoryResponse()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DeleteCategoryResponseBuilder {
    builderResult = DeleteCategoryResponse()
    return self
  }
  override func clone() -> DeleteCategoryResponseBuilder {
    return DeleteCategoryResponse.builderWithPrototype(builderResult)
  }
  func build() -> DeleteCategoryResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DeleteCategoryResponse {
    var returnMe:DeleteCategoryResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:DeleteCategoryResponse) -> DeleteCategoryResponseBuilder {
    if (other == DeleteCategoryResponse()) {
      return self
    }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DeleteCategoryResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DeleteCategoryResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class Category : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:Int64 = 0

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInMenu:Bool = false
  private(set) var orderInMenu:Int32 = 0

  private(set) var menuItem:Array<MenuItem>  = Array<MenuItem>()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasId {
      return false
    }
    var isInitmenuItem:Bool = true
    for element in menuItem {
        if (!element.isInitialized()) {
            isInitmenuItem = false
            break 
        }
    }
    if !isInitmenuItem {
     return isInitmenuItem
     }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeInt64(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasNotes {
      output.writeString(3, value:notes)
    }
    if hasOrderInMenu {
      output.writeInt32(4, value:orderInMenu)
    }
    for element in menuItem {
        output.writeMessage(5, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeInt64Size(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(3, value:notes)
    }
    if hasOrderInMenu {
      size += WireFormat.computeInt32Size(4, value:orderInMenu)
    }
    for element in menuItem {
        size += WireFormat.computeMessageSize(5, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Category {
    return Category.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Category {
    return Category.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Category {
    return Category.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Category {
    return Category.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Category {
    return Category.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Category {
    return Category.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> CategoryBuilder {
    return CategoryBuilder()
  }
  class func builderWithPrototype(prototype:Category) -> CategoryBuilder {
    return Category.builder().mergeFrom(prototype)
  }
  func builder() -> CategoryBuilder {
    return Category.builder()
  }
  func toBuilder() -> CategoryBuilder {
    return Category.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    if hasOrderInMenu {
      output += "\(indent) orderInMenu: \(orderInMenu) \n"
    }
    var menuItemElementIndex:Int = 0
    for element in menuItem {
        output += "\(indent) menuItem[\(menuItemElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        menuItemElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          if hasOrderInMenu {
             hashCode = (hashCode &* 31) &+ orderInMenu.hashValue
          }
          for element in menuItem {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class CategoryBuilder : GeneratedMessageBuilder {
  private var builderResult:Category

  required override init () {
     builderResult = Category()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:Int64 {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> CategoryBuilder{
       builderResult.hasId = false
       builderResult.id = 0
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> CategoryBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> CategoryBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var hasOrderInMenu:Bool {
       get {
            return builderResult.hasOrderInMenu
       }
  }
  var orderInMenu:Int32 {
       get {
            return builderResult.orderInMenu
       }
       set (value) {
           builderResult.hasOrderInMenu = true
           builderResult.orderInMenu = value
       }
  }
  func clearOrderInMenu() -> CategoryBuilder{
       builderResult.hasOrderInMenu = false
       builderResult.orderInMenu = 0
       return self
  }
  var menuItem:Array<MenuItem> {
       get {
           return builderResult.menuItem
       }
       set (value) {
           builderResult.menuItem = value
       }
  }
  func clearMenuItem() -> CategoryBuilder {
    builderResult.menuItem.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> CategoryBuilder {
    builderResult = Category()
    return self
  }
  override func clone() -> CategoryBuilder {
    return Category.builderWithPrototype(builderResult)
  }
  func build() -> Category {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Category {
    var returnMe:Category = builderResult
    return returnMe
  }
  func mergeFrom(other:Category) -> CategoryBuilder {
    if (other == Category()) {
      return self
    }
  if other.hasId {
       id = other.id
  }
  if other.hasName {
       name = other.name
  }
  if other.hasNotes {
       notes = other.notes
  }
  if other.hasOrderInMenu {
       orderInMenu = other.orderInMenu
  }
  if !other.menuItem.isEmpty  {
     builderResult.menuItem += other.menuItem
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->CategoryBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        id = input.readInt64()

      case 18 :
        name = input.readString()

      case 26 :
        notes = input.readString()

      case 32 :
        orderInMenu = input.readInt32()

      case 42 :
        var subBuilder = MenuItem.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        menuItem += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuItem : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:Int64 = -1

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasPrice:Bool = false
  private(set) var price:Float = 0

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInCategory:Bool = false
  private(set) var orderInCategory:Int32 = 0

  private(set) var hasIsAvailable:Bool = false
  private(set) var isAvailable:Bool = false

  private(set) var tag:Array<String> = Array<String>()
  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasId {
      return false
    }
    if !hasName {
      return false
    }
    if !hasPrice {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeInt64(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasPrice {
      output.writeFloat(3, value:price)
    }
    if hasNotes {
      output.writeString(4, value:notes)
    }
    if !tag.isEmpty {
      for value in tag {
        output.writeString(5, value:value)
      }
    }
    if hasOrderInCategory {
      output.writeInt32(6, value:orderInCategory)
    }
    if hasIsAvailable {
      output.writeBool(7, value:isAvailable)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeInt64Size(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasPrice {
      size += WireFormat.computeFloatSize(3, value:price)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(4, value:notes)
    }
    var dataSizeTag:Int32 = 0
    for element in tag {
        dataSizeTag += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeTag
    size += 1 * Int32(tag.count)
    if hasOrderInCategory {
      size += WireFormat.computeInt32Size(6, value:orderInCategory)
    }
    if hasIsAvailable {
      size += WireFormat.computeBoolSize(7, value:isAvailable)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItem {
    return MenuItem.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItem {
    return MenuItem.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItem {
    return MenuItem.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItem {
    return MenuItem.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItem {
    return MenuItem.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItem {
    return MenuItem.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemBuilder {
    return MenuItemBuilder()
  }
  class func builderWithPrototype(prototype:MenuItem) -> MenuItemBuilder {
    return MenuItem.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemBuilder {
    return MenuItem.builder()
  }
  func toBuilder() -> MenuItemBuilder {
    return MenuItem.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasPrice {
      output += "\(indent) price: \(price) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    var tagElementIndex:Int = 0
    for element in tag  {
        output += "\(indent) tag[\(tagElementIndex)]: \(element)\n"
        tagElementIndex++
    }
    if hasOrderInCategory {
      output += "\(indent) orderInCategory: \(orderInCategory) \n"
    }
    if hasIsAvailable {
      output += "\(indent) isAvailable: \(isAvailable) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasPrice {
             hashCode = (hashCode &* 31) &+ price.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          for element in tag {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOrderInCategory {
             hashCode = (hashCode &* 31) &+ orderInCategory.hashValue
          }
          if hasIsAvailable {
             hashCode = (hashCode &* 31) &+ isAvailable.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItem

  required override init () {
     builderResult = MenuItem()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:Int64 {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> MenuItemBuilder{
       builderResult.hasId = false
       builderResult.id = -1
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> MenuItemBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasPrice:Bool {
       get {
            return builderResult.hasPrice
       }
  }
  var price:Float {
       get {
            return builderResult.price
       }
       set (value) {
           builderResult.hasPrice = true
           builderResult.price = value
       }
  }
  func clearPrice() -> MenuItemBuilder{
       builderResult.hasPrice = false
       builderResult.price = 0
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> MenuItemBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var tag:Array<String> {
       get {
           return builderResult.tag
       }
       set (array) {
           builderResult.tag = array
       }
  }
  func clearTag() -> MenuItemBuilder {
     builderResult.tag.removeAll(keepCapacity: false)
     return self
  }
  var hasOrderInCategory:Bool {
       get {
            return builderResult.hasOrderInCategory
       }
  }
  var orderInCategory:Int32 {
       get {
            return builderResult.orderInCategory
       }
       set (value) {
           builderResult.hasOrderInCategory = true
           builderResult.orderInCategory = value
       }
  }
  func clearOrderInCategory() -> MenuItemBuilder{
       builderResult.hasOrderInCategory = false
       builderResult.orderInCategory = 0
       return self
  }
  var hasIsAvailable:Bool {
       get {
            return builderResult.hasIsAvailable
       }
  }
  var isAvailable:Bool {
       get {
            return builderResult.isAvailable
       }
       set (value) {
           builderResult.hasIsAvailable = true
           builderResult.isAvailable = value
       }
  }
  func clearIsAvailable() -> MenuItemBuilder{
       builderResult.hasIsAvailable = false
       builderResult.isAvailable = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemBuilder {
    builderResult = MenuItem()
    return self
  }
  override func clone() -> MenuItemBuilder {
    return MenuItem.builderWithPrototype(builderResult)
  }
  func build() -> MenuItem {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItem {
    var returnMe:MenuItem = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItem) -> MenuItemBuilder {
    if (other == MenuItem()) {
      return self
    }
  if other.hasId {
       id = other.id
  }
  if other.hasName {
       name = other.name
  }
  if other.hasPrice {
       price = other.price
  }
  if other.hasNotes {
       notes = other.notes
  }
  if !other.tag.isEmpty {
      builderResult.tag += other.tag
  }
  if other.hasOrderInCategory {
       orderInCategory = other.orderInCategory
  }
  if other.hasIsAvailable {
       isAvailable = other.isAvailable
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        id = input.readInt64()

      case 18 :
        name = input.readString()

      case 29 :
        price = input.readFloat()

      case 34 :
        notes = input.readString()

      case 42 :
        self.tag += [input.readString()]

      case 48 :
        orderInCategory = input.readInt32()

      case 56 :
        isAvailable = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final class MenuItemAvailabilityDiff : GeneratedMessage {
  private(set) var hasMenuItemId:Bool = false
  private(set) var menuItemId:Int64 = 0

  private(set) var hasIsAvailable:Bool = false
  private(set) var isAvailable:Bool = false

  required init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !hasMenuItemId {
      return false
    }
    if !hasIsAvailable {
      return false
    }
   return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMenuItemId {
      output.writeInt64(1, value:menuItemId)
    }
    if hasIsAvailable {
      output.writeBool(2, value:isAvailable)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMenuItemId {
      size += WireFormat.computeInt64Size(1, value:menuItemId)
    }
    if hasIsAvailable {
      size += WireFormat.computeBoolSize(2, value:isAvailable)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiff {
    return MenuItemAvailabilityDiff.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityDiffBuilder {
    return MenuItemAvailabilityDiffBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailabilityDiff) -> MenuItemAvailabilityDiffBuilder {
    return MenuItemAvailabilityDiff.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityDiffBuilder {
    return MenuItemAvailabilityDiff.builder()
  }
  func toBuilder() -> MenuItemAvailabilityDiffBuilder {
    return MenuItemAvailabilityDiff.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasMenuItemId {
      output += "\(indent) menuItemId: \(menuItemId) \n"
    }
    if hasIsAvailable {
      output += "\(indent) isAvailable: \(isAvailable) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMenuItemId {
             hashCode = (hashCode &* 31) &+ menuItemId.hashValue
          }
          if hasIsAvailable {
             hashCode = (hashCode &* 31) &+ isAvailable.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }
}

final class MenuItemAvailabilityDiffBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailabilityDiff

  required override init () {
     builderResult = MenuItemAvailabilityDiff()
     super.init()
  }
  var hasMenuItemId:Bool {
       get {
            return builderResult.hasMenuItemId
       }
  }
  var menuItemId:Int64 {
       get {
            return builderResult.menuItemId
       }
       set (value) {
           builderResult.hasMenuItemId = true
           builderResult.menuItemId = value
       }
  }
  func clearMenuItemId() -> MenuItemAvailabilityDiffBuilder{
       builderResult.hasMenuItemId = false
       builderResult.menuItemId = 0
       return self
  }
  var hasIsAvailable:Bool {
       get {
            return builderResult.hasIsAvailable
       }
  }
  var isAvailable:Bool {
       get {
            return builderResult.isAvailable
       }
       set (value) {
           builderResult.hasIsAvailable = true
           builderResult.isAvailable = value
       }
  }
  func clearIsAvailable() -> MenuItemAvailabilityDiffBuilder{
       builderResult.hasIsAvailable = false
       builderResult.isAvailable = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityDiffBuilder {
    builderResult = MenuItemAvailabilityDiff()
    return self
  }
  override func clone() -> MenuItemAvailabilityDiffBuilder {
    return MenuItemAvailabilityDiff.builderWithPrototype(builderResult)
  }
  func build() -> MenuItemAvailabilityDiff {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailabilityDiff {
    var returnMe:MenuItemAvailabilityDiff = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailabilityDiff) -> MenuItemAvailabilityDiffBuilder {
    if (other == MenuItemAvailabilityDiff()) {
      return self
    }
  if other.hasMenuItemId {
       menuItemId = other.menuItemId
  }
  if other.hasIsAvailable {
       isAvailable = other.isAvailable
  }
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityDiffBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        menuItemId = input.readInt64()

      case 16 :
        isAvailable = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension MenuItemAvailabilityDiffRequest {
    class func parseFromNSData(data:NSData) -> MenuItemAvailabilityDiffRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiffRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiffRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemAvailabilityDiffResponse {
    class func parseFromNSData(data:NSData) -> MenuItemAvailabilityDiffResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiffResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiffResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiffResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FullMenusRequest {
    class func parseFromNSData(data:NSData) -> FullMenusRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FullMenusResponse.Menu {
    class func parseFromNSData(data:NSData) -> FullMenusResponse.Menu {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.Menu.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FullMenusResponse.Menu {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.Menu.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FullMenusResponse {
    class func parseFromNSData(data:NSData) -> FullMenusResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuAvailabilityRequest {
    class func parseFromNSData(data:NSData) -> MenuAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuAvailabilityRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuAvailabilityRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuAvailabilityResponse {
    class func parseFromNSData(data:NSData) -> MenuAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuAvailabilityResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuAvailabilityResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemRequest {
    class func parseFromNSData(data:NSData) -> MenuItemRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemResponse {
    class func parseFromNSData(data:NSData) -> MenuItemResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension DeleteMenuItemRequest {
    class func parseFromNSData(data:NSData) -> DeleteMenuItemRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteMenuItemRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteMenuItemRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension DeleteMenuItemResponse {
    class func parseFromNSData(data:NSData) -> DeleteMenuItemResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteMenuItemResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DeleteMenuItemResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteMenuItemResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension CategoryRequest {
    class func parseFromNSData(data:NSData) -> CategoryRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return CategoryRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> CategoryRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return CategoryRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension CategoryResponse {
    class func parseFromNSData(data:NSData) -> CategoryResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return CategoryResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> CategoryResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return CategoryResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension DeleteCategoryRequest {
    class func parseFromNSData(data:NSData) -> DeleteCategoryRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteCategoryRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DeleteCategoryRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteCategoryRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension DeleteCategoryResponse {
    class func parseFromNSData(data:NSData) -> DeleteCategoryResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteCategoryResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DeleteCategoryResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DeleteCategoryResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Category {
    class func parseFromNSData(data:NSData) -> Category {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Category.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Category {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Category.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItem {
    class func parseFromNSData(data:NSData) -> MenuItem {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItem.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItem {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItem.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemAvailabilityDiff {
    class func parseFromNSData(data:NSData) -> MenuItemAvailabilityDiff {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiff.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityDiff {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityDiff.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
