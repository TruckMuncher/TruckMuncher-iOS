// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

struct MenuRoot {
  static var sharedInstance : MenuRoot {
   struct Static {
       static let instance : MenuRoot = MenuRoot()
   }
   return Static.instance
  }
  var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

func == (lhs: MenuItemAvailabilityRequest, rhs: MenuItemAvailabilityRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemAvailabilityResponse, rhs: MenuItemAvailabilityResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.availabilities == rhs.availabilities)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FullMenusRequest, rhs: FullMenusRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasIncludeAvailability == rhs.hasIncludeAvailability) && (!lhs.hasIncludeAvailability || lhs.includeAvailability == rhs.includeAvailability)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FullMenusResponse, rhs: FullMenusResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.menus == rhs.menus)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuRequest, rhs: MenuRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTruckId == rhs.hasTruckId) && (!lhs.hasTruckId || lhs.truckId == rhs.truckId)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuResponse, rhs: MenuResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMenu == rhs.hasMenu) && (!lhs.hasMenu || lhs.menu == rhs.menu)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: ModifyMenuItemAvailabilityRequest, rhs: ModifyMenuItemAvailabilityRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.diff == rhs.diff)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: ModifyMenuItemAvailabilityResponse, rhs: ModifyMenuItemAvailabilityResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Menu, rhs: Menu) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTruckId == rhs.hasTruckId) && (!lhs.hasTruckId || lhs.truckId == rhs.truckId)
  fieldCheck = fieldCheck && (lhs.categories == rhs.categories)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Category, rhs: Category) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.hasOrderInMenu == rhs.hasOrderInMenu) && (!lhs.hasOrderInMenu || lhs.orderInMenu == rhs.orderInMenu)
  fieldCheck = fieldCheck && (lhs.menuItems == rhs.menuItems)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItem, rhs: MenuItem) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasPrice == rhs.hasPrice) && (!lhs.hasPrice || lhs.price == rhs.price)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.tags == rhs.tags)
  fieldCheck = fieldCheck && (lhs.hasOrderInCategory == rhs.hasOrderInCategory) && (!lhs.hasOrderInCategory || lhs.orderInCategory == rhs.orderInCategory)
  fieldCheck = fieldCheck && (lhs.hasIsAvailable == rhs.hasIsAvailable) && (!lhs.hasIsAvailable || lhs.isAvailable == rhs.isAvailable)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MenuItemAvailability, rhs: MenuItemAvailability) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMenuItemId == rhs.hasMenuItemId) && (!lhs.hasMenuItemId || lhs.menuItemId == rhs.menuItemId)
  fieldCheck = fieldCheck && (lhs.hasIsAvailable == rhs.hasIsAvailable) && (!lhs.hasIsAvailable || lhs.isAvailable == rhs.isAvailable)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class MenuItemAvailabilityRequest : GeneratedMessage {
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Double = Double(0)

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Double = Double(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasLatitude {
      output.writeDouble(1, value:latitude)
    }
    if hasLongitude {
      output.writeDouble(2, value:longitude)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasLatitude {
      size += WireFormat.computeDoubleSize(1, value:latitude)
    }
    if hasLongitude {
      size += WireFormat.computeDoubleSize(2, value:longitude)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityRequest {
    return MenuItemAvailabilityRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityRequestBuilder {
    return MenuItemAvailabilityRequestBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailabilityRequest) -> MenuItemAvailabilityRequestBuilder {
    return MenuItemAvailabilityRequest.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityRequestBuilder {
    return MenuItemAvailabilityRequest.builder()
  }
  func toBuilder() -> MenuItemAvailabilityRequestBuilder {
    return MenuItemAvailabilityRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuItemAvailabilityRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuItemAvailabilityRequest.self
  }


  //Meta information declaration end

}

final class MenuItemAvailabilityRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailabilityRequest

  required override init () {
     builderResult = MenuItemAvailabilityRequest()
     super.init()
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Double {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func clearLatitude() -> MenuItemAvailabilityRequestBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = Double(0)
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Double {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func clearLongitude() -> MenuItemAvailabilityRequestBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = Double(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityRequestBuilder {
    builderResult = MenuItemAvailabilityRequest()
    return self
  }
  override func clone() -> MenuItemAvailabilityRequestBuilder {
    return MenuItemAvailabilityRequest.builderWithPrototype(builderResult)
  }
  override func build() -> MenuItemAvailabilityRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailabilityRequest {
    var returnMe:MenuItemAvailabilityRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailabilityRequest) -> MenuItemAvailabilityRequestBuilder {
    if (other == MenuItemAvailabilityRequest()) {
     return self
    }
    if other.hasLatitude {
         latitude = other.latitude
    }
    if other.hasLongitude {
         longitude = other.longitude
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 9 :
        latitude = input.readDouble()

      case 17 :
        longitude = input.readDouble()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MenuItemAvailabilityResponse : GeneratedMessage {
  private(set) var availabilities:Array<MenuItemAvailability>  = Array<MenuItemAvailability>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitavailabilities:Bool = true
    for element in availabilities {
        if (!element.isInitialized()) {
            isInitavailabilities = false
            break 
        }
    }
    if !isInitavailabilities {
     return isInitavailabilities
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in availabilities {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in availabilities {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityResponse {
    return MenuItemAvailabilityResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityResponseBuilder {
    return MenuItemAvailabilityResponseBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailabilityResponse) -> MenuItemAvailabilityResponseBuilder {
    return MenuItemAvailabilityResponse.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityResponseBuilder {
    return MenuItemAvailabilityResponse.builder()
  }
  func toBuilder() -> MenuItemAvailabilityResponseBuilder {
    return MenuItemAvailabilityResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var availabilitiesElementIndex:Int = 0
    for element in availabilities {
        output += "\(indent) availabilities[\(availabilitiesElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        availabilitiesElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in availabilities {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuItemAvailabilityResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuItemAvailabilityResponse.self
  }


  //Meta information declaration end

}

final class MenuItemAvailabilityResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailabilityResponse

  required override init () {
     builderResult = MenuItemAvailabilityResponse()
     super.init()
  }
  var availabilities:Array<MenuItemAvailability> {
       get {
           return builderResult.availabilities
       }
       set (value) {
           builderResult.availabilities = value
       }
  }
  func clearAvailabilities() -> MenuItemAvailabilityResponseBuilder {
    builderResult.availabilities.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityResponseBuilder {
    builderResult = MenuItemAvailabilityResponse()
    return self
  }
  override func clone() -> MenuItemAvailabilityResponseBuilder {
    return MenuItemAvailabilityResponse.builderWithPrototype(builderResult)
  }
  override func build() -> MenuItemAvailabilityResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailabilityResponse {
    var returnMe:MenuItemAvailabilityResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailabilityResponse) -> MenuItemAvailabilityResponseBuilder {
    if (other == MenuItemAvailabilityResponse()) {
     return self
    }
    if !other.availabilities.isEmpty  {
       builderResult.availabilities += other.availabilities
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = MenuItemAvailability.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        availabilities += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FullMenusRequest : GeneratedMessage {
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Double = Double(0)

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Double = Double(0)

  private(set) var hasIncludeAvailability:Bool = false
  private(set) var includeAvailability:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasLatitude {
      return false
    }
    if !hasLongitude {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasLatitude {
      output.writeDouble(1, value:latitude)
    }
    if hasLongitude {
      output.writeDouble(2, value:longitude)
    }
    if hasIncludeAvailability {
      output.writeBool(3, value:includeAvailability)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasLatitude {
      size += WireFormat.computeDoubleSize(1, value:latitude)
    }
    if hasLongitude {
      size += WireFormat.computeDoubleSize(2, value:longitude)
    }
    if hasIncludeAvailability {
      size += WireFormat.computeBoolSize(3, value:includeAvailability)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FullMenusRequest {
    return FullMenusRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
    return FullMenusRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FullMenusRequestBuilder {
    return FullMenusRequestBuilder()
  }
  class func builderWithPrototype(prototype:FullMenusRequest) -> FullMenusRequestBuilder {
    return FullMenusRequest.builder().mergeFrom(prototype)
  }
  func builder() -> FullMenusRequestBuilder {
    return FullMenusRequest.builder()
  }
  func toBuilder() -> FullMenusRequestBuilder {
    return FullMenusRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    if hasIncludeAvailability {
      output += "\(indent) includeAvailability: \(includeAvailability) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          if hasIncludeAvailability {
             hashCode = (hashCode &* 31) &+ includeAvailability.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FullMenusRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FullMenusRequest.self
  }


  //Meta information declaration end

}

final class FullMenusRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:FullMenusRequest

  required override init () {
     builderResult = FullMenusRequest()
     super.init()
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Double {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func clearLatitude() -> FullMenusRequestBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = Double(0)
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Double {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func clearLongitude() -> FullMenusRequestBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = Double(0)
       return self
  }
  var hasIncludeAvailability:Bool {
       get {
            return builderResult.hasIncludeAvailability
       }
  }
  var includeAvailability:Bool {
       get {
            return builderResult.includeAvailability
       }
       set (value) {
           builderResult.hasIncludeAvailability = true
           builderResult.includeAvailability = value
       }
  }
  func clearIncludeAvailability() -> FullMenusRequestBuilder{
       builderResult.hasIncludeAvailability = false
       builderResult.includeAvailability = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FullMenusRequestBuilder {
    builderResult = FullMenusRequest()
    return self
  }
  override func clone() -> FullMenusRequestBuilder {
    return FullMenusRequest.builderWithPrototype(builderResult)
  }
  override func build() -> FullMenusRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FullMenusRequest {
    var returnMe:FullMenusRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:FullMenusRequest) -> FullMenusRequestBuilder {
    if (other == FullMenusRequest()) {
     return self
    }
    if other.hasLatitude {
         latitude = other.latitude
    }
    if other.hasLongitude {
         longitude = other.longitude
    }
    if other.hasIncludeAvailability {
         includeAvailability = other.includeAvailability
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FullMenusRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 9 :
        latitude = input.readDouble()

      case 17 :
        longitude = input.readDouble()

      case 24 :
        includeAvailability = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FullMenusResponse : GeneratedMessage {
  private(set) var menus:Array<Menu>  = Array<Menu>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitmenus:Bool = true
    for element in menus {
        if (!element.isInitialized()) {
            isInitmenus = false
            break 
        }
    }
    if !isInitmenus {
     return isInitmenus
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in menus {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in menus {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FullMenusResponse {
    return FullMenusResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
    return FullMenusResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FullMenusResponseBuilder {
    return FullMenusResponseBuilder()
  }
  class func builderWithPrototype(prototype:FullMenusResponse) -> FullMenusResponseBuilder {
    return FullMenusResponse.builder().mergeFrom(prototype)
  }
  func builder() -> FullMenusResponseBuilder {
    return FullMenusResponse.builder()
  }
  func toBuilder() -> FullMenusResponseBuilder {
    return FullMenusResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var menusElementIndex:Int = 0
    for element in menus {
        output += "\(indent) menus[\(menusElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        menusElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in menus {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FullMenusResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FullMenusResponse.self
  }


  //Meta information declaration end

}

final class FullMenusResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:FullMenusResponse

  required override init () {
     builderResult = FullMenusResponse()
     super.init()
  }
  var menus:Array<Menu> {
       get {
           return builderResult.menus
       }
       set (value) {
           builderResult.menus = value
       }
  }
  func clearMenus() -> FullMenusResponseBuilder {
    builderResult.menus.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FullMenusResponseBuilder {
    builderResult = FullMenusResponse()
    return self
  }
  override func clone() -> FullMenusResponseBuilder {
    return FullMenusResponse.builderWithPrototype(builderResult)
  }
  override func build() -> FullMenusResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FullMenusResponse {
    var returnMe:FullMenusResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:FullMenusResponse) -> FullMenusResponseBuilder {
    if (other == FullMenusResponse()) {
     return self
    }
    if !other.menus.isEmpty  {
       builderResult.menus += other.menus
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FullMenusResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FullMenusResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = Menu.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        menus += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MenuRequest : GeneratedMessage {
  private(set) var hasTruckId:Bool = false
  private(set) var truckId:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasTruckId {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasTruckId {
      output.writeString(1, value:truckId)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasTruckId {
      size += WireFormat.computeStringSize(1, value:truckId)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuRequest {
    return MenuRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuRequest {
    return MenuRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuRequest {
    return MenuRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuRequest {
    return MenuRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuRequest {
    return MenuRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuRequest {
    return MenuRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuRequestBuilder {
    return MenuRequestBuilder()
  }
  class func builderWithPrototype(prototype:MenuRequest) -> MenuRequestBuilder {
    return MenuRequest.builder().mergeFrom(prototype)
  }
  func builder() -> MenuRequestBuilder {
    return MenuRequest.builder()
  }
  func toBuilder() -> MenuRequestBuilder {
    return MenuRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasTruckId {
      output += "\(indent) truckId: \(truckId) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTruckId {
             hashCode = (hashCode &* 31) &+ truckId.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuRequest.self
  }


  //Meta information declaration end

}

final class MenuRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuRequest

  required override init () {
     builderResult = MenuRequest()
     super.init()
  }
  var hasTruckId:Bool {
       get {
            return builderResult.hasTruckId
       }
  }
  var truckId:String {
       get {
            return builderResult.truckId
       }
       set (value) {
           builderResult.hasTruckId = true
           builderResult.truckId = value
       }
  }
  func clearTruckId() -> MenuRequestBuilder{
       builderResult.hasTruckId = false
       builderResult.truckId = ""
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuRequestBuilder {
    builderResult = MenuRequest()
    return self
  }
  override func clone() -> MenuRequestBuilder {
    return MenuRequest.builderWithPrototype(builderResult)
  }
  override func build() -> MenuRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuRequest {
    var returnMe:MenuRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuRequest) -> MenuRequestBuilder {
    if (other == MenuRequest()) {
     return self
    }
    if other.hasTruckId {
         truckId = other.truckId
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        truckId = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MenuResponse : GeneratedMessage {
  private(set) var hasMenu:Bool = false
  private(set) var menu:Menu = Menu()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasMenu {
      return false
    }
    if !menu.isInitialized() {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMenu {
      output.writeMessage(1, value:menu)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMenu {
      size += WireFormat.computeMessageSize(1, value:menu)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuResponse {
    return MenuResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuResponse {
    return MenuResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuResponse {
    return MenuResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuResponse {
    return MenuResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuResponse {
    return MenuResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuResponse {
    return MenuResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuResponseBuilder {
    return MenuResponseBuilder()
  }
  class func builderWithPrototype(prototype:MenuResponse) -> MenuResponseBuilder {
    return MenuResponse.builder().mergeFrom(prototype)
  }
  func builder() -> MenuResponseBuilder {
    return MenuResponse.builder()
  }
  func toBuilder() -> MenuResponseBuilder {
    return MenuResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasMenu {
      output += "\(indent) menu {\n"
      menu.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMenu {
            hashCode = (hashCode &* 31) &+ menu.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuResponse.self
  }


  //Meta information declaration end

}

final class MenuResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuResponse

  required override init () {
     builderResult = MenuResponse()
     super.init()
  }
  var hasMenu:Bool {
       get {
           return builderResult.hasMenu
       }
  }
  var menu:Menu {
       get {
           return builderResult.menu
       }
       set (value) {
           builderResult.hasMenu = true
           builderResult.menu = value
       }
  }
  func setMenuBuilder(builderForValue:MenuBuilder) -> MenuResponseBuilder {
    menu = builderForValue.build()
    return self
  }
  func mergeMenu(value:Menu) -> MenuResponseBuilder {
    if (builderResult.hasMenu && builderResult.menu != Menu()) {
      builderResult.menu = Menu.builderWithPrototype(builderResult.menu).mergeFrom(value).buildPartial()
    } else {
      builderResult.menu = value
    }
    builderResult.hasMenu = true
    return self
  }
  func clearMenu() -> MenuResponseBuilder {
    builderResult.hasMenu = false
    builderResult.menu = Menu()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuResponseBuilder {
    builderResult = MenuResponse()
    return self
  }
  override func clone() -> MenuResponseBuilder {
    return MenuResponse.builderWithPrototype(builderResult)
  }
  override func build() -> MenuResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuResponse {
    var returnMe:MenuResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuResponse) -> MenuResponseBuilder {
    if (other == MenuResponse()) {
     return self
    }
    if (other.hasMenu) {
        mergeMenu(other.menu)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:MenuBuilder = Menu.builder()
        if hasMenu {
          subBuilder.mergeFrom(menu)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        menu = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ModifyMenuItemAvailabilityRequest : GeneratedMessage {
  private(set) var diff:Array<MenuItemAvailability>  = Array<MenuItemAvailability>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitdiff:Bool = true
    for element in diff {
        if (!element.isInitialized()) {
            isInitdiff = false
            break 
        }
    }
    if !isInitdiff {
     return isInitdiff
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in diff {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in diff {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityRequest {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> ModifyMenuItemAvailabilityRequestBuilder {
    return ModifyMenuItemAvailabilityRequestBuilder()
  }
  class func builderWithPrototype(prototype:ModifyMenuItemAvailabilityRequest) -> ModifyMenuItemAvailabilityRequestBuilder {
    return ModifyMenuItemAvailabilityRequest.builder().mergeFrom(prototype)
  }
  func builder() -> ModifyMenuItemAvailabilityRequestBuilder {
    return ModifyMenuItemAvailabilityRequest.builder()
  }
  func toBuilder() -> ModifyMenuItemAvailabilityRequestBuilder {
    return ModifyMenuItemAvailabilityRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var diffElementIndex:Int = 0
    for element in diff {
        output += "\(indent) diff[\(diffElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        diffElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in diff {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ModifyMenuItemAvailabilityRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ModifyMenuItemAvailabilityRequest.self
  }


  //Meta information declaration end

}

final class ModifyMenuItemAvailabilityRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:ModifyMenuItemAvailabilityRequest

  required override init () {
     builderResult = ModifyMenuItemAvailabilityRequest()
     super.init()
  }
  var diff:Array<MenuItemAvailability> {
       get {
           return builderResult.diff
       }
       set (value) {
           builderResult.diff = value
       }
  }
  func clearDiff() -> ModifyMenuItemAvailabilityRequestBuilder {
    builderResult.diff.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> ModifyMenuItemAvailabilityRequestBuilder {
    builderResult = ModifyMenuItemAvailabilityRequest()
    return self
  }
  override func clone() -> ModifyMenuItemAvailabilityRequestBuilder {
    return ModifyMenuItemAvailabilityRequest.builderWithPrototype(builderResult)
  }
  override func build() -> ModifyMenuItemAvailabilityRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> ModifyMenuItemAvailabilityRequest {
    var returnMe:ModifyMenuItemAvailabilityRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:ModifyMenuItemAvailabilityRequest) -> ModifyMenuItemAvailabilityRequestBuilder {
    if (other == ModifyMenuItemAvailabilityRequest()) {
     return self
    }
    if !other.diff.isEmpty  {
       builderResult.diff += other.diff
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->ModifyMenuItemAvailabilityRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = MenuItemAvailability.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        diff += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ModifyMenuItemAvailabilityResponse : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityResponse {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> ModifyMenuItemAvailabilityResponseBuilder {
    return ModifyMenuItemAvailabilityResponseBuilder()
  }
  class func builderWithPrototype(prototype:ModifyMenuItemAvailabilityResponse) -> ModifyMenuItemAvailabilityResponseBuilder {
    return ModifyMenuItemAvailabilityResponse.builder().mergeFrom(prototype)
  }
  func builder() -> ModifyMenuItemAvailabilityResponseBuilder {
    return ModifyMenuItemAvailabilityResponse.builder()
  }
  func toBuilder() -> ModifyMenuItemAvailabilityResponseBuilder {
    return ModifyMenuItemAvailabilityResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ModifyMenuItemAvailabilityResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ModifyMenuItemAvailabilityResponse.self
  }


  //Meta information declaration end

}

final class ModifyMenuItemAvailabilityResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:ModifyMenuItemAvailabilityResponse

  required override init () {
     builderResult = ModifyMenuItemAvailabilityResponse()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> ModifyMenuItemAvailabilityResponseBuilder {
    builderResult = ModifyMenuItemAvailabilityResponse()
    return self
  }
  override func clone() -> ModifyMenuItemAvailabilityResponseBuilder {
    return ModifyMenuItemAvailabilityResponse.builderWithPrototype(builderResult)
  }
  override func build() -> ModifyMenuItemAvailabilityResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> ModifyMenuItemAvailabilityResponse {
    var returnMe:ModifyMenuItemAvailabilityResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:ModifyMenuItemAvailabilityResponse) -> ModifyMenuItemAvailabilityResponseBuilder {
    if (other == ModifyMenuItemAvailabilityResponse()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->ModifyMenuItemAvailabilityResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Menu : GeneratedMessage {
  private(set) var hasTruckId:Bool = false
  private(set) var truckId:String = ""

  private(set) var categories:Array<Category>  = Array<Category>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasTruckId {
      return false
    }
    var isInitcategories:Bool = true
    for element in categories {
        if (!element.isInitialized()) {
            isInitcategories = false
            break 
        }
    }
    if !isInitcategories {
     return isInitcategories
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasTruckId {
      output.writeString(1, value:truckId)
    }
    for element in categories {
        output.writeMessage(2, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasTruckId {
      size += WireFormat.computeStringSize(1, value:truckId)
    }
    for element in categories {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Menu {
    return Menu.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Menu {
    return Menu.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Menu {
    return Menu.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Menu {
    return Menu.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Menu {
    return Menu.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Menu {
    return Menu.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuBuilder {
    return MenuBuilder()
  }
  class func builderWithPrototype(prototype:Menu) -> MenuBuilder {
    return Menu.builder().mergeFrom(prototype)
  }
  func builder() -> MenuBuilder {
    return Menu.builder()
  }
  func toBuilder() -> MenuBuilder {
    return Menu.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasTruckId {
      output += "\(indent) truckId: \(truckId) \n"
    }
    var categoriesElementIndex:Int = 0
    for element in categories {
        output += "\(indent) categories[\(categoriesElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        categoriesElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasTruckId {
             hashCode = (hashCode &* 31) &+ truckId.hashValue
          }
          for element in categories {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Menu"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Menu.self
  }


  //Meta information declaration end

}

final class MenuBuilder : GeneratedMessageBuilder {
  private var builderResult:Menu

  required override init () {
     builderResult = Menu()
     super.init()
  }
  var hasTruckId:Bool {
       get {
            return builderResult.hasTruckId
       }
  }
  var truckId:String {
       get {
            return builderResult.truckId
       }
       set (value) {
           builderResult.hasTruckId = true
           builderResult.truckId = value
       }
  }
  func clearTruckId() -> MenuBuilder{
       builderResult.hasTruckId = false
       builderResult.truckId = ""
       return self
  }
  var categories:Array<Category> {
       get {
           return builderResult.categories
       }
       set (value) {
           builderResult.categories = value
       }
  }
  func clearCategories() -> MenuBuilder {
    builderResult.categories.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuBuilder {
    builderResult = Menu()
    return self
  }
  override func clone() -> MenuBuilder {
    return Menu.builderWithPrototype(builderResult)
  }
  override func build() -> Menu {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Menu {
    var returnMe:Menu = builderResult
    return returnMe
  }
  func mergeFrom(other:Menu) -> MenuBuilder {
    if (other == Menu()) {
     return self
    }
    if other.hasTruckId {
         truckId = other.truckId
    }
    if !other.categories.isEmpty  {
       builderResult.categories += other.categories
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        truckId = input.readString()

      case 18 :
        var subBuilder = Category.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        categories += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Category : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:String = ""

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInMenu:Bool = false
  private(set) var orderInMenu:Int32 = Int32(0)

  private(set) var menuItems:Array<MenuItem>  = Array<MenuItem>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitmenuItems:Bool = true
    for element in menuItems {
        if (!element.isInitialized()) {
            isInitmenuItems = false
            break 
        }
    }
    if !isInitmenuItems {
     return isInitmenuItems
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeString(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasNotes {
      output.writeString(3, value:notes)
    }
    if hasOrderInMenu {
      output.writeInt32(4, value:orderInMenu)
    }
    for element in menuItems {
        output.writeMessage(5, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeStringSize(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(3, value:notes)
    }
    if hasOrderInMenu {
      size += WireFormat.computeInt32Size(4, value:orderInMenu)
    }
    for element in menuItems {
        size += WireFormat.computeMessageSize(5, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Category {
    return Category.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Category {
    return Category.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Category {
    return Category.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Category {
    return Category.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Category {
    return Category.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Category {
    return Category.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> CategoryBuilder {
    return CategoryBuilder()
  }
  class func builderWithPrototype(prototype:Category) -> CategoryBuilder {
    return Category.builder().mergeFrom(prototype)
  }
  func builder() -> CategoryBuilder {
    return Category.builder()
  }
  func toBuilder() -> CategoryBuilder {
    return Category.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    if hasOrderInMenu {
      output += "\(indent) orderInMenu: \(orderInMenu) \n"
    }
    var menuItemsElementIndex:Int = 0
    for element in menuItems {
        output += "\(indent) menuItems[\(menuItemsElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        menuItemsElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          if hasOrderInMenu {
             hashCode = (hashCode &* 31) &+ orderInMenu.hashValue
          }
          for element in menuItems {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Category"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Category.self
  }


  //Meta information declaration end

}

final class CategoryBuilder : GeneratedMessageBuilder {
  private var builderResult:Category

  required override init () {
     builderResult = Category()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:String {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> CategoryBuilder{
       builderResult.hasId = false
       builderResult.id = ""
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> CategoryBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> CategoryBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var hasOrderInMenu:Bool {
       get {
            return builderResult.hasOrderInMenu
       }
  }
  var orderInMenu:Int32 {
       get {
            return builderResult.orderInMenu
       }
       set (value) {
           builderResult.hasOrderInMenu = true
           builderResult.orderInMenu = value
       }
  }
  func clearOrderInMenu() -> CategoryBuilder{
       builderResult.hasOrderInMenu = false
       builderResult.orderInMenu = Int32(0)
       return self
  }
  var menuItems:Array<MenuItem> {
       get {
           return builderResult.menuItems
       }
       set (value) {
           builderResult.menuItems = value
       }
  }
  func clearMenuItems() -> CategoryBuilder {
    builderResult.menuItems.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> CategoryBuilder {
    builderResult = Category()
    return self
  }
  override func clone() -> CategoryBuilder {
    return Category.builderWithPrototype(builderResult)
  }
  override func build() -> Category {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Category {
    var returnMe:Category = builderResult
    return returnMe
  }
  func mergeFrom(other:Category) -> CategoryBuilder {
    if (other == Category()) {
     return self
    }
    if other.hasId {
         id = other.id
    }
    if other.hasName {
         name = other.name
    }
    if other.hasNotes {
         notes = other.notes
    }
    if other.hasOrderInMenu {
         orderInMenu = other.orderInMenu
    }
    if !other.menuItems.isEmpty  {
       builderResult.menuItems += other.menuItems
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->CategoryBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> CategoryBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        id = input.readString()

      case 18 :
        name = input.readString()

      case 26 :
        notes = input.readString()

      case 32 :
        orderInMenu = input.readInt32()

      case 42 :
        var subBuilder = MenuItem.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        menuItems += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MenuItem : GeneratedMessage {
  private(set) var hasId:Bool = false
  private(set) var id:String = ""

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasPrice:Bool = false
  private(set) var price:Float = Float(0)

  private(set) var hasNotes:Bool = false
  private(set) var notes:String = ""

  private(set) var hasOrderInCategory:Bool = false
  private(set) var orderInCategory:Int32 = Int32(0)

  private(set) var hasIsAvailable:Bool = false
  private(set) var isAvailable:Bool = false

  private(set) var tags:Array<String> = Array<String>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasName {
      return false
    }
    if !hasPrice {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasId {
      output.writeString(1, value:id)
    }
    if hasName {
      output.writeString(2, value:name)
    }
    if hasPrice {
      output.writeFloat(3, value:price)
    }
    if hasNotes {
      output.writeString(4, value:notes)
    }
    if !tags.isEmpty {
      for value in tags {
        output.writeString(5, value:value)
      }
    }
    if hasOrderInCategory {
      output.writeInt32(6, value:orderInCategory)
    }
    if hasIsAvailable {
      output.writeBool(7, value:isAvailable)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasId {
      size += WireFormat.computeStringSize(1, value:id)
    }
    if hasName {
      size += WireFormat.computeStringSize(2, value:name)
    }
    if hasPrice {
      size += WireFormat.computeFloatSize(3, value:price)
    }
    if hasNotes {
      size += WireFormat.computeStringSize(4, value:notes)
    }
    var dataSizeTags:Int32 = 0
    for element in tags {
        dataSizeTags += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeTags
    size += 1 * Int32(tags.count)
    if hasOrderInCategory {
      size += WireFormat.computeInt32Size(6, value:orderInCategory)
    }
    if hasIsAvailable {
      size += WireFormat.computeBoolSize(7, value:isAvailable)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItem {
    return MenuItem.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItem {
    return MenuItem.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItem {
    return MenuItem.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItem {
    return MenuItem.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItem {
    return MenuItem.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItem {
    return MenuItem.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemBuilder {
    return MenuItemBuilder()
  }
  class func builderWithPrototype(prototype:MenuItem) -> MenuItemBuilder {
    return MenuItem.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemBuilder {
    return MenuItem.builder()
  }
  func toBuilder() -> MenuItemBuilder {
    return MenuItem.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasPrice {
      output += "\(indent) price: \(price) \n"
    }
    if hasNotes {
      output += "\(indent) notes: \(notes) \n"
    }
    var tagsElementIndex:Int = 0
    for element in tags  {
        output += "\(indent) tags[\(tagsElementIndex)]: \(element)\n"
        tagsElementIndex++
    }
    if hasOrderInCategory {
      output += "\(indent) orderInCategory: \(orderInCategory) \n"
    }
    if hasIsAvailable {
      output += "\(indent) isAvailable: \(isAvailable) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasPrice {
             hashCode = (hashCode &* 31) &+ price.hashValue
          }
          if hasNotes {
             hashCode = (hashCode &* 31) &+ notes.hashValue
          }
          for element in tags {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOrderInCategory {
             hashCode = (hashCode &* 31) &+ orderInCategory.hashValue
          }
          if hasIsAvailable {
             hashCode = (hashCode &* 31) &+ isAvailable.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuItem"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuItem.self
  }


  //Meta information declaration end

}

final class MenuItemBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItem

  required override init () {
     builderResult = MenuItem()
     super.init()
  }
  var hasId:Bool {
       get {
            return builderResult.hasId
       }
  }
  var id:String {
       get {
            return builderResult.id
       }
       set (value) {
           builderResult.hasId = true
           builderResult.id = value
       }
  }
  func clearId() -> MenuItemBuilder{
       builderResult.hasId = false
       builderResult.id = ""
       return self
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> MenuItemBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasPrice:Bool {
       get {
            return builderResult.hasPrice
       }
  }
  var price:Float {
       get {
            return builderResult.price
       }
       set (value) {
           builderResult.hasPrice = true
           builderResult.price = value
       }
  }
  func clearPrice() -> MenuItemBuilder{
       builderResult.hasPrice = false
       builderResult.price = Float(0)
       return self
  }
  var hasNotes:Bool {
       get {
            return builderResult.hasNotes
       }
  }
  var notes:String {
       get {
            return builderResult.notes
       }
       set (value) {
           builderResult.hasNotes = true
           builderResult.notes = value
       }
  }
  func clearNotes() -> MenuItemBuilder{
       builderResult.hasNotes = false
       builderResult.notes = ""
       return self
  }
  var tags:Array<String> {
       get {
           return builderResult.tags
       }
       set (array) {
           builderResult.tags = array
       }
  }
  func clearTags() -> MenuItemBuilder {
     builderResult.tags.removeAll(keepCapacity: false)
     return self
  }
  var hasOrderInCategory:Bool {
       get {
            return builderResult.hasOrderInCategory
       }
  }
  var orderInCategory:Int32 {
       get {
            return builderResult.orderInCategory
       }
       set (value) {
           builderResult.hasOrderInCategory = true
           builderResult.orderInCategory = value
       }
  }
  func clearOrderInCategory() -> MenuItemBuilder{
       builderResult.hasOrderInCategory = false
       builderResult.orderInCategory = Int32(0)
       return self
  }
  var hasIsAvailable:Bool {
       get {
            return builderResult.hasIsAvailable
       }
  }
  var isAvailable:Bool {
       get {
            return builderResult.isAvailable
       }
       set (value) {
           builderResult.hasIsAvailable = true
           builderResult.isAvailable = value
       }
  }
  func clearIsAvailable() -> MenuItemBuilder{
       builderResult.hasIsAvailable = false
       builderResult.isAvailable = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemBuilder {
    builderResult = MenuItem()
    return self
  }
  override func clone() -> MenuItemBuilder {
    return MenuItem.builderWithPrototype(builderResult)
  }
  override func build() -> MenuItem {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItem {
    var returnMe:MenuItem = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItem) -> MenuItemBuilder {
    if (other == MenuItem()) {
     return self
    }
    if other.hasId {
         id = other.id
    }
    if other.hasName {
         name = other.name
    }
    if other.hasPrice {
         price = other.price
    }
    if other.hasNotes {
         notes = other.notes
    }
    if !other.tags.isEmpty {
        builderResult.tags += other.tags
    }
    if other.hasOrderInCategory {
         orderInCategory = other.orderInCategory
    }
    if other.hasIsAvailable {
         isAvailable = other.isAvailable
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        id = input.readString()

      case 18 :
        name = input.readString()

      case 29 :
        price = input.readFloat()

      case 34 :
        notes = input.readString()

      case 42 :
        tags += [input.readString()]

      case 48 :
        orderInCategory = input.readInt32()

      case 56 :
        isAvailable = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MenuItemAvailability : GeneratedMessage {
  private(set) var hasMenuItemId:Bool = false
  private(set) var menuItemId:String = ""

  private(set) var hasIsAvailable:Bool = false
  private(set) var isAvailable:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasMenuItemId {
      return false
    }
    if !hasIsAvailable {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMenuItemId {
      output.writeString(1, value:menuItemId)
    }
    if hasIsAvailable {
      output.writeBool(2, value:isAvailable)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMenuItemId {
      size += WireFormat.computeStringSize(1, value:menuItemId)
    }
    if hasIsAvailable {
      size += WireFormat.computeBoolSize(2, value:isAvailable)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailability {
    return MenuItemAvailability.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MenuItemAvailabilityBuilder {
    return MenuItemAvailabilityBuilder()
  }
  class func builderWithPrototype(prototype:MenuItemAvailability) -> MenuItemAvailabilityBuilder {
    return MenuItemAvailability.builder().mergeFrom(prototype)
  }
  func builder() -> MenuItemAvailabilityBuilder {
    return MenuItemAvailability.builder()
  }
  func toBuilder() -> MenuItemAvailabilityBuilder {
    return MenuItemAvailability.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasMenuItemId {
      output += "\(indent) menuItemId: \(menuItemId) \n"
    }
    if hasIsAvailable {
      output += "\(indent) isAvailable: \(isAvailable) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMenuItemId {
             hashCode = (hashCode &* 31) &+ menuItemId.hashValue
          }
          if hasIsAvailable {
             hashCode = (hashCode &* 31) &+ isAvailable.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MenuItemAvailability"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MenuItemAvailability.self
  }


  //Meta information declaration end

}

final class MenuItemAvailabilityBuilder : GeneratedMessageBuilder {
  private var builderResult:MenuItemAvailability

  required override init () {
     builderResult = MenuItemAvailability()
     super.init()
  }
  var hasMenuItemId:Bool {
       get {
            return builderResult.hasMenuItemId
       }
  }
  var menuItemId:String {
       get {
            return builderResult.menuItemId
       }
       set (value) {
           builderResult.hasMenuItemId = true
           builderResult.menuItemId = value
       }
  }
  func clearMenuItemId() -> MenuItemAvailabilityBuilder{
       builderResult.hasMenuItemId = false
       builderResult.menuItemId = ""
       return self
  }
  var hasIsAvailable:Bool {
       get {
            return builderResult.hasIsAvailable
       }
  }
  var isAvailable:Bool {
       get {
            return builderResult.isAvailable
       }
       set (value) {
           builderResult.hasIsAvailable = true
           builderResult.isAvailable = value
       }
  }
  func clearIsAvailable() -> MenuItemAvailabilityBuilder{
       builderResult.hasIsAvailable = false
       builderResult.isAvailable = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MenuItemAvailabilityBuilder {
    builderResult = MenuItemAvailability()
    return self
  }
  override func clone() -> MenuItemAvailabilityBuilder {
    return MenuItemAvailability.builderWithPrototype(builderResult)
  }
  override func build() -> MenuItemAvailability {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MenuItemAvailability {
    var returnMe:MenuItemAvailability = builderResult
    return returnMe
  }
  func mergeFrom(other:MenuItemAvailability) -> MenuItemAvailabilityBuilder {
    if (other == MenuItemAvailability()) {
     return self
    }
    if other.hasMenuItemId {
         menuItemId = other.menuItemId
    }
    if other.hasIsAvailable {
         isAvailable = other.isAvailable
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MenuItemAvailabilityBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        menuItemId = input.readString()

      case 16 :
        isAvailable = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension MenuItemAvailabilityRequest {
    class func parseFromNSData(data:NSData) -> MenuItemAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemAvailabilityResponse {
    class func parseFromNSData(data:NSData) -> MenuItemAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailabilityResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FullMenusRequest {
    class func parseFromNSData(data:NSData) -> FullMenusRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FullMenusRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FullMenusResponse {
    class func parseFromNSData(data:NSData) -> FullMenusResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FullMenusResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FullMenusResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuRequest {
    class func parseFromNSData(data:NSData) -> MenuRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuResponse {
    class func parseFromNSData(data:NSData) -> MenuResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension ModifyMenuItemAvailabilityRequest {
    class func parseFromNSData(data:NSData) -> ModifyMenuItemAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ModifyMenuItemAvailabilityRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ModifyMenuItemAvailabilityRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension ModifyMenuItemAvailabilityResponse {
    class func parseFromNSData(data:NSData) -> ModifyMenuItemAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ModifyMenuItemAvailabilityResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ModifyMenuItemAvailabilityResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ModifyMenuItemAvailabilityResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Menu {
    class func parseFromNSData(data:NSData) -> Menu {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Menu.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Menu {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Menu.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Category {
    class func parseFromNSData(data:NSData) -> Category {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Category.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Category {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Category.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItem {
    class func parseFromNSData(data:NSData) -> MenuItem {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItem.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItem {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItem.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MenuItemAvailability {
    class func parseFromNSData(data:NSData) -> MenuItemAvailability {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailability.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MenuItemAvailability {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MenuItemAvailability.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
