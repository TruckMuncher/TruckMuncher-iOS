// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

struct PBDescriptorRoot {
  static var sharedInstance : PBDescriptorRoot {
   struct Static {
       static let instance : PBDescriptorRoot = PBDescriptorRoot()
   }
   return Static.instance
  }
  var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

func == (lhs: PBFileDescriptorSet, rhs: PBFileDescriptorSet) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.file == rhs.file)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBFileDescriptorProto, rhs: PBFileDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasPackage == rhs.hasPackage) && (!lhs.hasPackage || lhs.package == rhs.package)
  fieldCheck = fieldCheck && (lhs.dependency == rhs.dependency)
  fieldCheck = fieldCheck && (lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasSourceCodeInfo == rhs.hasSourceCodeInfo) && (!lhs.hasSourceCodeInfo || lhs.sourceCodeInfo == rhs.sourceCodeInfo)
  fieldCheck = fieldCheck && (lhs.publicDependency == rhs.publicDependency)
  fieldCheck = fieldCheck && (lhs.weakDependency == rhs.weakDependency)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBDescriptorProto.ExtensionRange, rhs: PBDescriptorProto.ExtensionRange) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBDescriptorProto, rhs: PBDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.field == rhs.field)
  fieldCheck = fieldCheck && (lhs.nestedType == rhs.nestedType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.extensionRange == rhs.extensionRange)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBFieldDescriptorProto, rhs: PBFieldDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasExtendee == rhs.hasExtendee) && (!lhs.hasExtendee || lhs.extendee == rhs.extendee)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasTypeName == rhs.hasTypeName) && (!lhs.hasTypeName || lhs.typeName == rhs.typeName)
  fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBEnumDescriptorProto, rhs: PBEnumDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBEnumValueDescriptorProto, rhs: PBEnumValueDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBServiceDescriptorProto, rhs: PBServiceDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.method == rhs.method)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBMethodDescriptorProto, rhs: PBMethodDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasInputType == rhs.hasInputType) && (!lhs.hasInputType || lhs.inputType == rhs.inputType)
  fieldCheck = fieldCheck && (lhs.hasOutputType == rhs.hasOutputType) && (!lhs.hasOutputType || lhs.outputType == rhs.outputType)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBFileOptions, rhs: PBFileOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasJavaPackage == rhs.hasJavaPackage) && (!lhs.hasJavaPackage || lhs.javaPackage == rhs.javaPackage)
  fieldCheck = fieldCheck && (lhs.hasJavaOuterClassname == rhs.hasJavaOuterClassname) && (!lhs.hasJavaOuterClassname || lhs.javaOuterClassname == rhs.javaOuterClassname)
  fieldCheck = fieldCheck && (lhs.hasOptimizeFor == rhs.hasOptimizeFor) && (!lhs.hasOptimizeFor || lhs.optimizeFor == rhs.optimizeFor)
  fieldCheck = fieldCheck && (lhs.hasJavaMultipleFiles == rhs.hasJavaMultipleFiles) && (!lhs.hasJavaMultipleFiles || lhs.javaMultipleFiles == rhs.javaMultipleFiles)
  fieldCheck = fieldCheck && (lhs.hasGoPackage == rhs.hasGoPackage) && (!lhs.hasGoPackage || lhs.goPackage == rhs.goPackage)
  fieldCheck = fieldCheck && (lhs.hasCcGenericServices == rhs.hasCcGenericServices) && (!lhs.hasCcGenericServices || lhs.ccGenericServices == rhs.ccGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenericServices == rhs.hasJavaGenericServices) && (!lhs.hasJavaGenericServices || lhs.javaGenericServices == rhs.javaGenericServices)
  fieldCheck = fieldCheck && (lhs.hasPyGenericServices == rhs.hasPyGenericServices) && (!lhs.hasPyGenericServices || lhs.pyGenericServices == rhs.pyGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenerateEqualsAndHash == rhs.hasJavaGenerateEqualsAndHash) && (!lhs.hasJavaGenerateEqualsAndHash || lhs.javaGenerateEqualsAndHash == rhs.javaGenerateEqualsAndHash)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBMessageOptions, rhs: PBMessageOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessageSetWireFormat == rhs.hasMessageSetWireFormat) && (!lhs.hasMessageSetWireFormat || lhs.messageSetWireFormat == rhs.messageSetWireFormat)
  fieldCheck = fieldCheck && (lhs.hasNoStandardDescriptorAccessor == rhs.hasNoStandardDescriptorAccessor) && (!lhs.hasNoStandardDescriptorAccessor || lhs.noStandardDescriptorAccessor == rhs.noStandardDescriptorAccessor)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBFieldOptions, rhs: PBFieldOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCtype == rhs.hasCtype) && (!lhs.hasCtype || lhs.ctype == rhs.ctype)
  fieldCheck = fieldCheck && (lhs.hasPacked == rhs.hasPacked) && (!lhs.hasPacked || lhs.packed == rhs.packed)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasLazy == rhs.hasLazy) && (!lhs.hasLazy || lhs.lazy == rhs.lazy)
  fieldCheck = fieldCheck && (lhs.hasExperimentalMapKey == rhs.hasExperimentalMapKey) && (!lhs.hasExperimentalMapKey || lhs.experimentalMapKey == rhs.experimentalMapKey)
  fieldCheck = fieldCheck && (lhs.hasWeak == rhs.hasWeak) && (!lhs.hasWeak || lhs.weak == rhs.weak)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBEnumOptions, rhs: PBEnumOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAllowAlias == rhs.hasAllowAlias) && (!lhs.hasAllowAlias || lhs.allowAlias == rhs.allowAlias)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBEnumValueOptions, rhs: PBEnumValueOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBServiceOptions, rhs: PBServiceOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBMethodOptions, rhs: PBMethodOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBUninterpretedOption.NamePart, rhs: PBUninterpretedOption.NamePart) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNamePart == rhs.hasNamePart) && (!lhs.hasNamePart || lhs.namePart == rhs.namePart)
  fieldCheck = fieldCheck && (lhs.hasIsExtension == rhs.hasIsExtension) && (!lhs.hasIsExtension || lhs.isExtension == rhs.isExtension)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBUninterpretedOption, rhs: PBUninterpretedOption) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasIdentifierValue == rhs.hasIdentifierValue) && (!lhs.hasIdentifierValue || lhs.identifierValue == rhs.identifierValue)
  fieldCheck = fieldCheck && (lhs.hasPositiveIntValue == rhs.hasPositiveIntValue) && (!lhs.hasPositiveIntValue || lhs.positiveIntValue == rhs.positiveIntValue)
  fieldCheck = fieldCheck && (lhs.hasNegativeIntValue == rhs.hasNegativeIntValue) && (!lhs.hasNegativeIntValue || lhs.negativeIntValue == rhs.negativeIntValue)
  fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
  fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
  fieldCheck = fieldCheck && (lhs.hasAggregateValue == rhs.hasAggregateValue) && (!lhs.hasAggregateValue || lhs.aggregateValue == rhs.aggregateValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBSourceCodeInfo.Location, rhs: PBSourceCodeInfo.Location) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.path == rhs.path)
  fieldCheck = fieldCheck && (lhs.span == rhs.span)
  fieldCheck = fieldCheck && (lhs.hasLeadingComments == rhs.hasLeadingComments) && (!lhs.hasLeadingComments || lhs.leadingComments == rhs.leadingComments)
  fieldCheck = fieldCheck && (lhs.hasTrailingComments == rhs.hasTrailingComments) && (!lhs.hasTrailingComments || lhs.trailingComments == rhs.trailingComments)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: PBSourceCodeInfo, rhs: PBSourceCodeInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.location == rhs.location)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class PBFileDescriptorSet : GeneratedMessage {
  private(set) var file:Array<PBFileDescriptorProto>  = Array<PBFileDescriptorProto>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitfile:Bool = true
    for element in file {
        if (!element.isInitialized()) {
            isInitfile = false
            break 
        }
    }
    if !isInitfile {
     return isInitfile
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in file {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in file {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorSet {
    return PBFileDescriptorSet.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBFileDescriptorSetBuilder {
    return PBFileDescriptorSetBuilder()
  }
  class func builderWithPrototype(prototype:PBFileDescriptorSet) -> PBFileDescriptorSetBuilder {
    return PBFileDescriptorSet.builder().mergeFrom(prototype)
  }
  func builder() -> PBFileDescriptorSetBuilder {
    return PBFileDescriptorSet.builder()
  }
  func toBuilder() -> PBFileDescriptorSetBuilder {
    return PBFileDescriptorSet.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var fileElementIndex:Int = 0
    for element in file {
        output += "\(indent) file[\(fileElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        fileElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in file {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFileDescriptorSet"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFileDescriptorSet.self
  }


  //Meta information declaration end

}

final class PBFileDescriptorSetBuilder : GeneratedMessageBuilder {
  private var builderResult:PBFileDescriptorSet

  required override init () {
     builderResult = PBFileDescriptorSet()
     super.init()
  }
  var file:Array<PBFileDescriptorProto> {
       get {
           return builderResult.file
       }
       set (value) {
           builderResult.file = value
       }
  }
  func clearFile() -> PBFileDescriptorSetBuilder {
    builderResult.file.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBFileDescriptorSetBuilder {
    builderResult = PBFileDescriptorSet()
    return self
  }
  override func clone() -> PBFileDescriptorSetBuilder {
    return PBFileDescriptorSet.builderWithPrototype(builderResult)
  }
  override func build() -> PBFileDescriptorSet {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBFileDescriptorSet {
    var returnMe:PBFileDescriptorSet = builderResult
    return returnMe
  }
  func mergeFrom(other:PBFileDescriptorSet) -> PBFileDescriptorSetBuilder {
    if (other == PBFileDescriptorSet()) {
     return self
    }
    if !other.file.isEmpty  {
       builderResult.file += other.file
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBFileDescriptorSetBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorSetBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = PBFileDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        file += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBFileDescriptorProto : GeneratedMessage {
  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasPackage:Bool = false
  private(set) var package:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBFileOptions = PBFileOptions()
  private(set) var hasSourceCodeInfo:Bool = false
  private(set) var sourceCodeInfo:PBSourceCodeInfo = PBSourceCodeInfo()
  private(set) var dependency:Array<String> = Array<String>()
  private(set) var publicDependency:Array<Int32> = Array<Int32>()
  private(set) var weakDependency:Array<Int32> = Array<Int32>()
  private(set) var messageType:Array<PBDescriptorProto>  = Array<PBDescriptorProto>()
  private(set) var enumType:Array<PBEnumDescriptorProto>  = Array<PBEnumDescriptorProto>()
  private(set) var service:Array<PBServiceDescriptorProto>  = Array<PBServiceDescriptorProto>()
  private(set) var extension_:Array<PBFieldDescriptorProto>  = Array<PBFieldDescriptorProto>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitmessageType:Bool = true
    for element in messageType {
        if (!element.isInitialized()) {
            isInitmessageType = false
            break 
        }
    }
    if !isInitmessageType {
     return isInitmessageType
     }
    var isInitenumType:Bool = true
    for element in enumType {
        if (!element.isInitialized()) {
            isInitenumType = false
            break 
        }
    }
    if !isInitenumType {
     return isInitenumType
     }
    var isInitservice:Bool = true
    for element in service {
        if (!element.isInitialized()) {
            isInitservice = false
            break 
        }
    }
    if !isInitservice {
     return isInitservice
     }
    var isInitextension_:Bool = true
    for element in extension_ {
        if (!element.isInitialized()) {
            isInitextension_ = false
            break 
        }
    }
    if !isInitextension_ {
     return isInitextension_
     }
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    if hasPackage {
      output.writeString(2, value:package)
    }
    if !dependency.isEmpty {
      for value in dependency {
        output.writeString(3, value:value)
      }
    }
    for element in messageType {
        output.writeMessage(4, value:element)
    }
    for element in enumType {
        output.writeMessage(5, value:element)
    }
    for element in service {
        output.writeMessage(6, value:element)
    }
    for element in extension_ {
        output.writeMessage(7, value:element)
    }
    if hasOptions {
      output.writeMessage(8, value:options)
    }
    if hasSourceCodeInfo {
      output.writeMessage(9, value:sourceCodeInfo)
    }
    if !publicDependency.isEmpty {
      for value in publicDependency {
        output.writeInt32(10, value:value)
      }
    }
    if !weakDependency.isEmpty {
      for value in weakDependency {
        output.writeInt32(11, value:value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    if hasPackage {
      size += WireFormat.computeStringSize(2, value:package)
    }
    var dataSizeDependency:Int32 = 0
    for element in dependency {
        dataSizeDependency += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeDependency
    size += 1 * Int32(dependency.count)
    for element in messageType {
        size += WireFormat.computeMessageSize(4, value:element)
    }
    for element in enumType {
        size += WireFormat.computeMessageSize(5, value:element)
    }
    for element in service {
        size += WireFormat.computeMessageSize(6, value:element)
    }
    for element in extension_ {
        size += WireFormat.computeMessageSize(7, value:element)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(8, value:options)
    }
    if hasSourceCodeInfo {
      size += WireFormat.computeMessageSize(9, value:sourceCodeInfo)
    }
    var dataSizePublicDependency:Int32 = 0
    for element in publicDependency {
        dataSizePublicDependency += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizePublicDependency
    size += 1 * Int32(publicDependency.count)
    var dataSizeWeakDependency:Int32 = 0
    for element in weakDependency {
        dataSizeWeakDependency += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizeWeakDependency
    size += 1 * Int32(weakDependency.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorProto {
    return PBFileDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBFileDescriptorProtoBuilder {
    return PBFileDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBFileDescriptorProto) -> PBFileDescriptorProtoBuilder {
    return PBFileDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBFileDescriptorProtoBuilder {
    return PBFileDescriptorProto.builder()
  }
  func toBuilder() -> PBFileDescriptorProtoBuilder {
    return PBFileDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasPackage {
      output += "\(indent) package: \(package) \n"
    }
    var dependencyElementIndex:Int = 0
    for element in dependency  {
        output += "\(indent) dependency[\(dependencyElementIndex)]: \(element)\n"
        dependencyElementIndex++
    }
    var messageTypeElementIndex:Int = 0
    for element in messageType {
        output += "\(indent) messageType[\(messageTypeElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        messageTypeElementIndex++
    }
    var enumTypeElementIndex:Int = 0
    for element in enumType {
        output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        enumTypeElementIndex++
    }
    var serviceElementIndex:Int = 0
    for element in service {
        output += "\(indent) service[\(serviceElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        serviceElementIndex++
    }
    var extension_ElementIndex:Int = 0
    for element in extension_ {
        output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        extension_ElementIndex++
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasSourceCodeInfo {
      output += "\(indent) sourceCodeInfo {\n"
      sourceCodeInfo.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var publicDependencyElementIndex:Int = 0
    for element in publicDependency  {
        output += "\(indent) publicDependency[\(publicDependencyElementIndex)]: \(element)\n"
        publicDependencyElementIndex++
    }
    var weakDependencyElementIndex:Int = 0
    for element in weakDependency  {
        output += "\(indent) weakDependency[\(weakDependencyElementIndex)]: \(element)\n"
        weakDependencyElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasPackage {
             hashCode = (hashCode &* 31) &+ package.hashValue
          }
          for element in dependency {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in messageType {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in enumType {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in service {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in extension_ {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          if hasSourceCodeInfo {
            hashCode = (hashCode &* 31) &+ sourceCodeInfo.hashValue
          }
          for element in publicDependency {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in weakDependency {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFileDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFileDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBFileDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBFileDescriptorProto

  required override init () {
     builderResult = PBFileDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBFileDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasPackage:Bool {
       get {
            return builderResult.hasPackage
       }
  }
  var package:String {
       get {
            return builderResult.package
       }
       set (value) {
           builderResult.hasPackage = true
           builderResult.package = value
       }
  }
  func clearPackage() -> PBFileDescriptorProtoBuilder{
       builderResult.hasPackage = false
       builderResult.package = ""
       return self
  }
  var dependency:Array<String> {
       get {
           return builderResult.dependency
       }
       set (array) {
           builderResult.dependency = array
       }
  }
  func clearDependency() -> PBFileDescriptorProtoBuilder {
     builderResult.dependency.removeAll(keepCapacity: false)
     return self
  }
  var publicDependency:Array<Int32> {
       get {
           return builderResult.publicDependency
       }
       set (array) {
           builderResult.publicDependency = array
       }
  }
  func clearPublicDependency() -> PBFileDescriptorProtoBuilder {
     builderResult.publicDependency.removeAll(keepCapacity: false)
     return self
  }
  var weakDependency:Array<Int32> {
       get {
           return builderResult.weakDependency
       }
       set (array) {
           builderResult.weakDependency = array
       }
  }
  func clearWeakDependency() -> PBFileDescriptorProtoBuilder {
     builderResult.weakDependency.removeAll(keepCapacity: false)
     return self
  }
  var messageType:Array<PBDescriptorProto> {
       get {
           return builderResult.messageType
       }
       set (value) {
           builderResult.messageType = value
       }
  }
  func clearMessageType() -> PBFileDescriptorProtoBuilder {
    builderResult.messageType.removeAll(keepCapacity: false)
    return self
  }
  var enumType:Array<PBEnumDescriptorProto> {
       get {
           return builderResult.enumType
       }
       set (value) {
           builderResult.enumType = value
       }
  }
  func clearEnumType() -> PBFileDescriptorProtoBuilder {
    builderResult.enumType.removeAll(keepCapacity: false)
    return self
  }
  var service:Array<PBServiceDescriptorProto> {
       get {
           return builderResult.service
       }
       set (value) {
           builderResult.service = value
       }
  }
  func clearService() -> PBFileDescriptorProtoBuilder {
    builderResult.service.removeAll(keepCapacity: false)
    return self
  }
  var extension_:Array<PBFieldDescriptorProto> {
       get {
           return builderResult.extension_
       }
       set (value) {
           builderResult.extension_ = value
       }
  }
  func clearExtension() -> PBFileDescriptorProtoBuilder {
    builderResult.extension_.removeAll(keepCapacity: false)
    return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBFileOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBFileOptionsBuilder) -> PBFileDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBFileOptions) -> PBFileDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBFileOptions()) {
      builderResult.options = PBFileOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBFileDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBFileOptions()
    return self
  }
  var hasSourceCodeInfo:Bool {
       get {
           return builderResult.hasSourceCodeInfo
       }
  }
  var sourceCodeInfo:PBSourceCodeInfo {
       get {
           return builderResult.sourceCodeInfo
       }
       set (value) {
           builderResult.hasSourceCodeInfo = true
           builderResult.sourceCodeInfo = value
       }
  }
  func setSourceCodeInfoBuilder(builderForValue:PBSourceCodeInfoBuilder) -> PBFileDescriptorProtoBuilder {
    sourceCodeInfo = builderForValue.build()
    return self
  }
  func mergeSourceCodeInfo(value:PBSourceCodeInfo) -> PBFileDescriptorProtoBuilder {
    if (builderResult.hasSourceCodeInfo && builderResult.sourceCodeInfo != PBSourceCodeInfo()) {
      builderResult.sourceCodeInfo = PBSourceCodeInfo.builderWithPrototype(builderResult.sourceCodeInfo).mergeFrom(value).buildPartial()
    } else {
      builderResult.sourceCodeInfo = value
    }
    builderResult.hasSourceCodeInfo = true
    return self
  }
  func clearSourceCodeInfo() -> PBFileDescriptorProtoBuilder {
    builderResult.hasSourceCodeInfo = false
    builderResult.sourceCodeInfo = PBSourceCodeInfo()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBFileDescriptorProtoBuilder {
    builderResult = PBFileDescriptorProto()
    return self
  }
  override func clone() -> PBFileDescriptorProtoBuilder {
    return PBFileDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBFileDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBFileDescriptorProto {
    var returnMe:PBFileDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBFileDescriptorProto) -> PBFileDescriptorProtoBuilder {
    if (other == PBFileDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if other.hasPackage {
         package = other.package
    }
    if !other.dependency.isEmpty {
        builderResult.dependency += other.dependency
    }
    if !other.publicDependency.isEmpty {
        builderResult.publicDependency += other.publicDependency
    }
    if !other.weakDependency.isEmpty {
        builderResult.weakDependency += other.weakDependency
    }
    if !other.messageType.isEmpty  {
       builderResult.messageType += other.messageType
    }
    if !other.enumType.isEmpty  {
       builderResult.enumType += other.enumType
    }
    if !other.service.isEmpty  {
       builderResult.service += other.service
    }
    if !other.extension_.isEmpty  {
       builderResult.extension_ += other.extension_
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    if (other.hasSourceCodeInfo) {
        mergeSourceCodeInfo(other.sourceCodeInfo)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBFileDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        package = input.readString()

      case 26 :
        dependency += [input.readString()]

      case 34 :
        var subBuilder = PBDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        messageType += [subBuilder.buildPartial()]

      case 42 :
        var subBuilder = PBEnumDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        enumType += [subBuilder.buildPartial()]

      case 50 :
        var subBuilder = PBServiceDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        service += [subBuilder.buildPartial()]

      case 58 :
        var subBuilder = PBFieldDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        extension_ += [subBuilder.buildPartial()]

      case 66 :
        var subBuilder:PBFileOptionsBuilder = PBFileOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      case 74 :
        var subBuilder:PBSourceCodeInfoBuilder = PBSourceCodeInfo.builder()
        if hasSourceCodeInfo {
          subBuilder.mergeFrom(sourceCodeInfo)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        sourceCodeInfo = subBuilder.buildPartial()

      case 80 :
        publicDependency += [input.readInt32()]

      case 88 :
        weakDependency += [input.readInt32()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBDescriptorProto : GeneratedMessage {


  //Nested type declaration start

    final public class ExtensionRange : GeneratedMessage {
      private(set) var hasStart:Bool = false
      private(set) var start:Int32 = Int32(0)

      private(set) var hasEnd:Bool = false
      private(set) var end:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasStart {
          output.writeInt32(1, value:start)
        }
        if hasEnd {
          output.writeInt32(2, value:end)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasStart {
          size += WireFormat.computeInt32Size(1, value:start)
        }
        if hasEnd {
          size += WireFormat.computeInt32Size(2, value:end)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBDescriptorProto.ExtensionRange {
        return PBDescriptorProto.ExtensionRange.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> PBDescriptorProto.ExtensionRangeBuilder {
        return PBDescriptorProto.ExtensionRangeBuilder()
      }
      class func builderWithPrototype(prototype:PBDescriptorProto.ExtensionRange) -> PBDescriptorProto.ExtensionRangeBuilder {
        return PBDescriptorProto.ExtensionRange.builder().mergeFrom(prototype)
      }
      func builder() -> PBDescriptorProto.ExtensionRangeBuilder {
        return PBDescriptorProto.ExtensionRange.builder()
      }
      func toBuilder() -> PBDescriptorProto.ExtensionRangeBuilder {
        return PBDescriptorProto.ExtensionRange.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasStart {
          output += "\(indent) start: \(start) \n"
        }
        if hasEnd {
          output += "\(indent) end: \(end) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasStart {
                 hashCode = (hashCode &* 31) &+ start.hashValue
              }
              if hasEnd {
                 hashCode = (hashCode &* 31) &+ end.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "PBDescriptorProto.ExtensionRange"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return PBDescriptorProto.ExtensionRange.self
      }


      //Meta information declaration end

    }

    final class ExtensionRangeBuilder : GeneratedMessageBuilder {
      private var builderResult:PBDescriptorProto.ExtensionRange

      required override init () {
         builderResult = PBDescriptorProto.ExtensionRange()
         super.init()
      }
      var hasStart:Bool {
           get {
                return builderResult.hasStart
           }
      }
      var start:Int32 {
           get {
                return builderResult.start
           }
           set (value) {
               builderResult.hasStart = true
               builderResult.start = value
           }
      }
      func clearStart() -> PBDescriptorProto.ExtensionRangeBuilder{
           builderResult.hasStart = false
           builderResult.start = Int32(0)
           return self
      }
      var hasEnd:Bool {
           get {
                return builderResult.hasEnd
           }
      }
      var end:Int32 {
           get {
                return builderResult.end
           }
           set (value) {
               builderResult.hasEnd = true
               builderResult.end = value
           }
      }
      func clearEnd() -> PBDescriptorProto.ExtensionRangeBuilder{
           builderResult.hasEnd = false
           builderResult.end = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> PBDescriptorProto.ExtensionRangeBuilder {
        builderResult = PBDescriptorProto.ExtensionRange()
        return self
      }
      override func clone() -> PBDescriptorProto.ExtensionRangeBuilder {
        return PBDescriptorProto.ExtensionRange.builderWithPrototype(builderResult)
      }
      override func build() -> PBDescriptorProto.ExtensionRange {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> PBDescriptorProto.ExtensionRange {
        var returnMe:PBDescriptorProto.ExtensionRange = builderResult
        return returnMe
      }
      func mergeFrom(other:PBDescriptorProto.ExtensionRange) -> PBDescriptorProto.ExtensionRangeBuilder {
        if (other == PBDescriptorProto.ExtensionRange()) {
         return self
        }
        if other.hasStart {
             start = other.start
        }
        if other.hasEnd {
             end = other.end
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->PBDescriptorProto.ExtensionRangeBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBDescriptorProto.ExtensionRangeBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            start = input.readInt32()

          case 16 :
            end = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBMessageOptions = PBMessageOptions()
  private(set) var field:Array<PBFieldDescriptorProto>  = Array<PBFieldDescriptorProto>()
  private(set) var extension_:Array<PBFieldDescriptorProto>  = Array<PBFieldDescriptorProto>()
  private(set) var nestedType:Array<PBDescriptorProto>  = Array<PBDescriptorProto>()
  private(set) var enumType:Array<PBEnumDescriptorProto>  = Array<PBEnumDescriptorProto>()
  private(set) var extensionRange:Array<PBDescriptorProto.ExtensionRange>  = Array<PBDescriptorProto.ExtensionRange>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitfield:Bool = true
    for element in field {
        if (!element.isInitialized()) {
            isInitfield = false
            break 
        }
    }
    if !isInitfield {
     return isInitfield
     }
    var isInitextension_:Bool = true
    for element in extension_ {
        if (!element.isInitialized()) {
            isInitextension_ = false
            break 
        }
    }
    if !isInitextension_ {
     return isInitextension_
     }
    var isInitnestedType:Bool = true
    for element in nestedType {
        if (!element.isInitialized()) {
            isInitnestedType = false
            break 
        }
    }
    if !isInitnestedType {
     return isInitnestedType
     }
    var isInitenumType:Bool = true
    for element in enumType {
        if (!element.isInitialized()) {
            isInitenumType = false
            break 
        }
    }
    if !isInitenumType {
     return isInitenumType
     }
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    for element in field {
        output.writeMessage(2, value:element)
    }
    for element in nestedType {
        output.writeMessage(3, value:element)
    }
    for element in enumType {
        output.writeMessage(4, value:element)
    }
    for element in extensionRange {
        output.writeMessage(5, value:element)
    }
    for element in extension_ {
        output.writeMessage(6, value:element)
    }
    if hasOptions {
      output.writeMessage(7, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    for element in field {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    for element in nestedType {
        size += WireFormat.computeMessageSize(3, value:element)
    }
    for element in enumType {
        size += WireFormat.computeMessageSize(4, value:element)
    }
    for element in extensionRange {
        size += WireFormat.computeMessageSize(5, value:element)
    }
    for element in extension_ {
        size += WireFormat.computeMessageSize(6, value:element)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(7, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBDescriptorProto {
    return PBDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBDescriptorProtoBuilder {
    return PBDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBDescriptorProto) -> PBDescriptorProtoBuilder {
    return PBDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBDescriptorProtoBuilder {
    return PBDescriptorProto.builder()
  }
  func toBuilder() -> PBDescriptorProtoBuilder {
    return PBDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    var fieldElementIndex:Int = 0
    for element in field {
        output += "\(indent) field[\(fieldElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        fieldElementIndex++
    }
    var nestedTypeElementIndex:Int = 0
    for element in nestedType {
        output += "\(indent) nestedType[\(nestedTypeElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        nestedTypeElementIndex++
    }
    var enumTypeElementIndex:Int = 0
    for element in enumType {
        output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        enumTypeElementIndex++
    }
    var extensionRangeElementIndex:Int = 0
    for element in extensionRange {
        output += "\(indent) extensionRange[\(extensionRangeElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        extensionRangeElementIndex++
    }
    var extension_ElementIndex:Int = 0
    for element in extension_ {
        output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        extension_ElementIndex++
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          for element in field {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in nestedType {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in enumType {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in extensionRange {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in extension_ {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBDescriptorProto

  required override init () {
     builderResult = PBDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var field:Array<PBFieldDescriptorProto> {
       get {
           return builderResult.field
       }
       set (value) {
           builderResult.field = value
       }
  }
  func clearField() -> PBDescriptorProtoBuilder {
    builderResult.field.removeAll(keepCapacity: false)
    return self
  }
  var extension_:Array<PBFieldDescriptorProto> {
       get {
           return builderResult.extension_
       }
       set (value) {
           builderResult.extension_ = value
       }
  }
  func clearExtension() -> PBDescriptorProtoBuilder {
    builderResult.extension_.removeAll(keepCapacity: false)
    return self
  }
  var nestedType:Array<PBDescriptorProto> {
       get {
           return builderResult.nestedType
       }
       set (value) {
           builderResult.nestedType = value
       }
  }
  func clearNestedType() -> PBDescriptorProtoBuilder {
    builderResult.nestedType.removeAll(keepCapacity: false)
    return self
  }
  var enumType:Array<PBEnumDescriptorProto> {
       get {
           return builderResult.enumType
       }
       set (value) {
           builderResult.enumType = value
       }
  }
  func clearEnumType() -> PBDescriptorProtoBuilder {
    builderResult.enumType.removeAll(keepCapacity: false)
    return self
  }
  var extensionRange:Array<PBDescriptorProto.ExtensionRange> {
       get {
           return builderResult.extensionRange
       }
       set (value) {
           builderResult.extensionRange = value
       }
  }
  func clearExtensionRange() -> PBDescriptorProtoBuilder {
    builderResult.extensionRange.removeAll(keepCapacity: false)
    return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBMessageOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBMessageOptionsBuilder) -> PBDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBMessageOptions) -> PBDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBMessageOptions()) {
      builderResult.options = PBMessageOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBMessageOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBDescriptorProtoBuilder {
    builderResult = PBDescriptorProto()
    return self
  }
  override func clone() -> PBDescriptorProtoBuilder {
    return PBDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBDescriptorProto {
    var returnMe:PBDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBDescriptorProto) -> PBDescriptorProtoBuilder {
    if (other == PBDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if !other.field.isEmpty  {
       builderResult.field += other.field
    }
    if !other.extension_.isEmpty  {
       builderResult.extension_ += other.extension_
    }
    if !other.nestedType.isEmpty  {
       builderResult.nestedType += other.nestedType
    }
    if !other.enumType.isEmpty  {
       builderResult.enumType += other.enumType
    }
    if !other.extensionRange.isEmpty  {
       builderResult.extensionRange += other.extensionRange
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        var subBuilder = PBFieldDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        field += [subBuilder.buildPartial()]

      case 26 :
        var subBuilder = PBDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        nestedType += [subBuilder.buildPartial()]

      case 34 :
        var subBuilder = PBEnumDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        enumType += [subBuilder.buildPartial()]

      case 42 :
        var subBuilder = PBDescriptorProto.ExtensionRange.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        extensionRange += [subBuilder.buildPartial()]

      case 50 :
        var subBuilder = PBFieldDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        extension_ += [subBuilder.buildPartial()]

      case 58 :
        var subBuilder:PBMessageOptionsBuilder = PBMessageOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBFieldDescriptorProto : GeneratedMessage {


    //Enum type declaration start 

    enum Types:Int32 {
      case TypeDouble = 1
      case TypeFloat = 2
      case TypeInt64 = 3
      case TypeUint64 = 4
      case TypeInt32 = 5
      case TypeFixed64 = 6
      case TypeFixed32 = 7
      case TypeBool = 8
      case TypeString = 9
      case TypeGroup = 10
      case TypeMessage = 11
      case TypeBytes = 12
      case TypeUint32 = 13
      case TypeEnum = 14
      case TypeSfixed32 = 15
      case TypeSfixed64 = 16
      case TypeSint32 = 17
      case TypeSint64 = 18

      static func IsValidValue(value:Types) ->Bool {
        switch value {
          case .TypeDouble, .TypeFloat, .TypeInt64, .TypeUint64, .TypeInt32, .TypeFixed64, .TypeFixed32, .TypeBool, .TypeString, .TypeGroup, .TypeMessage, .TypeBytes, .TypeUint32, .TypeEnum, .TypeSfixed32, .TypeSfixed64, .TypeSint32, .TypeSint64:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 



    //Enum type declaration start 

    enum Label:Int32 {
      case LabelOptional = 1
      case LabelRequired = 2
      case LabelRepeated = 3

      static func IsValidValue(value:Label) ->Bool {
        switch value {
          case .LabelOptional, .LabelRequired, .LabelRepeated:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNumber:Bool = false
  private(set) var number:Int32 = Int32(0)

  private(set) var label:PBFieldDescriptorProto.Label = PBFieldDescriptorProto.Label.LabelOptional
  private(set) var hasLabel:Bool = false
  private(set) var types:PBFieldDescriptorProto.Types = PBFieldDescriptorProto.Types.TypeDouble
  private(set) var hasTypes:Bool = false
  private(set) var hasTypeName:Bool = false
  private(set) var typeName:String = ""

  private(set) var hasExtendee:Bool = false
  private(set) var extendee:String = ""

  private(set) var hasDefaultValue:Bool = false
  private(set) var defaultValue:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBFieldOptions = PBFieldOptions()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    if hasExtendee {
      output.writeString(2, value:extendee)
    }
    if hasNumber {
      output.writeInt32(3, value:number)
    }
    if hasLabel {
      output.writeEnum(4, value:label.rawValue)
    }
    if hasTypes {
      output.writeEnum(5, value:types.rawValue)
    }
    if hasTypeName {
      output.writeString(6, value:typeName)
    }
    if hasDefaultValue {
      output.writeString(7, value:defaultValue)
    }
    if hasOptions {
      output.writeMessage(8, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    if hasExtendee {
      size += WireFormat.computeStringSize(2, value:extendee)
    }
    if hasNumber {
      size += WireFormat.computeInt32Size(3, value:number)
    }
    if (hasLabel) {
      size += WireFormat.computeEnumSize(4, value:label.rawValue)
    }
    if (hasTypes) {
      size += WireFormat.computeEnumSize(5, value:types.rawValue)
    }
    if hasTypeName {
      size += WireFormat.computeStringSize(6, value:typeName)
    }
    if hasDefaultValue {
      size += WireFormat.computeStringSize(7, value:defaultValue)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(8, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFieldDescriptorProto {
    return PBFieldDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBFieldDescriptorProtoBuilder {
    return PBFieldDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBFieldDescriptorProto) -> PBFieldDescriptorProtoBuilder {
    return PBFieldDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBFieldDescriptorProtoBuilder {
    return PBFieldDescriptorProto.builder()
  }
  func toBuilder() -> PBFieldDescriptorProtoBuilder {
    return PBFieldDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasExtendee {
      output += "\(indent) extendee: \(extendee) \n"
    }
    if hasNumber {
      output += "\(indent) number: \(number) \n"
    }
    if (hasLabel) {
      output += "\(indent) label: \(label.rawValue)\n"
    }
    if (hasTypes) {
      output += "\(indent) types: \(types.rawValue)\n"
    }
    if hasTypeName {
      output += "\(indent) typeName: \(typeName) \n"
    }
    if hasDefaultValue {
      output += "\(indent) defaultValue: \(defaultValue) \n"
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasExtendee {
             hashCode = (hashCode &* 31) &+ extendee.hashValue
          }
          if hasNumber {
             hashCode = (hashCode &* 31) &+ number.hashValue
          }
          if hasLabel {
             hashCode = (hashCode &* 31) &+ Int(label.rawValue)
          }
          if hasTypes {
             hashCode = (hashCode &* 31) &+ Int(types.rawValue)
          }
          if hasTypeName {
             hashCode = (hashCode &* 31) &+ typeName.hashValue
          }
          if hasDefaultValue {
             hashCode = (hashCode &* 31) &+ defaultValue.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFieldDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFieldDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBFieldDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBFieldDescriptorProto

  required override init () {
     builderResult = PBFieldDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBFieldDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNumber:Bool {
       get {
            return builderResult.hasNumber
       }
  }
  var number:Int32 {
       get {
            return builderResult.number
       }
       set (value) {
           builderResult.hasNumber = true
           builderResult.number = value
       }
  }
  func clearNumber() -> PBFieldDescriptorProtoBuilder{
       builderResult.hasNumber = false
       builderResult.number = Int32(0)
       return self
  }
    var hasLabel:Bool{
        get {
            return builderResult.hasLabel
        }
    }
    var label:PBFieldDescriptorProto.Label {
        get {
            return builderResult.label
        }
        set (value) {
            builderResult.hasLabel = true
            builderResult.label = value
        }
    }
    func clearLabel() -> PBFieldDescriptorProtoBuilder {
       builderResult.hasLabel = false
       builderResult.label = .LabelOptional
       return self
    }
    var hasTypes:Bool{
        get {
            return builderResult.hasTypes
        }
    }
    var types:PBFieldDescriptorProto.Types {
        get {
            return builderResult.types
        }
        set (value) {
            builderResult.hasTypes = true
            builderResult.types = value
        }
    }
    func clearTypes() -> PBFieldDescriptorProtoBuilder {
       builderResult.hasTypes = false
       builderResult.types = .TypeDouble
       return self
    }
  var hasTypeName:Bool {
       get {
            return builderResult.hasTypeName
       }
  }
  var typeName:String {
       get {
            return builderResult.typeName
       }
       set (value) {
           builderResult.hasTypeName = true
           builderResult.typeName = value
       }
  }
  func clearTypeName() -> PBFieldDescriptorProtoBuilder{
       builderResult.hasTypeName = false
       builderResult.typeName = ""
       return self
  }
  var hasExtendee:Bool {
       get {
            return builderResult.hasExtendee
       }
  }
  var extendee:String {
       get {
            return builderResult.extendee
       }
       set (value) {
           builderResult.hasExtendee = true
           builderResult.extendee = value
       }
  }
  func clearExtendee() -> PBFieldDescriptorProtoBuilder{
       builderResult.hasExtendee = false
       builderResult.extendee = ""
       return self
  }
  var hasDefaultValue:Bool {
       get {
            return builderResult.hasDefaultValue
       }
  }
  var defaultValue:String {
       get {
            return builderResult.defaultValue
       }
       set (value) {
           builderResult.hasDefaultValue = true
           builderResult.defaultValue = value
       }
  }
  func clearDefaultValue() -> PBFieldDescriptorProtoBuilder{
       builderResult.hasDefaultValue = false
       builderResult.defaultValue = ""
       return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBFieldOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBFieldOptionsBuilder) -> PBFieldDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBFieldOptions) -> PBFieldDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBFieldOptions()) {
      builderResult.options = PBFieldOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBFieldDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBFieldOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBFieldDescriptorProtoBuilder {
    builderResult = PBFieldDescriptorProto()
    return self
  }
  override func clone() -> PBFieldDescriptorProtoBuilder {
    return PBFieldDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBFieldDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBFieldDescriptorProto {
    var returnMe:PBFieldDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBFieldDescriptorProto) -> PBFieldDescriptorProtoBuilder {
    if (other == PBFieldDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if other.hasNumber {
         number = other.number
    }
    if other.hasLabel {
         label = other.label
    }
    if other.hasTypes {
         types = other.types
    }
    if other.hasTypeName {
         typeName = other.typeName
    }
    if other.hasExtendee {
         extendee = other.extendee
    }
    if other.hasDefaultValue {
         defaultValue = other.defaultValue
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBFieldDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFieldDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        extendee = input.readString()

      case 24 :
        number = input.readInt32()

      case 32 :
        var value = input.readEnum()
        var enumMergResult:PBFieldDescriptorProto.Label = PBFieldDescriptorProto.Label(rawValue:value)!
        if (PBFieldDescriptorProto.Label.IsValidValue(enumMergResult)) {
             label = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(4, value:Int64(value))
        }

      case 40 :
        var value = input.readEnum()
        var enumMergResult:PBFieldDescriptorProto.Types = PBFieldDescriptorProto.Types(rawValue:value)!
        if (PBFieldDescriptorProto.Types.IsValidValue(enumMergResult)) {
             types = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(5, value:Int64(value))
        }

      case 50 :
        typeName = input.readString()

      case 58 :
        defaultValue = input.readString()

      case 66 :
        var subBuilder:PBFieldOptionsBuilder = PBFieldOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBEnumDescriptorProto : GeneratedMessage {
  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBEnumOptions = PBEnumOptions()
  private(set) var value:Array<PBEnumValueDescriptorProto>  = Array<PBEnumValueDescriptorProto>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitvalue:Bool = true
    for element in value {
        if (!element.isInitialized()) {
            isInitvalue = false
            break 
        }
    }
    if !isInitvalue {
     return isInitvalue
     }
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    for element in value {
        output.writeMessage(2, value:element)
    }
    if hasOptions {
      output.writeMessage(3, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    for element in value {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(3, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumDescriptorProto {
    return PBEnumDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBEnumDescriptorProtoBuilder {
    return PBEnumDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBEnumDescriptorProto) -> PBEnumDescriptorProtoBuilder {
    return PBEnumDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBEnumDescriptorProtoBuilder {
    return PBEnumDescriptorProto.builder()
  }
  func toBuilder() -> PBEnumDescriptorProtoBuilder {
    return PBEnumDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    var valueElementIndex:Int = 0
    for element in value {
        output += "\(indent) value[\(valueElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        valueElementIndex++
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          for element in value {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBEnumDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBEnumDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBEnumDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBEnumDescriptorProto

  required override init () {
     builderResult = PBEnumDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBEnumDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var value:Array<PBEnumValueDescriptorProto> {
       get {
           return builderResult.value
       }
       set (value) {
           builderResult.value = value
       }
  }
  func clearValue() -> PBEnumDescriptorProtoBuilder {
    builderResult.value.removeAll(keepCapacity: false)
    return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBEnumOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBEnumOptionsBuilder) -> PBEnumDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBEnumOptions) -> PBEnumDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBEnumOptions()) {
      builderResult.options = PBEnumOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBEnumDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBEnumOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBEnumDescriptorProtoBuilder {
    builderResult = PBEnumDescriptorProto()
    return self
  }
  override func clone() -> PBEnumDescriptorProtoBuilder {
    return PBEnumDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBEnumDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBEnumDescriptorProto {
    var returnMe:PBEnumDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBEnumDescriptorProto) -> PBEnumDescriptorProtoBuilder {
    if (other == PBEnumDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if !other.value.isEmpty  {
       builderResult.value += other.value
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBEnumDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        var subBuilder = PBEnumValueDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        value += [subBuilder.buildPartial()]

      case 26 :
        var subBuilder:PBEnumOptionsBuilder = PBEnumOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBEnumValueDescriptorProto : GeneratedMessage {
  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasNumber:Bool = false
  private(set) var number:Int32 = Int32(0)

  private(set) var hasOptions:Bool = false
  private(set) var options:PBEnumValueOptions = PBEnumValueOptions()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    if hasNumber {
      output.writeInt32(2, value:number)
    }
    if hasOptions {
      output.writeMessage(3, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    if hasNumber {
      size += WireFormat.computeInt32Size(2, value:number)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(3, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumValueDescriptorProto {
    return PBEnumValueDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBEnumValueDescriptorProtoBuilder {
    return PBEnumValueDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBEnumValueDescriptorProto) -> PBEnumValueDescriptorProtoBuilder {
    return PBEnumValueDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBEnumValueDescriptorProtoBuilder {
    return PBEnumValueDescriptorProto.builder()
  }
  func toBuilder() -> PBEnumValueDescriptorProtoBuilder {
    return PBEnumValueDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNumber {
      output += "\(indent) number: \(number) \n"
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNumber {
             hashCode = (hashCode &* 31) &+ number.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBEnumValueDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBEnumValueDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBEnumValueDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBEnumValueDescriptorProto

  required override init () {
     builderResult = PBEnumValueDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBEnumValueDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasNumber:Bool {
       get {
            return builderResult.hasNumber
       }
  }
  var number:Int32 {
       get {
            return builderResult.number
       }
       set (value) {
           builderResult.hasNumber = true
           builderResult.number = value
       }
  }
  func clearNumber() -> PBEnumValueDescriptorProtoBuilder{
       builderResult.hasNumber = false
       builderResult.number = Int32(0)
       return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBEnumValueOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBEnumValueOptionsBuilder) -> PBEnumValueDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBEnumValueOptions) -> PBEnumValueDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBEnumValueOptions()) {
      builderResult.options = PBEnumValueOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBEnumValueDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBEnumValueOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBEnumValueDescriptorProtoBuilder {
    builderResult = PBEnumValueDescriptorProto()
    return self
  }
  override func clone() -> PBEnumValueDescriptorProtoBuilder {
    return PBEnumValueDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBEnumValueDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBEnumValueDescriptorProto {
    var returnMe:PBEnumValueDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBEnumValueDescriptorProto) -> PBEnumValueDescriptorProtoBuilder {
    if (other == PBEnumValueDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if other.hasNumber {
         number = other.number
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBEnumValueDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumValueDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 16 :
        number = input.readInt32()

      case 26 :
        var subBuilder:PBEnumValueOptionsBuilder = PBEnumValueOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBServiceDescriptorProto : GeneratedMessage {
  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBServiceOptions = PBServiceOptions()
  private(set) var method:Array<PBMethodDescriptorProto>  = Array<PBMethodDescriptorProto>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitmethod:Bool = true
    for element in method {
        if (!element.isInitialized()) {
            isInitmethod = false
            break 
        }
    }
    if !isInitmethod {
     return isInitmethod
     }
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    for element in method {
        output.writeMessage(2, value:element)
    }
    if hasOptions {
      output.writeMessage(3, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    for element in method {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(3, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBServiceDescriptorProto {
    return PBServiceDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBServiceDescriptorProtoBuilder {
    return PBServiceDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBServiceDescriptorProto) -> PBServiceDescriptorProtoBuilder {
    return PBServiceDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBServiceDescriptorProtoBuilder {
    return PBServiceDescriptorProto.builder()
  }
  func toBuilder() -> PBServiceDescriptorProtoBuilder {
    return PBServiceDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    var methodElementIndex:Int = 0
    for element in method {
        output += "\(indent) method[\(methodElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        methodElementIndex++
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          for element in method {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBServiceDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBServiceDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBServiceDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBServiceDescriptorProto

  required override init () {
     builderResult = PBServiceDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBServiceDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var method:Array<PBMethodDescriptorProto> {
       get {
           return builderResult.method
       }
       set (value) {
           builderResult.method = value
       }
  }
  func clearMethod() -> PBServiceDescriptorProtoBuilder {
    builderResult.method.removeAll(keepCapacity: false)
    return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBServiceOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBServiceOptionsBuilder) -> PBServiceDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBServiceOptions) -> PBServiceDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBServiceOptions()) {
      builderResult.options = PBServiceOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBServiceDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBServiceOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBServiceDescriptorProtoBuilder {
    builderResult = PBServiceDescriptorProto()
    return self
  }
  override func clone() -> PBServiceDescriptorProtoBuilder {
    return PBServiceDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBServiceDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBServiceDescriptorProto {
    var returnMe:PBServiceDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBServiceDescriptorProto) -> PBServiceDescriptorProtoBuilder {
    if (other == PBServiceDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if !other.method.isEmpty  {
       builderResult.method += other.method
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBServiceDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBServiceDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        var subBuilder = PBMethodDescriptorProto.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        method += [subBuilder.buildPartial()]

      case 26 :
        var subBuilder:PBServiceOptionsBuilder = PBServiceOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBMethodDescriptorProto : GeneratedMessage {
  private(set) var hasName:Bool = false
  private(set) var name:String = ""

  private(set) var hasInputType:Bool = false
  private(set) var inputType:String = ""

  private(set) var hasOutputType:Bool = false
  private(set) var outputType:String = ""

  private(set) var hasOptions:Bool = false
  private(set) var options:PBMethodOptions = PBMethodOptions()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasOptions {
     if !options.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasName {
      output.writeString(1, value:name)
    }
    if hasInputType {
      output.writeString(2, value:inputType)
    }
    if hasOutputType {
      output.writeString(3, value:outputType)
    }
    if hasOptions {
      output.writeMessage(4, value:options)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasName {
      size += WireFormat.computeStringSize(1, value:name)
    }
    if hasInputType {
      size += WireFormat.computeStringSize(2, value:inputType)
    }
    if hasOutputType {
      size += WireFormat.computeStringSize(3, value:outputType)
    }
    if hasOptions {
      size += WireFormat.computeMessageSize(4, value:options)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMethodDescriptorProto {
    return PBMethodDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBMethodDescriptorProtoBuilder {
    return PBMethodDescriptorProtoBuilder()
  }
  class func builderWithPrototype(prototype:PBMethodDescriptorProto) -> PBMethodDescriptorProtoBuilder {
    return PBMethodDescriptorProto.builder().mergeFrom(prototype)
  }
  func builder() -> PBMethodDescriptorProtoBuilder {
    return PBMethodDescriptorProto.builder()
  }
  func toBuilder() -> PBMethodDescriptorProtoBuilder {
    return PBMethodDescriptorProto.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasInputType {
      output += "\(indent) inputType: \(inputType) \n"
    }
    if hasOutputType {
      output += "\(indent) outputType: \(outputType) \n"
    }
    if hasOptions {
      output += "\(indent) options {\n"
      options.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasInputType {
             hashCode = (hashCode &* 31) &+ inputType.hashValue
          }
          if hasOutputType {
             hashCode = (hashCode &* 31) &+ outputType.hashValue
          }
          if hasOptions {
            hashCode = (hashCode &* 31) &+ options.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBMethodDescriptorProto"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBMethodDescriptorProto.self
  }


  //Meta information declaration end

}

final class PBMethodDescriptorProtoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBMethodDescriptorProto

  required override init () {
     builderResult = PBMethodDescriptorProto()
     super.init()
  }
  var hasName:Bool {
       get {
            return builderResult.hasName
       }
  }
  var name:String {
       get {
            return builderResult.name
       }
       set (value) {
           builderResult.hasName = true
           builderResult.name = value
       }
  }
  func clearName() -> PBMethodDescriptorProtoBuilder{
       builderResult.hasName = false
       builderResult.name = ""
       return self
  }
  var hasInputType:Bool {
       get {
            return builderResult.hasInputType
       }
  }
  var inputType:String {
       get {
            return builderResult.inputType
       }
       set (value) {
           builderResult.hasInputType = true
           builderResult.inputType = value
       }
  }
  func clearInputType() -> PBMethodDescriptorProtoBuilder{
       builderResult.hasInputType = false
       builderResult.inputType = ""
       return self
  }
  var hasOutputType:Bool {
       get {
            return builderResult.hasOutputType
       }
  }
  var outputType:String {
       get {
            return builderResult.outputType
       }
       set (value) {
           builderResult.hasOutputType = true
           builderResult.outputType = value
       }
  }
  func clearOutputType() -> PBMethodDescriptorProtoBuilder{
       builderResult.hasOutputType = false
       builderResult.outputType = ""
       return self
  }
  var hasOptions:Bool {
       get {
           return builderResult.hasOptions
       }
  }
  var options:PBMethodOptions {
       get {
           return builderResult.options
       }
       set (value) {
           builderResult.hasOptions = true
           builderResult.options = value
       }
  }
  func setOptionsBuilder(builderForValue:PBMethodOptionsBuilder) -> PBMethodDescriptorProtoBuilder {
    options = builderForValue.build()
    return self
  }
  func mergeOptions(value:PBMethodOptions) -> PBMethodDescriptorProtoBuilder {
    if (builderResult.hasOptions && builderResult.options != PBMethodOptions()) {
      builderResult.options = PBMethodOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
    } else {
      builderResult.options = value
    }
    builderResult.hasOptions = true
    return self
  }
  func clearOptions() -> PBMethodDescriptorProtoBuilder {
    builderResult.hasOptions = false
    builderResult.options = PBMethodOptions()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBMethodDescriptorProtoBuilder {
    builderResult = PBMethodDescriptorProto()
    return self
  }
  override func clone() -> PBMethodDescriptorProtoBuilder {
    return PBMethodDescriptorProto.builderWithPrototype(builderResult)
  }
  override func build() -> PBMethodDescriptorProto {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBMethodDescriptorProto {
    var returnMe:PBMethodDescriptorProto = builderResult
    return returnMe
  }
  func mergeFrom(other:PBMethodDescriptorProto) -> PBMethodDescriptorProtoBuilder {
    if (other == PBMethodDescriptorProto()) {
     return self
    }
    if other.hasName {
         name = other.name
    }
    if other.hasInputType {
         inputType = other.inputType
    }
    if other.hasOutputType {
         outputType = other.outputType
    }
    if (other.hasOptions) {
        mergeOptions(other.options)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBMethodDescriptorProtoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMethodDescriptorProtoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        name = input.readString()

      case 18 :
        inputType = input.readString()

      case 26 :
        outputType = input.readString()

      case 34 :
        var subBuilder:PBMethodOptionsBuilder = PBMethodOptions.builder()
        if hasOptions {
          subBuilder.mergeFrom(options)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        options = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBFileOptions : ExtendableMessage {


    //Enum type declaration start 

    enum OptimizeMode:Int32 {
      case Speed = 1
      case CodeSize = 2
      case LiteRuntime = 3

      static func IsValidValue(value:OptimizeMode) ->Bool {
        switch value {
          case .Speed, .CodeSize, .LiteRuntime:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var hasJavaPackage:Bool = false
  private(set) var javaPackage:String = ""

  private(set) var hasJavaOuterClassname:Bool = false
  private(set) var javaOuterClassname:String = ""

  private(set) var hasJavaMultipleFiles:Bool = false
  private(set) var javaMultipleFiles:Bool = false

  private(set) var hasJavaGenerateEqualsAndHash:Bool = false
  private(set) var javaGenerateEqualsAndHash:Bool = false

  private(set) var optimizeFor:PBFileOptions.OptimizeMode = PBFileOptions.OptimizeMode.Speed
  private(set) var hasOptimizeFor:Bool = false
  private(set) var hasGoPackage:Bool = false
  private(set) var goPackage:String = ""

  private(set) var hasCcGenericServices:Bool = false
  private(set) var ccGenericServices:Bool = false

  private(set) var hasJavaGenericServices:Bool = false
  private(set) var javaGenericServices:Bool = false

  private(set) var hasPyGenericServices:Bool = false
  private(set) var pyGenericServices:Bool = false

  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasJavaPackage {
      output.writeString(1, value:javaPackage)
    }
    if hasJavaOuterClassname {
      output.writeString(8, value:javaOuterClassname)
    }
    if hasOptimizeFor {
      output.writeEnum(9, value:optimizeFor.rawValue)
    }
    if hasJavaMultipleFiles {
      output.writeBool(10, value:javaMultipleFiles)
    }
    if hasGoPackage {
      output.writeString(11, value:goPackage)
    }
    if hasCcGenericServices {
      output.writeBool(16, value:ccGenericServices)
    }
    if hasJavaGenericServices {
      output.writeBool(17, value:javaGenericServices)
    }
    if hasPyGenericServices {
      output.writeBool(18, value:pyGenericServices)
    }
    if hasJavaGenerateEqualsAndHash {
      output.writeBool(20, value:javaGenerateEqualsAndHash)
    }
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasJavaPackage {
      size += WireFormat.computeStringSize(1, value:javaPackage)
    }
    if hasJavaOuterClassname {
      size += WireFormat.computeStringSize(8, value:javaOuterClassname)
    }
    if (hasOptimizeFor) {
      size += WireFormat.computeEnumSize(9, value:optimizeFor.rawValue)
    }
    if hasJavaMultipleFiles {
      size += WireFormat.computeBoolSize(10, value:javaMultipleFiles)
    }
    if hasGoPackage {
      size += WireFormat.computeStringSize(11, value:goPackage)
    }
    if hasCcGenericServices {
      size += WireFormat.computeBoolSize(16, value:ccGenericServices)
    }
    if hasJavaGenericServices {
      size += WireFormat.computeBoolSize(17, value:javaGenericServices)
    }
    if hasPyGenericServices {
      size += WireFormat.computeBoolSize(18, value:pyGenericServices)
    }
    if hasJavaGenerateEqualsAndHash {
      size += WireFormat.computeBoolSize(20, value:javaGenerateEqualsAndHash)
    }
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBFileOptions {
    return PBFileOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBFileOptions {
    return PBFileOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBFileOptions {
    return PBFileOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBFileOptions {
    return PBFileOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBFileOptions {
    return PBFileOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileOptions {
    return PBFileOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBFileOptionsBuilder {
    return PBFileOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBFileOptions) -> PBFileOptionsBuilder {
    return PBFileOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBFileOptionsBuilder {
    return PBFileOptions.builder()
  }
  func toBuilder() -> PBFileOptionsBuilder {
    return PBFileOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasJavaPackage {
      output += "\(indent) javaPackage: \(javaPackage) \n"
    }
    if hasJavaOuterClassname {
      output += "\(indent) javaOuterClassname: \(javaOuterClassname) \n"
    }
    if (hasOptimizeFor) {
      output += "\(indent) optimizeFor: \(optimizeFor.rawValue)\n"
    }
    if hasJavaMultipleFiles {
      output += "\(indent) javaMultipleFiles: \(javaMultipleFiles) \n"
    }
    if hasGoPackage {
      output += "\(indent) goPackage: \(goPackage) \n"
    }
    if hasCcGenericServices {
      output += "\(indent) ccGenericServices: \(ccGenericServices) \n"
    }
    if hasJavaGenericServices {
      output += "\(indent) javaGenericServices: \(javaGenericServices) \n"
    }
    if hasPyGenericServices {
      output += "\(indent) pyGenericServices: \(pyGenericServices) \n"
    }
    if hasJavaGenerateEqualsAndHash {
      output += "\(indent) javaGenerateEqualsAndHash: \(javaGenerateEqualsAndHash) \n"
    }
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasJavaPackage {
             hashCode = (hashCode &* 31) &+ javaPackage.hashValue
          }
          if hasJavaOuterClassname {
             hashCode = (hashCode &* 31) &+ javaOuterClassname.hashValue
          }
          if hasOptimizeFor {
             hashCode = (hashCode &* 31) &+ Int(optimizeFor.rawValue)
          }
          if hasJavaMultipleFiles {
             hashCode = (hashCode &* 31) &+ javaMultipleFiles.hashValue
          }
          if hasGoPackage {
             hashCode = (hashCode &* 31) &+ goPackage.hashValue
          }
          if hasCcGenericServices {
             hashCode = (hashCode &* 31) &+ ccGenericServices.hashValue
          }
          if hasJavaGenericServices {
             hashCode = (hashCode &* 31) &+ javaGenericServices.hashValue
          }
          if hasPyGenericServices {
             hashCode = (hashCode &* 31) &+ pyGenericServices.hashValue
          }
          if hasJavaGenerateEqualsAndHash {
             hashCode = (hashCode &* 31) &+ javaGenerateEqualsAndHash.hashValue
          }
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFileOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFileOptions.self
  }


  //Meta information declaration end

}

final class PBFileOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBFileOptions

  required override init () {
     builderResult = PBFileOptions()
     super.init()
  }
  var hasJavaPackage:Bool {
       get {
            return builderResult.hasJavaPackage
       }
  }
  var javaPackage:String {
       get {
            return builderResult.javaPackage
       }
       set (value) {
           builderResult.hasJavaPackage = true
           builderResult.javaPackage = value
       }
  }
  func clearJavaPackage() -> PBFileOptionsBuilder{
       builderResult.hasJavaPackage = false
       builderResult.javaPackage = ""
       return self
  }
  var hasJavaOuterClassname:Bool {
       get {
            return builderResult.hasJavaOuterClassname
       }
  }
  var javaOuterClassname:String {
       get {
            return builderResult.javaOuterClassname
       }
       set (value) {
           builderResult.hasJavaOuterClassname = true
           builderResult.javaOuterClassname = value
       }
  }
  func clearJavaOuterClassname() -> PBFileOptionsBuilder{
       builderResult.hasJavaOuterClassname = false
       builderResult.javaOuterClassname = ""
       return self
  }
  var hasJavaMultipleFiles:Bool {
       get {
            return builderResult.hasJavaMultipleFiles
       }
  }
  var javaMultipleFiles:Bool {
       get {
            return builderResult.javaMultipleFiles
       }
       set (value) {
           builderResult.hasJavaMultipleFiles = true
           builderResult.javaMultipleFiles = value
       }
  }
  func clearJavaMultipleFiles() -> PBFileOptionsBuilder{
       builderResult.hasJavaMultipleFiles = false
       builderResult.javaMultipleFiles = false
       return self
  }
  var hasJavaGenerateEqualsAndHash:Bool {
       get {
            return builderResult.hasJavaGenerateEqualsAndHash
       }
  }
  var javaGenerateEqualsAndHash:Bool {
       get {
            return builderResult.javaGenerateEqualsAndHash
       }
       set (value) {
           builderResult.hasJavaGenerateEqualsAndHash = true
           builderResult.javaGenerateEqualsAndHash = value
       }
  }
  func clearJavaGenerateEqualsAndHash() -> PBFileOptionsBuilder{
       builderResult.hasJavaGenerateEqualsAndHash = false
       builderResult.javaGenerateEqualsAndHash = false
       return self
  }
    var hasOptimizeFor:Bool{
        get {
            return builderResult.hasOptimizeFor
        }
    }
    var optimizeFor:PBFileOptions.OptimizeMode {
        get {
            return builderResult.optimizeFor
        }
        set (value) {
            builderResult.hasOptimizeFor = true
            builderResult.optimizeFor = value
        }
    }
    func clearOptimizeFor() -> PBFileOptionsBuilder {
       builderResult.hasOptimizeFor = false
       builderResult.optimizeFor = .Speed
       return self
    }
  var hasGoPackage:Bool {
       get {
            return builderResult.hasGoPackage
       }
  }
  var goPackage:String {
       get {
            return builderResult.goPackage
       }
       set (value) {
           builderResult.hasGoPackage = true
           builderResult.goPackage = value
       }
  }
  func clearGoPackage() -> PBFileOptionsBuilder{
       builderResult.hasGoPackage = false
       builderResult.goPackage = ""
       return self
  }
  var hasCcGenericServices:Bool {
       get {
            return builderResult.hasCcGenericServices
       }
  }
  var ccGenericServices:Bool {
       get {
            return builderResult.ccGenericServices
       }
       set (value) {
           builderResult.hasCcGenericServices = true
           builderResult.ccGenericServices = value
       }
  }
  func clearCcGenericServices() -> PBFileOptionsBuilder{
       builderResult.hasCcGenericServices = false
       builderResult.ccGenericServices = false
       return self
  }
  var hasJavaGenericServices:Bool {
       get {
            return builderResult.hasJavaGenericServices
       }
  }
  var javaGenericServices:Bool {
       get {
            return builderResult.javaGenericServices
       }
       set (value) {
           builderResult.hasJavaGenericServices = true
           builderResult.javaGenericServices = value
       }
  }
  func clearJavaGenericServices() -> PBFileOptionsBuilder{
       builderResult.hasJavaGenericServices = false
       builderResult.javaGenericServices = false
       return self
  }
  var hasPyGenericServices:Bool {
       get {
            return builderResult.hasPyGenericServices
       }
  }
  var pyGenericServices:Bool {
       get {
            return builderResult.pyGenericServices
       }
       set (value) {
           builderResult.hasPyGenericServices = true
           builderResult.pyGenericServices = value
       }
  }
  func clearPyGenericServices() -> PBFileOptionsBuilder{
       builderResult.hasPyGenericServices = false
       builderResult.pyGenericServices = false
       return self
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBFileOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBFileOptionsBuilder {
    builderResult = PBFileOptions()
    return self
  }
  override func clone() -> PBFileOptionsBuilder {
    return PBFileOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBFileOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBFileOptions {
    var returnMe:PBFileOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBFileOptions) -> PBFileOptionsBuilder {
    if (other == PBFileOptions()) {
     return self
    }
    if other.hasJavaPackage {
         javaPackage = other.javaPackage
    }
    if other.hasJavaOuterClassname {
         javaOuterClassname = other.javaOuterClassname
    }
    if other.hasJavaMultipleFiles {
         javaMultipleFiles = other.javaMultipleFiles
    }
    if other.hasJavaGenerateEqualsAndHash {
         javaGenerateEqualsAndHash = other.javaGenerateEqualsAndHash
    }
    if other.hasOptimizeFor {
         optimizeFor = other.optimizeFor
    }
    if other.hasGoPackage {
         goPackage = other.goPackage
    }
    if other.hasCcGenericServices {
         ccGenericServices = other.ccGenericServices
    }
    if other.hasJavaGenericServices {
         javaGenericServices = other.javaGenericServices
    }
    if other.hasPyGenericServices {
         pyGenericServices = other.pyGenericServices
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBFileOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFileOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        javaPackage = input.readString()

      case 66 :
        javaOuterClassname = input.readString()

      case 72 :
        var value = input.readEnum()
        var enumMergResult:PBFileOptions.OptimizeMode = PBFileOptions.OptimizeMode(rawValue:value)!
        if (PBFileOptions.OptimizeMode.IsValidValue(enumMergResult)) {
             optimizeFor = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(9, value:Int64(value))
        }

      case 80 :
        javaMultipleFiles = input.readBool()

      case 90 :
        goPackage = input.readString()

      case 128 :
        ccGenericServices = input.readBool()

      case 136 :
        javaGenericServices = input.readBool()

      case 144 :
        pyGenericServices = input.readBool()

      case 160 :
        javaGenerateEqualsAndHash = input.readBool()

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBMessageOptions : ExtendableMessage {
  private(set) var hasMessageSetWireFormat:Bool = false
  private(set) var messageSetWireFormat:Bool = false

  private(set) var hasNoStandardDescriptorAccessor:Bool = false
  private(set) var noStandardDescriptorAccessor:Bool = false

  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMessageSetWireFormat {
      output.writeBool(1, value:messageSetWireFormat)
    }
    if hasNoStandardDescriptorAccessor {
      output.writeBool(2, value:noStandardDescriptorAccessor)
    }
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMessageSetWireFormat {
      size += WireFormat.computeBoolSize(1, value:messageSetWireFormat)
    }
    if hasNoStandardDescriptorAccessor {
      size += WireFormat.computeBoolSize(2, value:noStandardDescriptorAccessor)
    }
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBMessageOptions {
    return PBMessageOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBMessageOptions {
    return PBMessageOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBMessageOptions {
    return PBMessageOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBMessageOptions {
    return PBMessageOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBMessageOptions {
    return PBMessageOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMessageOptions {
    return PBMessageOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBMessageOptionsBuilder {
    return PBMessageOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBMessageOptions) -> PBMessageOptionsBuilder {
    return PBMessageOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBMessageOptionsBuilder {
    return PBMessageOptions.builder()
  }
  func toBuilder() -> PBMessageOptionsBuilder {
    return PBMessageOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasMessageSetWireFormat {
      output += "\(indent) messageSetWireFormat: \(messageSetWireFormat) \n"
    }
    if hasNoStandardDescriptorAccessor {
      output += "\(indent) noStandardDescriptorAccessor: \(noStandardDescriptorAccessor) \n"
    }
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMessageSetWireFormat {
             hashCode = (hashCode &* 31) &+ messageSetWireFormat.hashValue
          }
          if hasNoStandardDescriptorAccessor {
             hashCode = (hashCode &* 31) &+ noStandardDescriptorAccessor.hashValue
          }
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBMessageOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBMessageOptions.self
  }


  //Meta information declaration end

}

final class PBMessageOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBMessageOptions

  required override init () {
     builderResult = PBMessageOptions()
     super.init()
  }
  var hasMessageSetWireFormat:Bool {
       get {
            return builderResult.hasMessageSetWireFormat
       }
  }
  var messageSetWireFormat:Bool {
       get {
            return builderResult.messageSetWireFormat
       }
       set (value) {
           builderResult.hasMessageSetWireFormat = true
           builderResult.messageSetWireFormat = value
       }
  }
  func clearMessageSetWireFormat() -> PBMessageOptionsBuilder{
       builderResult.hasMessageSetWireFormat = false
       builderResult.messageSetWireFormat = false
       return self
  }
  var hasNoStandardDescriptorAccessor:Bool {
       get {
            return builderResult.hasNoStandardDescriptorAccessor
       }
  }
  var noStandardDescriptorAccessor:Bool {
       get {
            return builderResult.noStandardDescriptorAccessor
       }
       set (value) {
           builderResult.hasNoStandardDescriptorAccessor = true
           builderResult.noStandardDescriptorAccessor = value
       }
  }
  func clearNoStandardDescriptorAccessor() -> PBMessageOptionsBuilder{
       builderResult.hasNoStandardDescriptorAccessor = false
       builderResult.noStandardDescriptorAccessor = false
       return self
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBMessageOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBMessageOptionsBuilder {
    builderResult = PBMessageOptions()
    return self
  }
  override func clone() -> PBMessageOptionsBuilder {
    return PBMessageOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBMessageOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBMessageOptions {
    var returnMe:PBMessageOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBMessageOptions) -> PBMessageOptionsBuilder {
    if (other == PBMessageOptions()) {
     return self
    }
    if other.hasMessageSetWireFormat {
         messageSetWireFormat = other.messageSetWireFormat
    }
    if other.hasNoStandardDescriptorAccessor {
         noStandardDescriptorAccessor = other.noStandardDescriptorAccessor
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBMessageOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMessageOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        messageSetWireFormat = input.readBool()

      case 16 :
        noStandardDescriptorAccessor = input.readBool()

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBFieldOptions : ExtendableMessage {


    //Enum type declaration start 

    enum Ctype:Int32 {
      case String = 0
      case Cord = 1
      case StringPiece = 2

      static func IsValidValue(value:Ctype) ->Bool {
        switch value {
          case .String, .Cord, .StringPiece:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var ctype:PBFieldOptions.Ctype = PBFieldOptions.Ctype.String
  private(set) var hasCtype:Bool = false
  private(set) var hasPacked:Bool = false
  private(set) var packed:Bool = false

  private(set) var hasLazy:Bool = false
  private(set) var lazy:Bool = false

  private(set) var hasDeprecated:Bool = false
  private(set) var deprecated:Bool = false

  private(set) var hasExperimentalMapKey:Bool = false
  private(set) var experimentalMapKey:String = ""

  private(set) var hasWeak:Bool = false
  private(set) var weak:Bool = false

  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasCtype {
      output.writeEnum(1, value:ctype.rawValue)
    }
    if hasPacked {
      output.writeBool(2, value:packed)
    }
    if hasDeprecated {
      output.writeBool(3, value:deprecated)
    }
    if hasLazy {
      output.writeBool(5, value:lazy)
    }
    if hasExperimentalMapKey {
      output.writeString(9, value:experimentalMapKey)
    }
    if hasWeak {
      output.writeBool(10, value:weak)
    }
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if (hasCtype) {
      size += WireFormat.computeEnumSize(1, value:ctype.rawValue)
    }
    if hasPacked {
      size += WireFormat.computeBoolSize(2, value:packed)
    }
    if hasDeprecated {
      size += WireFormat.computeBoolSize(3, value:deprecated)
    }
    if hasLazy {
      size += WireFormat.computeBoolSize(5, value:lazy)
    }
    if hasExperimentalMapKey {
      size += WireFormat.computeStringSize(9, value:experimentalMapKey)
    }
    if hasWeak {
      size += WireFormat.computeBoolSize(10, value:weak)
    }
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBFieldOptions {
    return PBFieldOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBFieldOptions {
    return PBFieldOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBFieldOptions {
    return PBFieldOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBFieldOptions {
    return PBFieldOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBFieldOptions {
    return PBFieldOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFieldOptions {
    return PBFieldOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBFieldOptionsBuilder {
    return PBFieldOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBFieldOptions) -> PBFieldOptionsBuilder {
    return PBFieldOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBFieldOptionsBuilder {
    return PBFieldOptions.builder()
  }
  func toBuilder() -> PBFieldOptionsBuilder {
    return PBFieldOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if (hasCtype) {
      output += "\(indent) ctype: \(ctype.rawValue)\n"
    }
    if hasPacked {
      output += "\(indent) packed: \(packed) \n"
    }
    if hasDeprecated {
      output += "\(indent) deprecated: \(deprecated) \n"
    }
    if hasLazy {
      output += "\(indent) lazy: \(lazy) \n"
    }
    if hasExperimentalMapKey {
      output += "\(indent) experimentalMapKey: \(experimentalMapKey) \n"
    }
    if hasWeak {
      output += "\(indent) weak: \(weak) \n"
    }
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasCtype {
             hashCode = (hashCode &* 31) &+ Int(ctype.rawValue)
          }
          if hasPacked {
             hashCode = (hashCode &* 31) &+ packed.hashValue
          }
          if hasDeprecated {
             hashCode = (hashCode &* 31) &+ deprecated.hashValue
          }
          if hasLazy {
             hashCode = (hashCode &* 31) &+ lazy.hashValue
          }
          if hasExperimentalMapKey {
             hashCode = (hashCode &* 31) &+ experimentalMapKey.hashValue
          }
          if hasWeak {
             hashCode = (hashCode &* 31) &+ weak.hashValue
          }
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBFieldOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBFieldOptions.self
  }


  //Meta information declaration end

}

final class PBFieldOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBFieldOptions

  required override init () {
     builderResult = PBFieldOptions()
     super.init()
  }
    var hasCtype:Bool{
        get {
            return builderResult.hasCtype
        }
    }
    var ctype:PBFieldOptions.Ctype {
        get {
            return builderResult.ctype
        }
        set (value) {
            builderResult.hasCtype = true
            builderResult.ctype = value
        }
    }
    func clearCtype() -> PBFieldOptionsBuilder {
       builderResult.hasCtype = false
       builderResult.ctype = .String
       return self
    }
  var hasPacked:Bool {
       get {
            return builderResult.hasPacked
       }
  }
  var packed:Bool {
       get {
            return builderResult.packed
       }
       set (value) {
           builderResult.hasPacked = true
           builderResult.packed = value
       }
  }
  func clearPacked() -> PBFieldOptionsBuilder{
       builderResult.hasPacked = false
       builderResult.packed = false
       return self
  }
  var hasLazy:Bool {
       get {
            return builderResult.hasLazy
       }
  }
  var lazy:Bool {
       get {
            return builderResult.lazy
       }
       set (value) {
           builderResult.hasLazy = true
           builderResult.lazy = value
       }
  }
  func clearLazy() -> PBFieldOptionsBuilder{
       builderResult.hasLazy = false
       builderResult.lazy = false
       return self
  }
  var hasDeprecated:Bool {
       get {
            return builderResult.hasDeprecated
       }
  }
  var deprecated:Bool {
       get {
            return builderResult.deprecated
       }
       set (value) {
           builderResult.hasDeprecated = true
           builderResult.deprecated = value
       }
  }
  func clearDeprecated() -> PBFieldOptionsBuilder{
       builderResult.hasDeprecated = false
       builderResult.deprecated = false
       return self
  }
  var hasExperimentalMapKey:Bool {
       get {
            return builderResult.hasExperimentalMapKey
       }
  }
  var experimentalMapKey:String {
       get {
            return builderResult.experimentalMapKey
       }
       set (value) {
           builderResult.hasExperimentalMapKey = true
           builderResult.experimentalMapKey = value
       }
  }
  func clearExperimentalMapKey() -> PBFieldOptionsBuilder{
       builderResult.hasExperimentalMapKey = false
       builderResult.experimentalMapKey = ""
       return self
  }
  var hasWeak:Bool {
       get {
            return builderResult.hasWeak
       }
  }
  var weak:Bool {
       get {
            return builderResult.weak
       }
       set (value) {
           builderResult.hasWeak = true
           builderResult.weak = value
       }
  }
  func clearWeak() -> PBFieldOptionsBuilder{
       builderResult.hasWeak = false
       builderResult.weak = false
       return self
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBFieldOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBFieldOptionsBuilder {
    builderResult = PBFieldOptions()
    return self
  }
  override func clone() -> PBFieldOptionsBuilder {
    return PBFieldOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBFieldOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBFieldOptions {
    var returnMe:PBFieldOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBFieldOptions) -> PBFieldOptionsBuilder {
    if (other == PBFieldOptions()) {
     return self
    }
    if other.hasCtype {
         ctype = other.ctype
    }
    if other.hasPacked {
         packed = other.packed
    }
    if other.hasLazy {
         lazy = other.lazy
    }
    if other.hasDeprecated {
         deprecated = other.deprecated
    }
    if other.hasExperimentalMapKey {
         experimentalMapKey = other.experimentalMapKey
    }
    if other.hasWeak {
         weak = other.weak
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBFieldOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBFieldOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        var value = input.readEnum()
        var enumMergResult:PBFieldOptions.Ctype = PBFieldOptions.Ctype(rawValue:value)!
        if (PBFieldOptions.Ctype.IsValidValue(enumMergResult)) {
             ctype = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(1, value:Int64(value))
        }

      case 16 :
        packed = input.readBool()

      case 24 :
        deprecated = input.readBool()

      case 40 :
        lazy = input.readBool()

      case 74 :
        experimentalMapKey = input.readString()

      case 80 :
        weak = input.readBool()

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBEnumOptions : ExtendableMessage {
  private(set) var hasAllowAlias:Bool = false
  private(set) var allowAlias:Bool = true

  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasAllowAlias {
      output.writeBool(2, value:allowAlias)
    }
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasAllowAlias {
      size += WireFormat.computeBoolSize(2, value:allowAlias)
    }
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBEnumOptions {
    return PBEnumOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBEnumOptions {
    return PBEnumOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBEnumOptions {
    return PBEnumOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBEnumOptions {
    return PBEnumOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBEnumOptions {
    return PBEnumOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumOptions {
    return PBEnumOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBEnumOptionsBuilder {
    return PBEnumOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBEnumOptions) -> PBEnumOptionsBuilder {
    return PBEnumOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBEnumOptionsBuilder {
    return PBEnumOptions.builder()
  }
  func toBuilder() -> PBEnumOptionsBuilder {
    return PBEnumOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasAllowAlias {
      output += "\(indent) allowAlias: \(allowAlias) \n"
    }
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasAllowAlias {
             hashCode = (hashCode &* 31) &+ allowAlias.hashValue
          }
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBEnumOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBEnumOptions.self
  }


  //Meta information declaration end

}

final class PBEnumOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBEnumOptions

  required override init () {
     builderResult = PBEnumOptions()
     super.init()
  }
  var hasAllowAlias:Bool {
       get {
            return builderResult.hasAllowAlias
       }
  }
  var allowAlias:Bool {
       get {
            return builderResult.allowAlias
       }
       set (value) {
           builderResult.hasAllowAlias = true
           builderResult.allowAlias = value
       }
  }
  func clearAllowAlias() -> PBEnumOptionsBuilder{
       builderResult.hasAllowAlias = false
       builderResult.allowAlias = true
       return self
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBEnumOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBEnumOptionsBuilder {
    builderResult = PBEnumOptions()
    return self
  }
  override func clone() -> PBEnumOptionsBuilder {
    return PBEnumOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBEnumOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBEnumOptions {
    var returnMe:PBEnumOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBEnumOptions) -> PBEnumOptionsBuilder {
    if (other == PBEnumOptions()) {
     return self
    }
    if other.hasAllowAlias {
         allowAlias = other.allowAlias
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBEnumOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 16 :
        allowAlias = input.readBool()

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBEnumValueOptions : ExtendableMessage {
  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumValueOptions {
    return PBEnumValueOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBEnumValueOptionsBuilder {
    return PBEnumValueOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBEnumValueOptions) -> PBEnumValueOptionsBuilder {
    return PBEnumValueOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBEnumValueOptionsBuilder {
    return PBEnumValueOptions.builder()
  }
  func toBuilder() -> PBEnumValueOptionsBuilder {
    return PBEnumValueOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBEnumValueOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBEnumValueOptions.self
  }


  //Meta information declaration end

}

final class PBEnumValueOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBEnumValueOptions

  required override init () {
     builderResult = PBEnumValueOptions()
     super.init()
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBEnumValueOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBEnumValueOptionsBuilder {
    builderResult = PBEnumValueOptions()
    return self
  }
  override func clone() -> PBEnumValueOptionsBuilder {
    return PBEnumValueOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBEnumValueOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBEnumValueOptions {
    var returnMe:PBEnumValueOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBEnumValueOptions) -> PBEnumValueOptionsBuilder {
    if (other == PBEnumValueOptions()) {
     return self
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBEnumValueOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBEnumValueOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBServiceOptions : ExtendableMessage {
  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBServiceOptions {
    return PBServiceOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBServiceOptions {
    return PBServiceOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBServiceOptions {
    return PBServiceOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBServiceOptions {
    return PBServiceOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBServiceOptions {
    return PBServiceOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBServiceOptions {
    return PBServiceOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBServiceOptionsBuilder {
    return PBServiceOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBServiceOptions) -> PBServiceOptionsBuilder {
    return PBServiceOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBServiceOptionsBuilder {
    return PBServiceOptions.builder()
  }
  func toBuilder() -> PBServiceOptionsBuilder {
    return PBServiceOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBServiceOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBServiceOptions.self
  }


  //Meta information declaration end

}

final class PBServiceOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBServiceOptions

  required override init () {
     builderResult = PBServiceOptions()
     super.init()
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBServiceOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBServiceOptionsBuilder {
    builderResult = PBServiceOptions()
    return self
  }
  override func clone() -> PBServiceOptionsBuilder {
    return PBServiceOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBServiceOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBServiceOptions {
    var returnMe:PBServiceOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBServiceOptions) -> PBServiceOptionsBuilder {
    if (other == PBServiceOptions()) {
     return self
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBServiceOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBServiceOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBMethodOptions : ExtendableMessage {
  private(set) var uninterpretedOption:Array<PBUninterpretedOption>  = Array<PBUninterpretedOption>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInituninterpretedOption:Bool = true
    for element in uninterpretedOption {
        if (!element.isInitialized()) {
            isInituninterpretedOption = false
            break 
        }
    }
    if !isInituninterpretedOption {
     return isInituninterpretedOption
     }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in uninterpretedOption {
        output.writeMessage(999, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in uninterpretedOption {
        size += WireFormat.computeMessageSize(999, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBMethodOptions {
    return PBMethodOptions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBMethodOptions {
    return PBMethodOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBMethodOptions {
    return PBMethodOptions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBMethodOptions {
    return PBMethodOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBMethodOptions {
    return PBMethodOptions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMethodOptions {
    return PBMethodOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBMethodOptionsBuilder {
    return PBMethodOptionsBuilder()
  }
  class func builderWithPrototype(prototype:PBMethodOptions) -> PBMethodOptionsBuilder {
    return PBMethodOptions.builder().mergeFrom(prototype)
  }
  func builder() -> PBMethodOptionsBuilder {
    return PBMethodOptions.builder()
  }
  func toBuilder() -> PBMethodOptionsBuilder {
    return PBMethodOptions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var uninterpretedOptionElementIndex:Int = 0
    for element in uninterpretedOption {
        output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        uninterpretedOptionElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in uninterpretedOption {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBMethodOptions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBMethodOptions.self
  }


  //Meta information declaration end

}

final class PBMethodOptionsBuilder : ExtendableMessageBuilder {
  private var builderResult:PBMethodOptions

  required override init () {
     builderResult = PBMethodOptions()
     super.init()
  }
  var uninterpretedOption:Array<PBUninterpretedOption> {
       get {
           return builderResult.uninterpretedOption
       }
       set (value) {
           builderResult.uninterpretedOption = value
       }
  }
  func clearUninterpretedOption() -> PBMethodOptionsBuilder {
    builderResult.uninterpretedOption.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> PBMethodOptionsBuilder {
    builderResult = PBMethodOptions()
    return self
  }
  override func clone() -> PBMethodOptionsBuilder {
    return PBMethodOptions.builderWithPrototype(builderResult)
  }
  override func build() -> PBMethodOptions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBMethodOptions {
    var returnMe:PBMethodOptions = builderResult
    return returnMe
  }
  func mergeFrom(other:PBMethodOptions) -> PBMethodOptionsBuilder {
    if (other == PBMethodOptions()) {
     return self
    }
    if !other.uninterpretedOption.isEmpty  {
       builderResult.uninterpretedOption += other.uninterpretedOption
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBMethodOptionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBMethodOptionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 7994 :
        var subBuilder = PBUninterpretedOption.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        uninterpretedOption += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBUninterpretedOption : GeneratedMessage {


  //Nested type declaration start

    final public class NamePart : GeneratedMessage {
      private(set) var hasNamePart:Bool = false
      private(set) var namePart:String = ""

      private(set) var hasIsExtension:Bool = false
      private(set) var isExtension:Bool = false

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasNamePart {
          return false
        }
        if !hasIsExtension {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasNamePart {
          output.writeString(1, value:namePart)
        }
        if hasIsExtension {
          output.writeBool(2, value:isExtension)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasNamePart {
          size += WireFormat.computeStringSize(1, value:namePart)
        }
        if hasIsExtension {
          size += WireFormat.computeBoolSize(2, value:isExtension)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption.NamePart {
        return PBUninterpretedOption.NamePart.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> PBUninterpretedOption.NamePartBuilder {
        return PBUninterpretedOption.NamePartBuilder()
      }
      class func builderWithPrototype(prototype:PBUninterpretedOption.NamePart) -> PBUninterpretedOption.NamePartBuilder {
        return PBUninterpretedOption.NamePart.builder().mergeFrom(prototype)
      }
      func builder() -> PBUninterpretedOption.NamePartBuilder {
        return PBUninterpretedOption.NamePart.builder()
      }
      func toBuilder() -> PBUninterpretedOption.NamePartBuilder {
        return PBUninterpretedOption.NamePart.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasNamePart {
          output += "\(indent) namePart: \(namePart) \n"
        }
        if hasIsExtension {
          output += "\(indent) isExtension: \(isExtension) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasNamePart {
                 hashCode = (hashCode &* 31) &+ namePart.hashValue
              }
              if hasIsExtension {
                 hashCode = (hashCode &* 31) &+ isExtension.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "PBUninterpretedOption.NamePart"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return PBUninterpretedOption.NamePart.self
      }


      //Meta information declaration end

    }

    final class NamePartBuilder : GeneratedMessageBuilder {
      private var builderResult:PBUninterpretedOption.NamePart

      required override init () {
         builderResult = PBUninterpretedOption.NamePart()
         super.init()
      }
      var hasNamePart:Bool {
           get {
                return builderResult.hasNamePart
           }
      }
      var namePart:String {
           get {
                return builderResult.namePart
           }
           set (value) {
               builderResult.hasNamePart = true
               builderResult.namePart = value
           }
      }
      func clearNamePart() -> PBUninterpretedOption.NamePartBuilder{
           builderResult.hasNamePart = false
           builderResult.namePart = ""
           return self
      }
      var hasIsExtension:Bool {
           get {
                return builderResult.hasIsExtension
           }
      }
      var isExtension:Bool {
           get {
                return builderResult.isExtension
           }
           set (value) {
               builderResult.hasIsExtension = true
               builderResult.isExtension = value
           }
      }
      func clearIsExtension() -> PBUninterpretedOption.NamePartBuilder{
           builderResult.hasIsExtension = false
           builderResult.isExtension = false
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> PBUninterpretedOption.NamePartBuilder {
        builderResult = PBUninterpretedOption.NamePart()
        return self
      }
      override func clone() -> PBUninterpretedOption.NamePartBuilder {
        return PBUninterpretedOption.NamePart.builderWithPrototype(builderResult)
      }
      override func build() -> PBUninterpretedOption.NamePart {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> PBUninterpretedOption.NamePart {
        var returnMe:PBUninterpretedOption.NamePart = builderResult
        return returnMe
      }
      func mergeFrom(other:PBUninterpretedOption.NamePart) -> PBUninterpretedOption.NamePartBuilder {
        if (other == PBUninterpretedOption.NamePart()) {
         return self
        }
        if other.hasNamePart {
             namePart = other.namePart
        }
        if other.hasIsExtension {
             isExtension = other.isExtension
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->PBUninterpretedOption.NamePartBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption.NamePartBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 10 :
            namePart = input.readString()

          case 16 :
            isExtension = input.readBool()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasIdentifierValue:Bool = false
  private(set) var identifierValue:String = ""

  private(set) var hasPositiveIntValue:Bool = false
  private(set) var positiveIntValue:UInt64 = UInt64(0)

  private(set) var hasNegativeIntValue:Bool = false
  private(set) var negativeIntValue:Int64 = Int64(0)

  private(set) var hasDoubleValue:Bool = false
  private(set) var doubleValue:Double = Double(0)

  private(set) var hasStringValue:Bool = false
  private(set) var stringValue:Array<Byte> = [Byte]()

  private(set) var hasAggregateValue:Bool = false
  private(set) var aggregateValue:String = ""

  private(set) var name:Array<PBUninterpretedOption.NamePart>  = Array<PBUninterpretedOption.NamePart>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    var isInitname:Bool = true
    for element in name {
        if (!element.isInitialized()) {
            isInitname = false
            break 
        }
    }
    if !isInitname {
     return isInitname
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in name {
        output.writeMessage(2, value:element)
    }
    if hasIdentifierValue {
      output.writeString(3, value:identifierValue)
    }
    if hasPositiveIntValue {
      output.writeUInt64(4, value:positiveIntValue)
    }
    if hasNegativeIntValue {
      output.writeInt64(5, value:negativeIntValue)
    }
    if hasDoubleValue {
      output.writeDouble(6, value:doubleValue)
    }
    if hasStringValue {
      output.writeData(7, value:stringValue)
    }
    if hasAggregateValue {
      output.writeString(8, value:aggregateValue)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in name {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    if hasIdentifierValue {
      size += WireFormat.computeStringSize(3, value:identifierValue)
    }
    if hasPositiveIntValue {
      size += WireFormat.computeUInt64Size(4, value:positiveIntValue)
    }
    if hasNegativeIntValue {
      size += WireFormat.computeInt64Size(5, value:negativeIntValue)
    }
    if hasDoubleValue {
      size += WireFormat.computeDoubleSize(6, value:doubleValue)
    }
    if hasStringValue {
      size += WireFormat.computeDataSize(7, value:stringValue)
    }
    if hasAggregateValue {
      size += WireFormat.computeStringSize(8, value:aggregateValue)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption {
    return PBUninterpretedOption.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBUninterpretedOptionBuilder {
    return PBUninterpretedOptionBuilder()
  }
  class func builderWithPrototype(prototype:PBUninterpretedOption) -> PBUninterpretedOptionBuilder {
    return PBUninterpretedOption.builder().mergeFrom(prototype)
  }
  func builder() -> PBUninterpretedOptionBuilder {
    return PBUninterpretedOption.builder()
  }
  func toBuilder() -> PBUninterpretedOptionBuilder {
    return PBUninterpretedOption.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var nameElementIndex:Int = 0
    for element in name {
        output += "\(indent) name[\(nameElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        nameElementIndex++
    }
    if hasIdentifierValue {
      output += "\(indent) identifierValue: \(identifierValue) \n"
    }
    if hasPositiveIntValue {
      output += "\(indent) positiveIntValue: \(positiveIntValue) \n"
    }
    if hasNegativeIntValue {
      output += "\(indent) negativeIntValue: \(negativeIntValue) \n"
    }
    if hasDoubleValue {
      output += "\(indent) doubleValue: \(doubleValue) \n"
    }
    if hasStringValue {
      output += "\(indent) stringValue: \(stringValue) \n"
    }
    if hasAggregateValue {
      output += "\(indent) aggregateValue: \(aggregateValue) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in name {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasIdentifierValue {
             hashCode = (hashCode &* 31) &+ identifierValue.hashValue
          }
          if hasPositiveIntValue {
             hashCode = (hashCode &* 31) &+ positiveIntValue.hashValue
          }
          if hasNegativeIntValue {
             hashCode = (hashCode &* 31) &+ negativeIntValue.hashValue
          }
          if hasDoubleValue {
             hashCode = (hashCode &* 31) &+ doubleValue.hashValue
          }
          for value in stringValue {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasAggregateValue {
             hashCode = (hashCode &* 31) &+ aggregateValue.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBUninterpretedOption"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBUninterpretedOption.self
  }


  //Meta information declaration end

}

final class PBUninterpretedOptionBuilder : GeneratedMessageBuilder {
  private var builderResult:PBUninterpretedOption

  required override init () {
     builderResult = PBUninterpretedOption()
     super.init()
  }
  var name:Array<PBUninterpretedOption.NamePart> {
       get {
           return builderResult.name
       }
       set (value) {
           builderResult.name = value
       }
  }
  func clearName() -> PBUninterpretedOptionBuilder {
    builderResult.name.removeAll(keepCapacity: false)
    return self
  }
  var hasIdentifierValue:Bool {
       get {
            return builderResult.hasIdentifierValue
       }
  }
  var identifierValue:String {
       get {
            return builderResult.identifierValue
       }
       set (value) {
           builderResult.hasIdentifierValue = true
           builderResult.identifierValue = value
       }
  }
  func clearIdentifierValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasIdentifierValue = false
       builderResult.identifierValue = ""
       return self
  }
  var hasPositiveIntValue:Bool {
       get {
            return builderResult.hasPositiveIntValue
       }
  }
  var positiveIntValue:UInt64 {
       get {
            return builderResult.positiveIntValue
       }
       set (value) {
           builderResult.hasPositiveIntValue = true
           builderResult.positiveIntValue = value
       }
  }
  func clearPositiveIntValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasPositiveIntValue = false
       builderResult.positiveIntValue = UInt64(0)
       return self
  }
  var hasNegativeIntValue:Bool {
       get {
            return builderResult.hasNegativeIntValue
       }
  }
  var negativeIntValue:Int64 {
       get {
            return builderResult.negativeIntValue
       }
       set (value) {
           builderResult.hasNegativeIntValue = true
           builderResult.negativeIntValue = value
       }
  }
  func clearNegativeIntValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasNegativeIntValue = false
       builderResult.negativeIntValue = Int64(0)
       return self
  }
  var hasDoubleValue:Bool {
       get {
            return builderResult.hasDoubleValue
       }
  }
  var doubleValue:Double {
       get {
            return builderResult.doubleValue
       }
       set (value) {
           builderResult.hasDoubleValue = true
           builderResult.doubleValue = value
       }
  }
  func clearDoubleValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasDoubleValue = false
       builderResult.doubleValue = Double(0)
       return self
  }
  var hasStringValue:Bool {
       get {
            return builderResult.hasStringValue
       }
  }
  var stringValue:Array<Byte> {
       get {
            return builderResult.stringValue
       }
       set (value) {
           builderResult.hasStringValue = true
           builderResult.stringValue = value
       }
  }
  func clearStringValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasStringValue = false
       builderResult.stringValue = [Byte]()
       return self
  }
  var hasAggregateValue:Bool {
       get {
            return builderResult.hasAggregateValue
       }
  }
  var aggregateValue:String {
       get {
            return builderResult.aggregateValue
       }
       set (value) {
           builderResult.hasAggregateValue = true
           builderResult.aggregateValue = value
       }
  }
  func clearAggregateValue() -> PBUninterpretedOptionBuilder{
       builderResult.hasAggregateValue = false
       builderResult.aggregateValue = ""
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBUninterpretedOptionBuilder {
    builderResult = PBUninterpretedOption()
    return self
  }
  override func clone() -> PBUninterpretedOptionBuilder {
    return PBUninterpretedOption.builderWithPrototype(builderResult)
  }
  override func build() -> PBUninterpretedOption {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBUninterpretedOption {
    var returnMe:PBUninterpretedOption = builderResult
    return returnMe
  }
  func mergeFrom(other:PBUninterpretedOption) -> PBUninterpretedOptionBuilder {
    if (other == PBUninterpretedOption()) {
     return self
    }
    if !other.name.isEmpty  {
       builderResult.name += other.name
    }
    if other.hasIdentifierValue {
         identifierValue = other.identifierValue
    }
    if other.hasPositiveIntValue {
         positiveIntValue = other.positiveIntValue
    }
    if other.hasNegativeIntValue {
         negativeIntValue = other.negativeIntValue
    }
    if other.hasDoubleValue {
         doubleValue = other.doubleValue
    }
    if other.hasStringValue {
         stringValue = other.stringValue
    }
    if other.hasAggregateValue {
         aggregateValue = other.aggregateValue
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBUninterpretedOptionBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOptionBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 18 :
        var subBuilder = PBUninterpretedOption.NamePart.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        name += [subBuilder.buildPartial()]

      case 26 :
        identifierValue = input.readString()

      case 32 :
        positiveIntValue = input.readUInt64()

      case 40 :
        negativeIntValue = input.readInt64()

      case 49 :
        doubleValue = input.readDouble()

      case 58 :
        stringValue = input.readData()

      case 66 :
        aggregateValue = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class PBSourceCodeInfo : GeneratedMessage {


  //Nested type declaration start

    final public class Location : GeneratedMessage {
      private(set) var hasLeadingComments:Bool = false
      private(set) var leadingComments:String = ""

      private(set) var hasTrailingComments:Bool = false
      private(set) var trailingComments:String = ""

      private(set) var path:Array<Int32> = Array<Int32>()
      private var pathMemoizedSerializedSize:Int32 = -1
      private(set) var span:Array<Int32> = Array<Int32>()
      private var spanMemoizedSerializedSize:Int32 = -1
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if !path.isEmpty {
          output.writeRawVarint32(10)
          output.writeRawVarint32(pathMemoizedSerializedSize)
          for value in path {
            output.writeInt32NoTag(value)
          }
        }
        if !span.isEmpty {
          output.writeRawVarint32(18)
          output.writeRawVarint32(spanMemoizedSerializedSize)
          for value in span {
            output.writeInt32NoTag(value)
          }
        }
        if hasLeadingComments {
          output.writeString(3, value:leadingComments)
        }
        if hasTrailingComments {
          output.writeString(4, value:trailingComments)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        var dataSizePath:Int32 = 0
        for element in path {
            dataSizePath += WireFormat.computeInt32SizeNoTag(element)
        }
        size += dataSizePath
        if !path.isEmpty {
          size += 1
          size += WireFormat.computeInt32SizeNoTag(dataSizePath)
        }
        pathMemoizedSerializedSize = dataSizePath
        var dataSizeSpan:Int32 = 0
        for element in span {
            dataSizeSpan += WireFormat.computeInt32SizeNoTag(element)
        }
        size += dataSizeSpan
        if !span.isEmpty {
          size += 1
          size += WireFormat.computeInt32SizeNoTag(dataSizeSpan)
        }
        spanMemoizedSerializedSize = dataSizeSpan
        if hasLeadingComments {
          size += WireFormat.computeStringSize(3, value:leadingComments)
        }
        if hasTrailingComments {
          size += WireFormat.computeStringSize(4, value:trailingComments)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo.Location {
        return PBSourceCodeInfo.Location.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> PBSourceCodeInfo.LocationBuilder {
        return PBSourceCodeInfo.LocationBuilder()
      }
      class func builderWithPrototype(prototype:PBSourceCodeInfo.Location) -> PBSourceCodeInfo.LocationBuilder {
        return PBSourceCodeInfo.Location.builder().mergeFrom(prototype)
      }
      func builder() -> PBSourceCodeInfo.LocationBuilder {
        return PBSourceCodeInfo.Location.builder()
      }
      func toBuilder() -> PBSourceCodeInfo.LocationBuilder {
        return PBSourceCodeInfo.Location.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        var pathElementIndex:Int = 0
        for element in path  {
            output += "\(indent) path[\(pathElementIndex)]: \(element)\n"
            pathElementIndex++
        }
        var spanElementIndex:Int = 0
        for element in span  {
            output += "\(indent) span[\(spanElementIndex)]: \(element)\n"
            spanElementIndex++
        }
        if hasLeadingComments {
          output += "\(indent) leadingComments: \(leadingComments) \n"
        }
        if hasTrailingComments {
          output += "\(indent) trailingComments: \(trailingComments) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for element in path {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in span {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              if hasLeadingComments {
                 hashCode = (hashCode &* 31) &+ leadingComments.hashValue
              }
              if hasTrailingComments {
                 hashCode = (hashCode &* 31) &+ trailingComments.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "PBSourceCodeInfo.Location"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return PBSourceCodeInfo.Location.self
      }


      //Meta information declaration end

    }

    final class LocationBuilder : GeneratedMessageBuilder {
      private var builderResult:PBSourceCodeInfo.Location

      required override init () {
         builderResult = PBSourceCodeInfo.Location()
         super.init()
      }
      var path:Array<Int32> {
           get {
               return builderResult.path
           }
           set (array) {
               builderResult.path = array
           }
      }
      func clearPath() -> PBSourceCodeInfo.LocationBuilder {
         builderResult.path.removeAll(keepCapacity: false)
         return self
      }
      var span:Array<Int32> {
           get {
               return builderResult.span
           }
           set (array) {
               builderResult.span = array
           }
      }
      func clearSpan() -> PBSourceCodeInfo.LocationBuilder {
         builderResult.span.removeAll(keepCapacity: false)
         return self
      }
      var hasLeadingComments:Bool {
           get {
                return builderResult.hasLeadingComments
           }
      }
      var leadingComments:String {
           get {
                return builderResult.leadingComments
           }
           set (value) {
               builderResult.hasLeadingComments = true
               builderResult.leadingComments = value
           }
      }
      func clearLeadingComments() -> PBSourceCodeInfo.LocationBuilder{
           builderResult.hasLeadingComments = false
           builderResult.leadingComments = ""
           return self
      }
      var hasTrailingComments:Bool {
           get {
                return builderResult.hasTrailingComments
           }
      }
      var trailingComments:String {
           get {
                return builderResult.trailingComments
           }
           set (value) {
               builderResult.hasTrailingComments = true
               builderResult.trailingComments = value
           }
      }
      func clearTrailingComments() -> PBSourceCodeInfo.LocationBuilder{
           builderResult.hasTrailingComments = false
           builderResult.trailingComments = ""
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> PBSourceCodeInfo.LocationBuilder {
        builderResult = PBSourceCodeInfo.Location()
        return self
      }
      override func clone() -> PBSourceCodeInfo.LocationBuilder {
        return PBSourceCodeInfo.Location.builderWithPrototype(builderResult)
      }
      override func build() -> PBSourceCodeInfo.Location {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> PBSourceCodeInfo.Location {
        var returnMe:PBSourceCodeInfo.Location = builderResult
        return returnMe
      }
      func mergeFrom(other:PBSourceCodeInfo.Location) -> PBSourceCodeInfo.LocationBuilder {
        if (other == PBSourceCodeInfo.Location()) {
         return self
        }
        if !other.path.isEmpty {
            builderResult.path += other.path
        }
        if !other.span.isEmpty {
            builderResult.span += other.span
        }
        if other.hasLeadingComments {
             leadingComments = other.leadingComments
        }
        if other.hasTrailingComments {
             trailingComments = other.trailingComments
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->PBSourceCodeInfo.LocationBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo.LocationBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 10 :
            var length:Int32 = input.readRawVarint32()
            var limit:Int32 = input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.path += [input.readInt32()]
            }
            input.popLimit(limit)

          case 18 :
            var length:Int32 = input.readRawVarint32()
            var limit:Int32 = input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.span += [input.readInt32()]
            }
            input.popLimit(limit)

          case 26 :
            leadingComments = input.readString()

          case 34 :
            trailingComments = input.readString()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var location:Array<PBSourceCodeInfo.Location>  = Array<PBSourceCodeInfo.Location>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    for element in location {
        output.writeMessage(1, value:element)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    for element in location {
        size += WireFormat.computeMessageSize(1, value:element)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo {
    return PBSourceCodeInfo.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> PBSourceCodeInfoBuilder {
    return PBSourceCodeInfoBuilder()
  }
  class func builderWithPrototype(prototype:PBSourceCodeInfo) -> PBSourceCodeInfoBuilder {
    return PBSourceCodeInfo.builder().mergeFrom(prototype)
  }
  func builder() -> PBSourceCodeInfoBuilder {
    return PBSourceCodeInfo.builder()
  }
  func toBuilder() -> PBSourceCodeInfoBuilder {
    return PBSourceCodeInfo.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var locationElementIndex:Int = 0
    for element in location {
        output += "\(indent) location[\(locationElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        locationElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in location {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PBSourceCodeInfo"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return PBSourceCodeInfo.self
  }


  //Meta information declaration end

}

final class PBSourceCodeInfoBuilder : GeneratedMessageBuilder {
  private var builderResult:PBSourceCodeInfo

  required override init () {
     builderResult = PBSourceCodeInfo()
     super.init()
  }
  var location:Array<PBSourceCodeInfo.Location> {
       get {
           return builderResult.location
       }
       set (value) {
           builderResult.location = value
       }
  }
  func clearLocation() -> PBSourceCodeInfoBuilder {
    builderResult.location.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> PBSourceCodeInfoBuilder {
    builderResult = PBSourceCodeInfo()
    return self
  }
  override func clone() -> PBSourceCodeInfoBuilder {
    return PBSourceCodeInfo.builderWithPrototype(builderResult)
  }
  override func build() -> PBSourceCodeInfo {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> PBSourceCodeInfo {
    var returnMe:PBSourceCodeInfo = builderResult
    return returnMe
  }
  func mergeFrom(other:PBSourceCodeInfo) -> PBSourceCodeInfoBuilder {
    if (other == PBSourceCodeInfo()) {
     return self
    }
    if !other.location.isEmpty  {
       builderResult.location += other.location
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->PBSourceCodeInfoBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfoBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder = PBSourceCodeInfo.Location.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        location += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension PBFileDescriptorSet {
    class func parseFromNSData(data:NSData) -> PBFileDescriptorSet {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileDescriptorSet.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorSet {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileDescriptorSet.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBFileDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBFileDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBFileDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBDescriptorProto.ExtensionRange {
    class func parseFromNSData(data:NSData) -> PBDescriptorProto.ExtensionRange {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBDescriptorProto.ExtensionRange.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBDescriptorProto.ExtensionRange {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBDescriptorProto.ExtensionRange.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBFieldDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBFieldDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFieldDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBFieldDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFieldDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBEnumDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBEnumDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBEnumDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBEnumValueDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBEnumValueDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumValueDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBEnumValueDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumValueDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBServiceDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBServiceDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBServiceDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBServiceDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBServiceDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBMethodDescriptorProto {
    class func parseFromNSData(data:NSData) -> PBMethodDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMethodDescriptorProto.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBMethodDescriptorProto {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMethodDescriptorProto.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBFileOptions {
    class func parseFromNSData(data:NSData) -> PBFileOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBFileOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFileOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBMessageOptions {
    class func parseFromNSData(data:NSData) -> PBMessageOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMessageOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBMessageOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMessageOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBFieldOptions {
    class func parseFromNSData(data:NSData) -> PBFieldOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFieldOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBFieldOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBFieldOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBEnumOptions {
    class func parseFromNSData(data:NSData) -> PBEnumOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBEnumOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBEnumValueOptions {
    class func parseFromNSData(data:NSData) -> PBEnumValueOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumValueOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBEnumValueOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBEnumValueOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBServiceOptions {
    class func parseFromNSData(data:NSData) -> PBServiceOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBServiceOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBServiceOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBServiceOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBMethodOptions {
    class func parseFromNSData(data:NSData) -> PBMethodOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMethodOptions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBMethodOptions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBMethodOptions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBUninterpretedOption.NamePart {
    class func parseFromNSData(data:NSData) -> PBUninterpretedOption.NamePart {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBUninterpretedOption.NamePart.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption.NamePart {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBUninterpretedOption.NamePart.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBUninterpretedOption {
    class func parseFromNSData(data:NSData) -> PBUninterpretedOption {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBUninterpretedOption.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBUninterpretedOption {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBUninterpretedOption.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBSourceCodeInfo.Location {
    class func parseFromNSData(data:NSData) -> PBSourceCodeInfo.Location {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBSourceCodeInfo.Location.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo.Location {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBSourceCodeInfo.Location.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension PBSourceCodeInfo {
    class func parseFromNSData(data:NSData) -> PBSourceCodeInfo {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBSourceCodeInfo.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> PBSourceCodeInfo {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return PBSourceCodeInfo.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
