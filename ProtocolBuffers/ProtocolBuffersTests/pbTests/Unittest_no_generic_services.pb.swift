// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

var UnittestNoGenericServicesRoottestExtension:ConcreateExtensionField {
   get {
       return UnittestNoGenericServicesRoot.sharedInstance.UnittestNoGenericServicesRoottestExtensionStatic
   }
}
struct UnittestNoGenericServicesRoot {
  static var sharedInstance : UnittestNoGenericServicesRoot {
   struct Static {
       static let instance : UnittestNoGenericServicesRoot = UnittestNoGenericServicesRoot()
   }
   return Static.instance
  }
  var UnittestNoGenericServicesRoottestExtensionStatic:ConcreateExtensionField
  var extensionRegistry:ExtensionRegistry

  init() {
    UnittestNoGenericServicesRoottestExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestMessage.self, fieldNumber: 1000, defaultValue:Int32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  func registerAllExtensions(registry:ExtensionRegistry) {
    registry.addExtension(UnittestNoGenericServicesRoottestExtensionStatic)
  }
  static func testExtension() -> ConcreateExtensionField {
       return UnittestNoGenericServicesRoot.sharedInstance.UnittestNoGenericServicesRoottestExtensionStatic
  }
}



//Enum type declaration start 

enum TestEnum:Int32 {
  case Foo = 1

  static func IsValidValue(value:TestEnum) ->Bool {
    switch value {
      case .Foo:
        return true;
      default:
        return false;
    }
  }
}



//Enum type declaration end 

func == (lhs: TestMessage, rhs: TestMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class TestMessage : ExtendableMessage {
  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(1, value:a)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(1, value:a)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestMessage {
    return TestMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestMessage {
    return TestMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestMessage {
    return TestMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestMessage {
    return TestMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestMessage {
    return TestMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMessage {
    return TestMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestMessageBuilder {
    return TestMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestMessage) -> TestMessageBuilder {
    return TestMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestMessageBuilder {
    return TestMessage.builder()
  }
  func toBuilder() -> TestMessageBuilder {
    return TestMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestMessage.self
  }


  //Meta information declaration end

}

final class TestMessageBuilder : ExtendableMessageBuilder {
  private var builderResult:TestMessage

  required override init () {
     builderResult = TestMessage()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> TestMessageBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestMessageBuilder {
    builderResult = TestMessage()
    return self
  }
  override func clone() -> TestMessageBuilder {
    return TestMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestMessage {
    var returnMe:TestMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestMessage) -> TestMessageBuilder {
    if (other == TestMessage()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        a = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension TestMessage {
    class func parseFromNSData(data:NSData) -> TestMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
