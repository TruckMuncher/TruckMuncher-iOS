// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

var UnittestRootoptionalInt32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalInt32ExtensionStatic
   }
}
var UnittestRootoptionalInt64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalInt64ExtensionStatic
   }
}
var UnittestRootoptionalUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalUint32ExtensionStatic
   }
}
var UnittestRootoptionalUint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalUint64ExtensionStatic
   }
}
var UnittestRootoptionalSint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSint32ExtensionStatic
   }
}
var UnittestRootoptionalSint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSint64ExtensionStatic
   }
}
var UnittestRootoptionalFixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFixed32ExtensionStatic
   }
}
var UnittestRootoptionalFixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFixed64ExtensionStatic
   }
}
var UnittestRootoptionalSfixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSfixed32ExtensionStatic
   }
}
var UnittestRootoptionalSfixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSfixed64ExtensionStatic
   }
}
var UnittestRootoptionalFloatExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFloatExtensionStatic
   }
}
var UnittestRootoptionalDoubleExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalDoubleExtensionStatic
   }
}
var UnittestRootoptionalBoolExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalBoolExtensionStatic
   }
}
var UnittestRootoptionalStringExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalStringExtensionStatic
   }
}
var UnittestRootoptionalBytesExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalBytesExtensionStatic
   }
}
var UnittestRootoptionalGroupExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalGroupExtensionStatic
   }
}
var UnittestRootoptionalNestedMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalNestedMessageExtensionStatic
   }
}
var UnittestRootoptionalForeignMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalForeignMessageExtensionStatic
   }
}
var UnittestRootoptionalImportMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalImportMessageExtensionStatic
   }
}
var UnittestRootoptionalNestedEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalNestedEnumExtensionStatic
   }
}
var UnittestRootoptionalForeignEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalForeignEnumExtensionStatic
   }
}
var UnittestRootoptionalImportEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalImportEnumExtensionStatic
   }
}
var UnittestRootoptionalStringPieceExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalStringPieceExtensionStatic
   }
}
var UnittestRootoptionalCordExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalCordExtensionStatic
   }
}
var UnittestRootoptionalPublicImportMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalPublicImportMessageExtensionStatic
   }
}
var UnittestRootoptionalLazyMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoptionalLazyMessageExtensionStatic
   }
}
var UnittestRootrepeatedInt32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedInt32ExtensionStatic
   }
}
var UnittestRootrepeatedInt64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedInt64ExtensionStatic
   }
}
var UnittestRootrepeatedUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedUint32ExtensionStatic
   }
}
var UnittestRootrepeatedUint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedUint64ExtensionStatic
   }
}
var UnittestRootrepeatedSint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSint32ExtensionStatic
   }
}
var UnittestRootrepeatedSint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSint64ExtensionStatic
   }
}
var UnittestRootrepeatedFixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFixed32ExtensionStatic
   }
}
var UnittestRootrepeatedFixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFixed64ExtensionStatic
   }
}
var UnittestRootrepeatedSfixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSfixed32ExtensionStatic
   }
}
var UnittestRootrepeatedSfixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSfixed64ExtensionStatic
   }
}
var UnittestRootrepeatedFloatExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFloatExtensionStatic
   }
}
var UnittestRootrepeatedDoubleExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedDoubleExtensionStatic
   }
}
var UnittestRootrepeatedBoolExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedBoolExtensionStatic
   }
}
var UnittestRootrepeatedStringExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedStringExtensionStatic
   }
}
var UnittestRootrepeatedBytesExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedBytesExtensionStatic
   }
}
var UnittestRootrepeatedGroupExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedGroupExtensionStatic
   }
}
var UnittestRootrepeatedNestedMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedNestedMessageExtensionStatic
   }
}
var UnittestRootrepeatedForeignMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedForeignMessageExtensionStatic
   }
}
var UnittestRootrepeatedImportMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedImportMessageExtensionStatic
   }
}
var UnittestRootrepeatedNestedEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedNestedEnumExtensionStatic
   }
}
var UnittestRootrepeatedForeignEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedForeignEnumExtensionStatic
   }
}
var UnittestRootrepeatedImportEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedImportEnumExtensionStatic
   }
}
var UnittestRootrepeatedStringPieceExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedStringPieceExtensionStatic
   }
}
var UnittestRootrepeatedCordExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedCordExtensionStatic
   }
}
var UnittestRootrepeatedLazyMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedLazyMessageExtensionStatic
   }
}
var UnittestRootdefaultInt32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultInt32ExtensionStatic
   }
}
var UnittestRootdefaultInt64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultInt64ExtensionStatic
   }
}
var UnittestRootdefaultUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultUint32ExtensionStatic
   }
}
var UnittestRootdefaultUint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultUint64ExtensionStatic
   }
}
var UnittestRootdefaultSint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSint32ExtensionStatic
   }
}
var UnittestRootdefaultSint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSint64ExtensionStatic
   }
}
var UnittestRootdefaultFixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFixed32ExtensionStatic
   }
}
var UnittestRootdefaultFixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFixed64ExtensionStatic
   }
}
var UnittestRootdefaultSfixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSfixed32ExtensionStatic
   }
}
var UnittestRootdefaultSfixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSfixed64ExtensionStatic
   }
}
var UnittestRootdefaultFloatExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFloatExtensionStatic
   }
}
var UnittestRootdefaultDoubleExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultDoubleExtensionStatic
   }
}
var UnittestRootdefaultBoolExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultBoolExtensionStatic
   }
}
var UnittestRootdefaultStringExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultStringExtensionStatic
   }
}
var UnittestRootdefaultBytesExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultBytesExtensionStatic
   }
}
var UnittestRootdefaultNestedEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultNestedEnumExtensionStatic
   }
}
var UnittestRootdefaultForeignEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultForeignEnumExtensionStatic
   }
}
var UnittestRootdefaultImportEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultImportEnumExtensionStatic
   }
}
var UnittestRootdefaultStringPieceExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultStringPieceExtensionStatic
   }
}
var UnittestRootdefaultCordExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootdefaultCordExtensionStatic
   }
}
var UnittestRootoneofUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoneofUint32ExtensionStatic
   }
}
var UnittestRootoneofNestedMessageExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoneofNestedMessageExtensionStatic
   }
}
var UnittestRootoneofStringExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoneofStringExtensionStatic
   }
}
var UnittestRootoneofBytesExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootoneofBytesExtensionStatic
   }
}
var UnittestRootmyExtensionString:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootmyExtensionStringStatic
   }
}
var UnittestRootmyExtensionInt:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootmyExtensionIntStatic
   }
}
var UnittestRootpackedInt32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedInt32ExtensionStatic
   }
}
var UnittestRootpackedInt64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedInt64ExtensionStatic
   }
}
var UnittestRootpackedUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedUint32ExtensionStatic
   }
}
var UnittestRootpackedUint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedUint64ExtensionStatic
   }
}
var UnittestRootpackedSint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedSint32ExtensionStatic
   }
}
var UnittestRootpackedSint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedSint64ExtensionStatic
   }
}
var UnittestRootpackedFixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedFixed32ExtensionStatic
   }
}
var UnittestRootpackedFixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedFixed64ExtensionStatic
   }
}
var UnittestRootpackedSfixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedSfixed32ExtensionStatic
   }
}
var UnittestRootpackedSfixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedSfixed64ExtensionStatic
   }
}
var UnittestRootpackedFloatExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedFloatExtensionStatic
   }
}
var UnittestRootpackedDoubleExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedDoubleExtensionStatic
   }
}
var UnittestRootpackedBoolExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedBoolExtensionStatic
   }
}
var UnittestRootpackedEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootpackedEnumExtensionStatic
   }
}
var UnittestRootunpackedInt32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedInt32ExtensionStatic
   }
}
var UnittestRootunpackedInt64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedInt64ExtensionStatic
   }
}
var UnittestRootunpackedUint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedUint32ExtensionStatic
   }
}
var UnittestRootunpackedUint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedUint64ExtensionStatic
   }
}
var UnittestRootunpackedSint32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSint32ExtensionStatic
   }
}
var UnittestRootunpackedSint64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSint64ExtensionStatic
   }
}
var UnittestRootunpackedFixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFixed32ExtensionStatic
   }
}
var UnittestRootunpackedFixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFixed64ExtensionStatic
   }
}
var UnittestRootunpackedSfixed32Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSfixed32ExtensionStatic
   }
}
var UnittestRootunpackedSfixed64Extension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSfixed64ExtensionStatic
   }
}
var UnittestRootunpackedFloatExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFloatExtensionStatic
   }
}
var UnittestRootunpackedDoubleExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedDoubleExtensionStatic
   }
}
var UnittestRootunpackedBoolExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedBoolExtensionStatic
   }
}
var UnittestRootunpackedEnumExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.UnittestRootunpackedEnumExtensionStatic
   }
}
var TestNestedExtensiontest:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestNestedExtensiontestStatic
   }
}
var TestNestedExtensionnestedStringExtension:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestNestedExtensionnestedStringExtensionStatic
   }
}
var TestRequiredsingle:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestRequiredsingleStatic
   }
}
var TestRequiredmulti:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestRequiredmultiStatic
   }
}
var TestParsingMergeoptionalExt:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestParsingMergeoptionalExtStatic
   }
}
var TestParsingMergerepeatedExt:ConcreateExtensionField {
   get {
       return UnittestRoot.sharedInstance.TestParsingMergerepeatedExtStatic
   }
}
struct UnittestRoot {
  static var sharedInstance : UnittestRoot {
   struct Static {
       static let instance : UnittestRoot = UnittestRoot()
   }
   return Static.instance
  }
  var UnittestRootoptionalInt32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalInt64ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalUint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalSint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalSint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalFixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalFixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalSfixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalSfixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalFloatExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalDoubleExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalBoolExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalStringExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalBytesExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalGroupExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalNestedMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalForeignMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalImportMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalNestedEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalForeignEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalImportEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalStringPieceExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalCordExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalPublicImportMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootoptionalLazyMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedInt32ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedInt64ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedUint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedSint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedSint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedFixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedFixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedSfixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedSfixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedFloatExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedDoubleExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedBoolExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedStringExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedBytesExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedGroupExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedNestedMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedForeignMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedImportMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedNestedEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedForeignEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedImportEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedStringPieceExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedCordExtensionStatic:ConcreateExtensionField
  var UnittestRootrepeatedLazyMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultInt32ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultInt64ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultUint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultSint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultSint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultFixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultFixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultSfixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultSfixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultFloatExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultDoubleExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultBoolExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultStringExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultBytesExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultNestedEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultForeignEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultImportEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultStringPieceExtensionStatic:ConcreateExtensionField
  var UnittestRootdefaultCordExtensionStatic:ConcreateExtensionField
  var UnittestRootoneofUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootoneofNestedMessageExtensionStatic:ConcreateExtensionField
  var UnittestRootoneofStringExtensionStatic:ConcreateExtensionField
  var UnittestRootoneofBytesExtensionStatic:ConcreateExtensionField
  var UnittestRootmyExtensionStringStatic:ConcreateExtensionField
  var UnittestRootmyExtensionIntStatic:ConcreateExtensionField
  var UnittestRootpackedInt32ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedInt64ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedUint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedSint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedSint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedFixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedFixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedSfixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedSfixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedFloatExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedDoubleExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedBoolExtensionStatic:ConcreateExtensionField
  var UnittestRootpackedEnumExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedInt32ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedInt64ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedUint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedUint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedSint32ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedSint64ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedFixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedFixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedSfixed32ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedSfixed64ExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedFloatExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedDoubleExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedBoolExtensionStatic:ConcreateExtensionField
  var UnittestRootunpackedEnumExtensionStatic:ConcreateExtensionField
  var TestNestedExtensiontestStatic:ConcreateExtensionField
  var TestNestedExtensionnestedStringExtensionStatic:ConcreateExtensionField
  var TestRequiredsingleStatic:ConcreateExtensionField
  var TestRequiredmultiStatic:ConcreateExtensionField
  var TestParsingMergeoptionalExtStatic:ConcreateExtensionField
  var TestParsingMergerepeatedExtStatic:ConcreateExtensionField
  var extensionRegistry:ExtensionRegistry

  init() {
    UnittestRootoptionalInt32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestAllExtensions.self, fieldNumber: 1, defaultValue:Int32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalInt64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt64, extendedClass:TestAllExtensions.self, fieldNumber: 2, defaultValue:Int64(0), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestAllExtensions.self, fieldNumber: 3, defaultValue:UInt32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalUint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt64, extendedClass:TestAllExtensions.self, fieldNumber: 4, defaultValue:UInt64(0), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalSint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt32, extendedClass:TestAllExtensions.self, fieldNumber: 5, defaultValue:Int32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalSint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt64, extendedClass:TestAllExtensions.self, fieldNumber: 6, defaultValue:Int64(0), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalFixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 7, defaultValue:UInt32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalFixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 8, defaultValue:UInt64(0), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalSfixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 9, defaultValue:Int32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalSfixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 10, defaultValue:Int64(0), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalFloatExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFloat, extendedClass:TestAllExtensions.self, fieldNumber: 11, defaultValue:Float(0), messageOrGroupClass:Float.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalDoubleExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeDouble, extendedClass:TestAllExtensions.self, fieldNumber: 12, defaultValue:Double(0), messageOrGroupClass:Double.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalBoolExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBool, extendedClass:TestAllExtensions.self, fieldNumber: 13, defaultValue:false, messageOrGroupClass:Bool.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalStringExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 14, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalBytesExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBytes, extendedClass:TestAllExtensions.self, fieldNumber: 15, defaultValue:[Byte](), messageOrGroupClass:[Byte].self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalGroupExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeGroup, extendedClass:TestAllExtensions.self, fieldNumber: 16, defaultValue:OptionalGroup_extension(), messageOrGroupClass:OptionalGroup_extension.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalNestedMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 18, defaultValue:TestAllTypes.NestedMessage(), messageOrGroupClass:TestAllTypes.NestedMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalForeignMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 19, defaultValue:ForeignMessage(), messageOrGroupClass:ForeignMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalImportMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 20, defaultValue:ImportMessage(), messageOrGroupClass:ImportMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalNestedEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 21, defaultValue:TestAllTypes.NestedEnum.Foo.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalForeignEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 22, defaultValue:ForeignEnum.ForeignFoo.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalImportEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 23, defaultValue:ImportEnum.ImportFoo.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalStringPieceExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 24, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalCordExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 25, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalPublicImportMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 26, defaultValue:PublicImportMessage(), messageOrGroupClass:PublicImportMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoptionalLazyMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 27, defaultValue:TestAllTypes.NestedMessage(), messageOrGroupClass:TestAllTypes.NestedMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedInt32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestAllExtensions.self, fieldNumber: 31, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedInt64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt64, extendedClass:TestAllExtensions.self, fieldNumber: 32, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestAllExtensions.self, fieldNumber: 33, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedUint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt64, extendedClass:TestAllExtensions.self, fieldNumber: 34, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedSint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt32, extendedClass:TestAllExtensions.self, fieldNumber: 35, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedSint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt64, extendedClass:TestAllExtensions.self, fieldNumber: 36, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedFixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 37, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedFixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 38, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedSfixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 39, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedSfixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 40, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedFloatExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFloat, extendedClass:TestAllExtensions.self, fieldNumber: 41, defaultValue:Array<Float>(), messageOrGroupClass:Float.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedDoubleExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeDouble, extendedClass:TestAllExtensions.self, fieldNumber: 42, defaultValue:Array<Double>(), messageOrGroupClass:Double.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedBoolExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBool, extendedClass:TestAllExtensions.self, fieldNumber: 43, defaultValue:Array<Bool>(), messageOrGroupClass:Bool.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedStringExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 44, defaultValue:Array<String>(), messageOrGroupClass:String.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedBytesExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBytes, extendedClass:TestAllExtensions.self, fieldNumber: 45, defaultValue:Array<[Byte]>(), messageOrGroupClass:[Byte].self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedGroupExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeGroup, extendedClass:TestAllExtensions.self, fieldNumber: 46, defaultValue:Array<RepeatedGroup_extension>(), messageOrGroupClass:RepeatedGroup_extension.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedNestedMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 48, defaultValue:Array<TestAllTypes.NestedMessage>(), messageOrGroupClass:TestAllTypes.NestedMessage.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedForeignMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 49, defaultValue:Array<ForeignMessage>(), messageOrGroupClass:ForeignMessage.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedImportMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 50, defaultValue:Array<ImportMessage>(), messageOrGroupClass:ImportMessage.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedNestedEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 51, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedForeignEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 52, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedImportEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 53, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedStringPieceExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 54, defaultValue:Array<String>(), messageOrGroupClass:String.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedCordExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 55, defaultValue:Array<String>(), messageOrGroupClass:String.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootrepeatedLazyMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 57, defaultValue:Array<TestAllTypes.NestedMessage>(), messageOrGroupClass:TestAllTypes.NestedMessage.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultInt32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestAllExtensions.self, fieldNumber: 61, defaultValue:Int32(41), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultInt64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt64, extendedClass:TestAllExtensions.self, fieldNumber: 62, defaultValue:Int64(42), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestAllExtensions.self, fieldNumber: 63, defaultValue:UInt32(43), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultUint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt64, extendedClass:TestAllExtensions.self, fieldNumber: 64, defaultValue:UInt64(44), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultSint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt32, extendedClass:TestAllExtensions.self, fieldNumber: 65, defaultValue:Int32(-45), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultSint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt64, extendedClass:TestAllExtensions.self, fieldNumber: 66, defaultValue:Int64(46), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultFixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 67, defaultValue:UInt32(47), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultFixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 68, defaultValue:UInt64(48), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultSfixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed32, extendedClass:TestAllExtensions.self, fieldNumber: 69, defaultValue:Int32(49), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultSfixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed64, extendedClass:TestAllExtensions.self, fieldNumber: 70, defaultValue:Int64(-50), messageOrGroupClass:Int64.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultFloatExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFloat, extendedClass:TestAllExtensions.self, fieldNumber: 71, defaultValue:Float(51.5), messageOrGroupClass:Float.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultDoubleExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeDouble, extendedClass:TestAllExtensions.self, fieldNumber: 72, defaultValue:Double(52000), messageOrGroupClass:Double.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultBoolExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBool, extendedClass:TestAllExtensions.self, fieldNumber: 73, defaultValue:true, messageOrGroupClass:Bool.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultStringExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 74, defaultValue:"hello", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultBytesExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBytes, extendedClass:TestAllExtensions.self, fieldNumber: 75, defaultValue:([Byte]() + "world".utf8), messageOrGroupClass:[Byte].self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultNestedEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 81, defaultValue:TestAllTypes.NestedEnum.Bar.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultForeignEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 82, defaultValue:ForeignEnum.ForeignBar.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultImportEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestAllExtensions.self, fieldNumber: 83, defaultValue:ImportEnum.ImportBar.rawValue, messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultStringPieceExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 84, defaultValue:"abc", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootdefaultCordExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 85, defaultValue:"123", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoneofUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestAllExtensions.self, fieldNumber: 111, defaultValue:UInt32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoneofNestedMessageExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 112, defaultValue:TestAllTypes.NestedMessage(), messageOrGroupClass:TestAllTypes.NestedMessage.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoneofStringExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 113, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootoneofBytesExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBytes, extendedClass:TestAllExtensions.self, fieldNumber: 114, defaultValue:[Byte](), messageOrGroupClass:[Byte].self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootmyExtensionStringStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestFieldOrderings.self, fieldNumber: 50, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootmyExtensionIntStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestFieldOrderings.self, fieldNumber: 5, defaultValue:Int32(0), messageOrGroupClass:Int32.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootpackedInt32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestPackedExtensions.self, fieldNumber: 90, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedInt64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt64, extendedClass:TestPackedExtensions.self, fieldNumber: 91, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestPackedExtensions.self, fieldNumber: 92, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedUint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt64, extendedClass:TestPackedExtensions.self, fieldNumber: 93, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedSint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt32, extendedClass:TestPackedExtensions.self, fieldNumber: 94, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedSint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt64, extendedClass:TestPackedExtensions.self, fieldNumber: 95, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedFixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed32, extendedClass:TestPackedExtensions.self, fieldNumber: 96, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedFixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed64, extendedClass:TestPackedExtensions.self, fieldNumber: 97, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedSfixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed32, extendedClass:TestPackedExtensions.self, fieldNumber: 98, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedSfixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed64, extendedClass:TestPackedExtensions.self, fieldNumber: 99, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedFloatExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFloat, extendedClass:TestPackedExtensions.self, fieldNumber: 100, defaultValue:Array<Float>(), messageOrGroupClass:Float.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedDoubleExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeDouble, extendedClass:TestPackedExtensions.self, fieldNumber: 101, defaultValue:Array<Double>(), messageOrGroupClass:Double.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedBoolExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBool, extendedClass:TestPackedExtensions.self, fieldNumber: 102, defaultValue:Array<Bool>(), messageOrGroupClass:Bool.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootpackedEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestPackedExtensions.self, fieldNumber: 103, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:true, isMessageSetWireFormat:false)
    UnittestRootunpackedInt32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt32, extendedClass:TestUnpackedExtensions.self, fieldNumber: 90, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedInt64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeInt64, extendedClass:TestUnpackedExtensions.self, fieldNumber: 91, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedUint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt32, extendedClass:TestUnpackedExtensions.self, fieldNumber: 92, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedUint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeUInt64, extendedClass:TestUnpackedExtensions.self, fieldNumber: 93, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedSint32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt32, extendedClass:TestUnpackedExtensions.self, fieldNumber: 94, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedSint64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSInt64, extendedClass:TestUnpackedExtensions.self, fieldNumber: 95, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedFixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed32, extendedClass:TestUnpackedExtensions.self, fieldNumber: 96, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedFixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFixed64, extendedClass:TestUnpackedExtensions.self, fieldNumber: 97, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedSfixed32ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed32, extendedClass:TestUnpackedExtensions.self, fieldNumber: 98, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedSfixed64ExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeSFixed64, extendedClass:TestUnpackedExtensions.self, fieldNumber: 99, defaultValue:Array<Int64>(), messageOrGroupClass:Int64.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedFloatExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeFloat, extendedClass:TestUnpackedExtensions.self, fieldNumber: 100, defaultValue:Array<Float>(), messageOrGroupClass:Float.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedDoubleExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeDouble, extendedClass:TestUnpackedExtensions.self, fieldNumber: 101, defaultValue:Array<Double>(), messageOrGroupClass:Double.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedBoolExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeBool, extendedClass:TestUnpackedExtensions.self, fieldNumber: 102, defaultValue:Array<Bool>(), messageOrGroupClass:Bool.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    UnittestRootunpackedEnumExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeEnum, extendedClass:TestUnpackedExtensions.self, fieldNumber: 103, defaultValue:Array<Int32>(), messageOrGroupClass:Int32.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    TestNestedExtensiontestStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 1002, defaultValue:"test", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    TestNestedExtensionnestedStringExtensionStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeString, extendedClass:TestAllExtensions.self, fieldNumber: 1003, defaultValue:"", messageOrGroupClass:String.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    TestRequiredsingleStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 1000, defaultValue:TestRequired(), messageOrGroupClass:TestRequired.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    TestRequiredmultiStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestAllExtensions.self, fieldNumber: 1001, defaultValue:Array<TestRequired>(), messageOrGroupClass:TestRequired.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    TestParsingMergeoptionalExtStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestParsingMerge.self, fieldNumber: 1000, defaultValue:TestAllTypes(), messageOrGroupClass:TestAllTypes.self, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
    TestParsingMergerepeatedExtStatic = ConcreateExtensionField(type:ExtensionType.ExtensionTypeMessage, extendedClass:TestParsingMerge.self, fieldNumber: 1001, defaultValue:Array<TestAllTypes>(), messageOrGroupClass:TestAllTypes.self, isRepeated:true, isPacked:false, isMessageSetWireFormat:false)
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    UnittestImportRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  func registerAllExtensions(registry:ExtensionRegistry) {
    registry.addExtension(UnittestRootoptionalInt32ExtensionStatic)
    registry.addExtension(UnittestRootoptionalInt64ExtensionStatic)
    registry.addExtension(UnittestRootoptionalUint32ExtensionStatic)
    registry.addExtension(UnittestRootoptionalUint64ExtensionStatic)
    registry.addExtension(UnittestRootoptionalSint32ExtensionStatic)
    registry.addExtension(UnittestRootoptionalSint64ExtensionStatic)
    registry.addExtension(UnittestRootoptionalFixed32ExtensionStatic)
    registry.addExtension(UnittestRootoptionalFixed64ExtensionStatic)
    registry.addExtension(UnittestRootoptionalSfixed32ExtensionStatic)
    registry.addExtension(UnittestRootoptionalSfixed64ExtensionStatic)
    registry.addExtension(UnittestRootoptionalFloatExtensionStatic)
    registry.addExtension(UnittestRootoptionalDoubleExtensionStatic)
    registry.addExtension(UnittestRootoptionalBoolExtensionStatic)
    registry.addExtension(UnittestRootoptionalStringExtensionStatic)
    registry.addExtension(UnittestRootoptionalBytesExtensionStatic)
    registry.addExtension(UnittestRootoptionalGroupExtensionStatic)
    registry.addExtension(UnittestRootoptionalNestedMessageExtensionStatic)
    registry.addExtension(UnittestRootoptionalForeignMessageExtensionStatic)
    registry.addExtension(UnittestRootoptionalImportMessageExtensionStatic)
    registry.addExtension(UnittestRootoptionalNestedEnumExtensionStatic)
    registry.addExtension(UnittestRootoptionalForeignEnumExtensionStatic)
    registry.addExtension(UnittestRootoptionalImportEnumExtensionStatic)
    registry.addExtension(UnittestRootoptionalStringPieceExtensionStatic)
    registry.addExtension(UnittestRootoptionalCordExtensionStatic)
    registry.addExtension(UnittestRootoptionalPublicImportMessageExtensionStatic)
    registry.addExtension(UnittestRootoptionalLazyMessageExtensionStatic)
    registry.addExtension(UnittestRootrepeatedInt32ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedInt64ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedUint32ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedUint64ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedSint32ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedSint64ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedFixed32ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedFixed64ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedSfixed32ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedSfixed64ExtensionStatic)
    registry.addExtension(UnittestRootrepeatedFloatExtensionStatic)
    registry.addExtension(UnittestRootrepeatedDoubleExtensionStatic)
    registry.addExtension(UnittestRootrepeatedBoolExtensionStatic)
    registry.addExtension(UnittestRootrepeatedStringExtensionStatic)
    registry.addExtension(UnittestRootrepeatedBytesExtensionStatic)
    registry.addExtension(UnittestRootrepeatedGroupExtensionStatic)
    registry.addExtension(UnittestRootrepeatedNestedMessageExtensionStatic)
    registry.addExtension(UnittestRootrepeatedForeignMessageExtensionStatic)
    registry.addExtension(UnittestRootrepeatedImportMessageExtensionStatic)
    registry.addExtension(UnittestRootrepeatedNestedEnumExtensionStatic)
    registry.addExtension(UnittestRootrepeatedForeignEnumExtensionStatic)
    registry.addExtension(UnittestRootrepeatedImportEnumExtensionStatic)
    registry.addExtension(UnittestRootrepeatedStringPieceExtensionStatic)
    registry.addExtension(UnittestRootrepeatedCordExtensionStatic)
    registry.addExtension(UnittestRootrepeatedLazyMessageExtensionStatic)
    registry.addExtension(UnittestRootdefaultInt32ExtensionStatic)
    registry.addExtension(UnittestRootdefaultInt64ExtensionStatic)
    registry.addExtension(UnittestRootdefaultUint32ExtensionStatic)
    registry.addExtension(UnittestRootdefaultUint64ExtensionStatic)
    registry.addExtension(UnittestRootdefaultSint32ExtensionStatic)
    registry.addExtension(UnittestRootdefaultSint64ExtensionStatic)
    registry.addExtension(UnittestRootdefaultFixed32ExtensionStatic)
    registry.addExtension(UnittestRootdefaultFixed64ExtensionStatic)
    registry.addExtension(UnittestRootdefaultSfixed32ExtensionStatic)
    registry.addExtension(UnittestRootdefaultSfixed64ExtensionStatic)
    registry.addExtension(UnittestRootdefaultFloatExtensionStatic)
    registry.addExtension(UnittestRootdefaultDoubleExtensionStatic)
    registry.addExtension(UnittestRootdefaultBoolExtensionStatic)
    registry.addExtension(UnittestRootdefaultStringExtensionStatic)
    registry.addExtension(UnittestRootdefaultBytesExtensionStatic)
    registry.addExtension(UnittestRootdefaultNestedEnumExtensionStatic)
    registry.addExtension(UnittestRootdefaultForeignEnumExtensionStatic)
    registry.addExtension(UnittestRootdefaultImportEnumExtensionStatic)
    registry.addExtension(UnittestRootdefaultStringPieceExtensionStatic)
    registry.addExtension(UnittestRootdefaultCordExtensionStatic)
    registry.addExtension(UnittestRootoneofUint32ExtensionStatic)
    registry.addExtension(UnittestRootoneofNestedMessageExtensionStatic)
    registry.addExtension(UnittestRootoneofStringExtensionStatic)
    registry.addExtension(UnittestRootoneofBytesExtensionStatic)
    registry.addExtension(UnittestRootmyExtensionStringStatic)
    registry.addExtension(UnittestRootmyExtensionIntStatic)
    registry.addExtension(UnittestRootpackedInt32ExtensionStatic)
    registry.addExtension(UnittestRootpackedInt64ExtensionStatic)
    registry.addExtension(UnittestRootpackedUint32ExtensionStatic)
    registry.addExtension(UnittestRootpackedUint64ExtensionStatic)
    registry.addExtension(UnittestRootpackedSint32ExtensionStatic)
    registry.addExtension(UnittestRootpackedSint64ExtensionStatic)
    registry.addExtension(UnittestRootpackedFixed32ExtensionStatic)
    registry.addExtension(UnittestRootpackedFixed64ExtensionStatic)
    registry.addExtension(UnittestRootpackedSfixed32ExtensionStatic)
    registry.addExtension(UnittestRootpackedSfixed64ExtensionStatic)
    registry.addExtension(UnittestRootpackedFloatExtensionStatic)
    registry.addExtension(UnittestRootpackedDoubleExtensionStatic)
    registry.addExtension(UnittestRootpackedBoolExtensionStatic)
    registry.addExtension(UnittestRootpackedEnumExtensionStatic)
    registry.addExtension(UnittestRootunpackedInt32ExtensionStatic)
    registry.addExtension(UnittestRootunpackedInt64ExtensionStatic)
    registry.addExtension(UnittestRootunpackedUint32ExtensionStatic)
    registry.addExtension(UnittestRootunpackedUint64ExtensionStatic)
    registry.addExtension(UnittestRootunpackedSint32ExtensionStatic)
    registry.addExtension(UnittestRootunpackedSint64ExtensionStatic)
    registry.addExtension(UnittestRootunpackedFixed32ExtensionStatic)
    registry.addExtension(UnittestRootunpackedFixed64ExtensionStatic)
    registry.addExtension(UnittestRootunpackedSfixed32ExtensionStatic)
    registry.addExtension(UnittestRootunpackedSfixed64ExtensionStatic)
    registry.addExtension(UnittestRootunpackedFloatExtensionStatic)
    registry.addExtension(UnittestRootunpackedDoubleExtensionStatic)
    registry.addExtension(UnittestRootunpackedBoolExtensionStatic)
    registry.addExtension(UnittestRootunpackedEnumExtensionStatic)
    registry.addExtension(TestNestedExtensiontestStatic)
    registry.addExtension(TestNestedExtensionnestedStringExtensionStatic)
    registry.addExtension(TestRequiredsingleStatic)
    registry.addExtension(TestRequiredmultiStatic)
    registry.addExtension(TestParsingMergeoptionalExtStatic)
    registry.addExtension(TestParsingMergerepeatedExtStatic)
  }
  static func optionalInt32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalInt32ExtensionStatic
  }
  static func optionalInt64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalInt64ExtensionStatic
  }
  static func optionalUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalUint32ExtensionStatic
  }
  static func optionalUint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalUint64ExtensionStatic
  }
  static func optionalSint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSint32ExtensionStatic
  }
  static func optionalSint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSint64ExtensionStatic
  }
  static func optionalFixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFixed32ExtensionStatic
  }
  static func optionalFixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFixed64ExtensionStatic
  }
  static func optionalSfixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSfixed32ExtensionStatic
  }
  static func optionalSfixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalSfixed64ExtensionStatic
  }
  static func optionalFloatExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalFloatExtensionStatic
  }
  static func optionalDoubleExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalDoubleExtensionStatic
  }
  static func optionalBoolExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalBoolExtensionStatic
  }
  static func optionalStringExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalStringExtensionStatic
  }
  static func optionalBytesExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalBytesExtensionStatic
  }
  static func optionalGroupExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalGroupExtensionStatic
  }
  static func optionalNestedMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalNestedMessageExtensionStatic
  }
  static func optionalForeignMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalForeignMessageExtensionStatic
  }
  static func optionalImportMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalImportMessageExtensionStatic
  }
  static func optionalNestedEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalNestedEnumExtensionStatic
  }
  static func optionalForeignEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalForeignEnumExtensionStatic
  }
  static func optionalImportEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalImportEnumExtensionStatic
  }
  static func optionalStringPieceExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalStringPieceExtensionStatic
  }
  static func optionalCordExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalCordExtensionStatic
  }
  static func optionalPublicImportMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalPublicImportMessageExtensionStatic
  }
  static func optionalLazyMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoptionalLazyMessageExtensionStatic
  }
  static func repeatedInt32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedInt32ExtensionStatic
  }
  static func repeatedInt64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedInt64ExtensionStatic
  }
  static func repeatedUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedUint32ExtensionStatic
  }
  static func repeatedUint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedUint64ExtensionStatic
  }
  static func repeatedSint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSint32ExtensionStatic
  }
  static func repeatedSint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSint64ExtensionStatic
  }
  static func repeatedFixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFixed32ExtensionStatic
  }
  static func repeatedFixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFixed64ExtensionStatic
  }
  static func repeatedSfixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSfixed32ExtensionStatic
  }
  static func repeatedSfixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedSfixed64ExtensionStatic
  }
  static func repeatedFloatExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedFloatExtensionStatic
  }
  static func repeatedDoubleExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedDoubleExtensionStatic
  }
  static func repeatedBoolExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedBoolExtensionStatic
  }
  static func repeatedStringExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedStringExtensionStatic
  }
  static func repeatedBytesExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedBytesExtensionStatic
  }
  static func repeatedGroupExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedGroupExtensionStatic
  }
  static func repeatedNestedMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedNestedMessageExtensionStatic
  }
  static func repeatedForeignMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedForeignMessageExtensionStatic
  }
  static func repeatedImportMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedImportMessageExtensionStatic
  }
  static func repeatedNestedEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedNestedEnumExtensionStatic
  }
  static func repeatedForeignEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedForeignEnumExtensionStatic
  }
  static func repeatedImportEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedImportEnumExtensionStatic
  }
  static func repeatedStringPieceExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedStringPieceExtensionStatic
  }
  static func repeatedCordExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedCordExtensionStatic
  }
  static func repeatedLazyMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootrepeatedLazyMessageExtensionStatic
  }
  static func defaultInt32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultInt32ExtensionStatic
  }
  static func defaultInt64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultInt64ExtensionStatic
  }
  static func defaultUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultUint32ExtensionStatic
  }
  static func defaultUint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultUint64ExtensionStatic
  }
  static func defaultSint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSint32ExtensionStatic
  }
  static func defaultSint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSint64ExtensionStatic
  }
  static func defaultFixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFixed32ExtensionStatic
  }
  static func defaultFixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFixed64ExtensionStatic
  }
  static func defaultSfixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSfixed32ExtensionStatic
  }
  static func defaultSfixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultSfixed64ExtensionStatic
  }
  static func defaultFloatExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultFloatExtensionStatic
  }
  static func defaultDoubleExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultDoubleExtensionStatic
  }
  static func defaultBoolExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultBoolExtensionStatic
  }
  static func defaultStringExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultStringExtensionStatic
  }
  static func defaultBytesExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultBytesExtensionStatic
  }
  static func defaultNestedEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultNestedEnumExtensionStatic
  }
  static func defaultForeignEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultForeignEnumExtensionStatic
  }
  static func defaultImportEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultImportEnumExtensionStatic
  }
  static func defaultStringPieceExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultStringPieceExtensionStatic
  }
  static func defaultCordExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootdefaultCordExtensionStatic
  }
  static func oneofUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoneofUint32ExtensionStatic
  }
  static func oneofNestedMessageExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoneofNestedMessageExtensionStatic
  }
  static func oneofStringExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoneofStringExtensionStatic
  }
  static func oneofBytesExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootoneofBytesExtensionStatic
  }
  static func myExtensionString() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootmyExtensionStringStatic
  }
  static func myExtensionInt() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootmyExtensionIntStatic
  }
  static func packedInt32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedInt32ExtensionStatic
  }
  static func packedInt64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedInt64ExtensionStatic
  }
  static func packedUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedUint32ExtensionStatic
  }
  static func packedUint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedUint64ExtensionStatic
  }
  static func packedSint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedSint32ExtensionStatic
  }
  static func packedSint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedSint64ExtensionStatic
  }
  static func packedFixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedFixed32ExtensionStatic
  }
  static func packedFixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedFixed64ExtensionStatic
  }
  static func packedSfixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedSfixed32ExtensionStatic
  }
  static func packedSfixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedSfixed64ExtensionStatic
  }
  static func packedFloatExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedFloatExtensionStatic
  }
  static func packedDoubleExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedDoubleExtensionStatic
  }
  static func packedBoolExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedBoolExtensionStatic
  }
  static func packedEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootpackedEnumExtensionStatic
  }
  static func unpackedInt32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedInt32ExtensionStatic
  }
  static func unpackedInt64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedInt64ExtensionStatic
  }
  static func unpackedUint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedUint32ExtensionStatic
  }
  static func unpackedUint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedUint64ExtensionStatic
  }
  static func unpackedSint32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSint32ExtensionStatic
  }
  static func unpackedSint64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSint64ExtensionStatic
  }
  static func unpackedFixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFixed32ExtensionStatic
  }
  static func unpackedFixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFixed64ExtensionStatic
  }
  static func unpackedSfixed32Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSfixed32ExtensionStatic
  }
  static func unpackedSfixed64Extension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedSfixed64ExtensionStatic
  }
  static func unpackedFloatExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedFloatExtensionStatic
  }
  static func unpackedDoubleExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedDoubleExtensionStatic
  }
  static func unpackedBoolExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedBoolExtensionStatic
  }
  static func unpackedEnumExtension() -> ConcreateExtensionField {
       return UnittestRoot.sharedInstance.UnittestRootunpackedEnumExtensionStatic
  }
}



//Enum type declaration start 

enum ForeignEnum:Int32 {
  case ForeignFoo = 4
  case ForeignBar = 5
  case ForeignBaz = 6

  static func IsValidValue(value:ForeignEnum) ->Bool {
    switch value {
      case .ForeignFoo, .ForeignBar, .ForeignBaz:
        return true;
      default:
        return false;
    }
  }
}



//Enum type declaration end 



//Enum type declaration start 

enum TestEnumWithDupValue:Int32 {
  case Foo1 = 1
  case Bar1 = 2
  case Baz = 3

  static func IsValidValue(value:TestEnumWithDupValue) ->Bool {
    switch value {
      case .Foo1, .Bar1, .Baz:
        return true;
      default:
        return false;
    }
  }
}



//Enum type declaration end 



//Enum type declaration start 

enum TestSparseEnum:Int32 {
  case SparseA = 123
  case SparseB = 62374
  case SparseC = 12589234
  case SparseD = -15
  case SparseE = -53452
  case SparseF = 0
  case SparseG = 2

  static func IsValidValue(value:TestSparseEnum) ->Bool {
    switch value {
      case .SparseA, .SparseB, .SparseC, .SparseD, .SparseE, .SparseF, .SparseG:
        return true;
      default:
        return false;
    }
  }
}



//Enum type declaration end 

func == (lhs: TestAllTypes.NestedMessage, rhs: TestAllTypes.NestedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBb == rhs.hasBb) && (!lhs.hasBb || lhs.bb == rhs.bb)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestAllTypes.OptionalGroup, rhs: TestAllTypes.OptionalGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestAllTypes.RepeatedGroup, rhs: TestAllTypes.RepeatedGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestAllTypes, rhs: TestAllTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOptionalInt32 == rhs.hasOptionalInt32) && (!lhs.hasOptionalInt32 || lhs.optionalInt32 == rhs.optionalInt32)
  fieldCheck = fieldCheck && (lhs.hasOptionalInt64 == rhs.hasOptionalInt64) && (!lhs.hasOptionalInt64 || lhs.optionalInt64 == rhs.optionalInt64)
  fieldCheck = fieldCheck && (lhs.hasOptionalUint32 == rhs.hasOptionalUint32) && (!lhs.hasOptionalUint32 || lhs.optionalUint32 == rhs.optionalUint32)
  fieldCheck = fieldCheck && (lhs.hasOptionalUint64 == rhs.hasOptionalUint64) && (!lhs.hasOptionalUint64 || lhs.optionalUint64 == rhs.optionalUint64)
  fieldCheck = fieldCheck && (lhs.hasOptionalSint32 == rhs.hasOptionalSint32) && (!lhs.hasOptionalSint32 || lhs.optionalSint32 == rhs.optionalSint32)
  fieldCheck = fieldCheck && (lhs.hasOptionalSint64 == rhs.hasOptionalSint64) && (!lhs.hasOptionalSint64 || lhs.optionalSint64 == rhs.optionalSint64)
  fieldCheck = fieldCheck && (lhs.hasOptionalFixed32 == rhs.hasOptionalFixed32) && (!lhs.hasOptionalFixed32 || lhs.optionalFixed32 == rhs.optionalFixed32)
  fieldCheck = fieldCheck && (lhs.hasOptionalFixed64 == rhs.hasOptionalFixed64) && (!lhs.hasOptionalFixed64 || lhs.optionalFixed64 == rhs.optionalFixed64)
  fieldCheck = fieldCheck && (lhs.hasOptionalSfixed32 == rhs.hasOptionalSfixed32) && (!lhs.hasOptionalSfixed32 || lhs.optionalSfixed32 == rhs.optionalSfixed32)
  fieldCheck = fieldCheck && (lhs.hasOptionalSfixed64 == rhs.hasOptionalSfixed64) && (!lhs.hasOptionalSfixed64 || lhs.optionalSfixed64 == rhs.optionalSfixed64)
  fieldCheck = fieldCheck && (lhs.hasOptionalFloat == rhs.hasOptionalFloat) && (!lhs.hasOptionalFloat || lhs.optionalFloat == rhs.optionalFloat)
  fieldCheck = fieldCheck && (lhs.hasOptionalDouble == rhs.hasOptionalDouble) && (!lhs.hasOptionalDouble || lhs.optionalDouble == rhs.optionalDouble)
  fieldCheck = fieldCheck && (lhs.hasOptionalBool == rhs.hasOptionalBool) && (!lhs.hasOptionalBool || lhs.optionalBool == rhs.optionalBool)
  fieldCheck = fieldCheck && (lhs.hasOptionalString == rhs.hasOptionalString) && (!lhs.hasOptionalString || lhs.optionalString == rhs.optionalString)
  fieldCheck = fieldCheck && (lhs.hasOptionalBytes == rhs.hasOptionalBytes) && (!lhs.hasOptionalBytes || lhs.optionalBytes == rhs.optionalBytes)
  fieldCheck = fieldCheck && (lhs.hasOptionalGroup == rhs.hasOptionalGroup) && (!lhs.hasOptionalGroup || lhs.optionalGroup == rhs.optionalGroup)
  fieldCheck = fieldCheck && (lhs.hasOptionalNestedMessage == rhs.hasOptionalNestedMessage) && (!lhs.hasOptionalNestedMessage || lhs.optionalNestedMessage == rhs.optionalNestedMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalForeignMessage == rhs.hasOptionalForeignMessage) && (!lhs.hasOptionalForeignMessage || lhs.optionalForeignMessage == rhs.optionalForeignMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalImportMessage == rhs.hasOptionalImportMessage) && (!lhs.hasOptionalImportMessage || lhs.optionalImportMessage == rhs.optionalImportMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalNestedEnum == rhs.hasOptionalNestedEnum) && (!lhs.hasOptionalNestedEnum || lhs.optionalNestedEnum == rhs.optionalNestedEnum)
  fieldCheck = fieldCheck && (lhs.hasOptionalForeignEnum == rhs.hasOptionalForeignEnum) && (!lhs.hasOptionalForeignEnum || lhs.optionalForeignEnum == rhs.optionalForeignEnum)
  fieldCheck = fieldCheck && (lhs.hasOptionalImportEnum == rhs.hasOptionalImportEnum) && (!lhs.hasOptionalImportEnum || lhs.optionalImportEnum == rhs.optionalImportEnum)
  fieldCheck = fieldCheck && (lhs.hasOptionalStringPiece == rhs.hasOptionalStringPiece) && (!lhs.hasOptionalStringPiece || lhs.optionalStringPiece == rhs.optionalStringPiece)
  fieldCheck = fieldCheck && (lhs.hasOptionalCord == rhs.hasOptionalCord) && (!lhs.hasOptionalCord || lhs.optionalCord == rhs.optionalCord)
  fieldCheck = fieldCheck && (lhs.hasOptionalPublicImportMessage == rhs.hasOptionalPublicImportMessage) && (!lhs.hasOptionalPublicImportMessage || lhs.optionalPublicImportMessage == rhs.optionalPublicImportMessage)
  fieldCheck = fieldCheck && (lhs.hasOptionalLazyMessage == rhs.hasOptionalLazyMessage) && (!lhs.hasOptionalLazyMessage || lhs.optionalLazyMessage == rhs.optionalLazyMessage)
  fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
  fieldCheck = fieldCheck && (lhs.repeatedInt64 == rhs.repeatedInt64)
  fieldCheck = fieldCheck && (lhs.repeatedUint32 == rhs.repeatedUint32)
  fieldCheck = fieldCheck && (lhs.repeatedUint64 == rhs.repeatedUint64)
  fieldCheck = fieldCheck && (lhs.repeatedSint32 == rhs.repeatedSint32)
  fieldCheck = fieldCheck && (lhs.repeatedSint64 == rhs.repeatedSint64)
  fieldCheck = fieldCheck && (lhs.repeatedFixed32 == rhs.repeatedFixed32)
  fieldCheck = fieldCheck && (lhs.repeatedFixed64 == rhs.repeatedFixed64)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed32 == rhs.repeatedSfixed32)
  fieldCheck = fieldCheck && (lhs.repeatedSfixed64 == rhs.repeatedSfixed64)
  fieldCheck = fieldCheck && (lhs.repeatedFloat == rhs.repeatedFloat)
  fieldCheck = fieldCheck && (lhs.repeatedDouble == rhs.repeatedDouble)
  fieldCheck = fieldCheck && (lhs.repeatedBool == rhs.repeatedBool)
  fieldCheck = fieldCheck && (lhs.repeatedString == rhs.repeatedString)
  fieldCheck = fieldCheck && (lhs.repeatedBytes == rhs.repeatedBytes)
  fieldCheck = fieldCheck && (lhs.repeatedGroup == rhs.repeatedGroup)
  fieldCheck = fieldCheck && (lhs.repeatedNestedMessage == rhs.repeatedNestedMessage)
  fieldCheck = fieldCheck && (lhs.repeatedForeignMessage == rhs.repeatedForeignMessage)
  fieldCheck = fieldCheck && (lhs.repeatedImportMessage == rhs.repeatedImportMessage)
  fieldCheck = fieldCheck && (lhs.repeatedNestedEnum == rhs.repeatedNestedEnum)
  fieldCheck = fieldCheck && (lhs.repeatedForeignEnum == rhs.repeatedForeignEnum)
  fieldCheck = fieldCheck && (lhs.repeatedImportEnum == rhs.repeatedImportEnum)
  fieldCheck = fieldCheck && (lhs.repeatedStringPiece == rhs.repeatedStringPiece)
  fieldCheck = fieldCheck && (lhs.repeatedCord == rhs.repeatedCord)
  fieldCheck = fieldCheck && (lhs.repeatedLazyMessage == rhs.repeatedLazyMessage)
  fieldCheck = fieldCheck && (lhs.hasDefaultInt32 == rhs.hasDefaultInt32) && (!lhs.hasDefaultInt32 || lhs.defaultInt32 == rhs.defaultInt32)
  fieldCheck = fieldCheck && (lhs.hasDefaultInt64 == rhs.hasDefaultInt64) && (!lhs.hasDefaultInt64 || lhs.defaultInt64 == rhs.defaultInt64)
  fieldCheck = fieldCheck && (lhs.hasDefaultUint32 == rhs.hasDefaultUint32) && (!lhs.hasDefaultUint32 || lhs.defaultUint32 == rhs.defaultUint32)
  fieldCheck = fieldCheck && (lhs.hasDefaultUint64 == rhs.hasDefaultUint64) && (!lhs.hasDefaultUint64 || lhs.defaultUint64 == rhs.defaultUint64)
  fieldCheck = fieldCheck && (lhs.hasDefaultSint32 == rhs.hasDefaultSint32) && (!lhs.hasDefaultSint32 || lhs.defaultSint32 == rhs.defaultSint32)
  fieldCheck = fieldCheck && (lhs.hasDefaultSint64 == rhs.hasDefaultSint64) && (!lhs.hasDefaultSint64 || lhs.defaultSint64 == rhs.defaultSint64)
  fieldCheck = fieldCheck && (lhs.hasDefaultFixed32 == rhs.hasDefaultFixed32) && (!lhs.hasDefaultFixed32 || lhs.defaultFixed32 == rhs.defaultFixed32)
  fieldCheck = fieldCheck && (lhs.hasDefaultFixed64 == rhs.hasDefaultFixed64) && (!lhs.hasDefaultFixed64 || lhs.defaultFixed64 == rhs.defaultFixed64)
  fieldCheck = fieldCheck && (lhs.hasDefaultSfixed32 == rhs.hasDefaultSfixed32) && (!lhs.hasDefaultSfixed32 || lhs.defaultSfixed32 == rhs.defaultSfixed32)
  fieldCheck = fieldCheck && (lhs.hasDefaultSfixed64 == rhs.hasDefaultSfixed64) && (!lhs.hasDefaultSfixed64 || lhs.defaultSfixed64 == rhs.defaultSfixed64)
  fieldCheck = fieldCheck && (lhs.hasDefaultFloat == rhs.hasDefaultFloat) && (!lhs.hasDefaultFloat || lhs.defaultFloat == rhs.defaultFloat)
  fieldCheck = fieldCheck && (lhs.hasDefaultDouble == rhs.hasDefaultDouble) && (!lhs.hasDefaultDouble || lhs.defaultDouble == rhs.defaultDouble)
  fieldCheck = fieldCheck && (lhs.hasDefaultBool == rhs.hasDefaultBool) && (!lhs.hasDefaultBool || lhs.defaultBool == rhs.defaultBool)
  fieldCheck = fieldCheck && (lhs.hasDefaultString == rhs.hasDefaultString) && (!lhs.hasDefaultString || lhs.defaultString == rhs.defaultString)
  fieldCheck = fieldCheck && (lhs.hasDefaultBytes == rhs.hasDefaultBytes) && (!lhs.hasDefaultBytes || lhs.defaultBytes == rhs.defaultBytes)
  fieldCheck = fieldCheck && (lhs.hasDefaultNestedEnum == rhs.hasDefaultNestedEnum) && (!lhs.hasDefaultNestedEnum || lhs.defaultNestedEnum == rhs.defaultNestedEnum)
  fieldCheck = fieldCheck && (lhs.hasDefaultForeignEnum == rhs.hasDefaultForeignEnum) && (!lhs.hasDefaultForeignEnum || lhs.defaultForeignEnum == rhs.defaultForeignEnum)
  fieldCheck = fieldCheck && (lhs.hasDefaultImportEnum == rhs.hasDefaultImportEnum) && (!lhs.hasDefaultImportEnum || lhs.defaultImportEnum == rhs.defaultImportEnum)
  fieldCheck = fieldCheck && (lhs.hasDefaultStringPiece == rhs.hasDefaultStringPiece) && (!lhs.hasDefaultStringPiece || lhs.defaultStringPiece == rhs.defaultStringPiece)
  fieldCheck = fieldCheck && (lhs.hasDefaultCord == rhs.hasDefaultCord) && (!lhs.hasDefaultCord || lhs.defaultCord == rhs.defaultCord)
  fieldCheck = fieldCheck && (lhs.hasOneofUint32 == rhs.hasOneofUint32) && (!lhs.hasOneofUint32 || lhs.oneofUint32 == rhs.oneofUint32)
  fieldCheck = fieldCheck && (lhs.hasOneofNestedMessage == rhs.hasOneofNestedMessage) && (!lhs.hasOneofNestedMessage || lhs.oneofNestedMessage == rhs.oneofNestedMessage)
  fieldCheck = fieldCheck && (lhs.hasOneofString == rhs.hasOneofString) && (!lhs.hasOneofString || lhs.oneofString == rhs.oneofString)
  fieldCheck = fieldCheck && (lhs.hasOneofBytes == rhs.hasOneofBytes) && (!lhs.hasOneofBytes || lhs.oneofBytes == rhs.oneofBytes)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: NestedTestAllTypes, rhs: NestedTestAllTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasChild == rhs.hasChild) && (!lhs.hasChild || lhs.child == rhs.child)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDeprecatedFields, rhs: TestDeprecatedFields) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecatedInt32 == rhs.hasDeprecatedInt32) && (!lhs.hasDeprecatedInt32 || lhs.deprecatedInt32 == rhs.deprecatedInt32)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: ForeignMessage, rhs: ForeignMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasC == rhs.hasC) && (!lhs.hasC || lhs.c == rhs.c)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestAllExtensions, rhs: TestAllExtensions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: OptionalGroup_extension, rhs: OptionalGroup_extension) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: RepeatedGroup_extension, rhs: RepeatedGroup_extension) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestNestedExtension, rhs: TestNestedExtension) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRequired, rhs: TestRequired) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasDummy2 == rhs.hasDummy2) && (!lhs.hasDummy2 || lhs.dummy2 == rhs.dummy2)
  fieldCheck = fieldCheck && (lhs.hasB == rhs.hasB) && (!lhs.hasB || lhs.b == rhs.b)
  fieldCheck = fieldCheck && (lhs.hasDummy4 == rhs.hasDummy4) && (!lhs.hasDummy4 || lhs.dummy4 == rhs.dummy4)
  fieldCheck = fieldCheck && (lhs.hasDummy5 == rhs.hasDummy5) && (!lhs.hasDummy5 || lhs.dummy5 == rhs.dummy5)
  fieldCheck = fieldCheck && (lhs.hasDummy6 == rhs.hasDummy6) && (!lhs.hasDummy6 || lhs.dummy6 == rhs.dummy6)
  fieldCheck = fieldCheck && (lhs.hasDummy7 == rhs.hasDummy7) && (!lhs.hasDummy7 || lhs.dummy7 == rhs.dummy7)
  fieldCheck = fieldCheck && (lhs.hasDummy8 == rhs.hasDummy8) && (!lhs.hasDummy8 || lhs.dummy8 == rhs.dummy8)
  fieldCheck = fieldCheck && (lhs.hasDummy9 == rhs.hasDummy9) && (!lhs.hasDummy9 || lhs.dummy9 == rhs.dummy9)
  fieldCheck = fieldCheck && (lhs.hasDummy10 == rhs.hasDummy10) && (!lhs.hasDummy10 || lhs.dummy10 == rhs.dummy10)
  fieldCheck = fieldCheck && (lhs.hasDummy11 == rhs.hasDummy11) && (!lhs.hasDummy11 || lhs.dummy11 == rhs.dummy11)
  fieldCheck = fieldCheck && (lhs.hasDummy12 == rhs.hasDummy12) && (!lhs.hasDummy12 || lhs.dummy12 == rhs.dummy12)
  fieldCheck = fieldCheck && (lhs.hasDummy13 == rhs.hasDummy13) && (!lhs.hasDummy13 || lhs.dummy13 == rhs.dummy13)
  fieldCheck = fieldCheck && (lhs.hasDummy14 == rhs.hasDummy14) && (!lhs.hasDummy14 || lhs.dummy14 == rhs.dummy14)
  fieldCheck = fieldCheck && (lhs.hasDummy15 == rhs.hasDummy15) && (!lhs.hasDummy15 || lhs.dummy15 == rhs.dummy15)
  fieldCheck = fieldCheck && (lhs.hasDummy16 == rhs.hasDummy16) && (!lhs.hasDummy16 || lhs.dummy16 == rhs.dummy16)
  fieldCheck = fieldCheck && (lhs.hasDummy17 == rhs.hasDummy17) && (!lhs.hasDummy17 || lhs.dummy17 == rhs.dummy17)
  fieldCheck = fieldCheck && (lhs.hasDummy18 == rhs.hasDummy18) && (!lhs.hasDummy18 || lhs.dummy18 == rhs.dummy18)
  fieldCheck = fieldCheck && (lhs.hasDummy19 == rhs.hasDummy19) && (!lhs.hasDummy19 || lhs.dummy19 == rhs.dummy19)
  fieldCheck = fieldCheck && (lhs.hasDummy20 == rhs.hasDummy20) && (!lhs.hasDummy20 || lhs.dummy20 == rhs.dummy20)
  fieldCheck = fieldCheck && (lhs.hasDummy21 == rhs.hasDummy21) && (!lhs.hasDummy21 || lhs.dummy21 == rhs.dummy21)
  fieldCheck = fieldCheck && (lhs.hasDummy22 == rhs.hasDummy22) && (!lhs.hasDummy22 || lhs.dummy22 == rhs.dummy22)
  fieldCheck = fieldCheck && (lhs.hasDummy23 == rhs.hasDummy23) && (!lhs.hasDummy23 || lhs.dummy23 == rhs.dummy23)
  fieldCheck = fieldCheck && (lhs.hasDummy24 == rhs.hasDummy24) && (!lhs.hasDummy24 || lhs.dummy24 == rhs.dummy24)
  fieldCheck = fieldCheck && (lhs.hasDummy25 == rhs.hasDummy25) && (!lhs.hasDummy25 || lhs.dummy25 == rhs.dummy25)
  fieldCheck = fieldCheck && (lhs.hasDummy26 == rhs.hasDummy26) && (!lhs.hasDummy26 || lhs.dummy26 == rhs.dummy26)
  fieldCheck = fieldCheck && (lhs.hasDummy27 == rhs.hasDummy27) && (!lhs.hasDummy27 || lhs.dummy27 == rhs.dummy27)
  fieldCheck = fieldCheck && (lhs.hasDummy28 == rhs.hasDummy28) && (!lhs.hasDummy28 || lhs.dummy28 == rhs.dummy28)
  fieldCheck = fieldCheck && (lhs.hasDummy29 == rhs.hasDummy29) && (!lhs.hasDummy29 || lhs.dummy29 == rhs.dummy29)
  fieldCheck = fieldCheck && (lhs.hasDummy30 == rhs.hasDummy30) && (!lhs.hasDummy30 || lhs.dummy30 == rhs.dummy30)
  fieldCheck = fieldCheck && (lhs.hasDummy31 == rhs.hasDummy31) && (!lhs.hasDummy31 || lhs.dummy31 == rhs.dummy31)
  fieldCheck = fieldCheck && (lhs.hasDummy32 == rhs.hasDummy32) && (!lhs.hasDummy32 || lhs.dummy32 == rhs.dummy32)
  fieldCheck = fieldCheck && (lhs.hasC == rhs.hasC) && (!lhs.hasC || lhs.c == rhs.c)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRequiredForeign, rhs: TestRequiredForeign) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOptionalMessage == rhs.hasOptionalMessage) && (!lhs.hasOptionalMessage || lhs.optionalMessage == rhs.optionalMessage)
  fieldCheck = fieldCheck && (lhs.repeatedMessage == rhs.repeatedMessage)
  fieldCheck = fieldCheck && (lhs.hasDummy == rhs.hasDummy) && (!lhs.hasDummy || lhs.dummy == rhs.dummy)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestForeignNested, rhs: TestForeignNested) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasForeignNested == rhs.hasForeignNested) && (!lhs.hasForeignNested || lhs.foreignNested == rhs.foreignNested)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestEmptyMessage, rhs: TestEmptyMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestEmptyMessageWithExtensions, rhs: TestEmptyMessageWithExtensions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestMultipleExtensionRanges, rhs: TestMultipleExtensionRanges) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(42), endExclusive:Int32(43))
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(4143), endExclusive:Int32(4244))
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(65536), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestReallyLargeTagNumber, rhs: TestReallyLargeTagNumber) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasBb == rhs.hasBb) && (!lhs.hasBb || lhs.bb == rhs.bb)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRecursiveMessage, rhs: TestRecursiveMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasI == rhs.hasI) && (!lhs.hasI || lhs.i == rhs.i)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestMutualRecursionA, rhs: TestMutualRecursionA) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBb == rhs.hasBb) && (!lhs.hasBb || lhs.bb == rhs.bb)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestMutualRecursionB, rhs: TestMutualRecursionB) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasOptionalInt32 == rhs.hasOptionalInt32) && (!lhs.hasOptionalInt32 || lhs.optionalInt32 == rhs.optionalInt32)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDupFieldNumber.Foo, rhs: TestDupFieldNumber.Foo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDupFieldNumber.Bar, rhs: TestDupFieldNumber.Bar) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDupFieldNumber, rhs: TestDupFieldNumber) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasFoo == rhs.hasFoo) && (!lhs.hasFoo || lhs.foo == rhs.foo)
  fieldCheck = fieldCheck && (lhs.hasBar == rhs.hasBar) && (!lhs.hasBar || lhs.bar == rhs.bar)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestEagerMessage, rhs: TestEagerMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSubMessage == rhs.hasSubMessage) && (!lhs.hasSubMessage || lhs.subMessage == rhs.subMessage)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestLazyMessage, rhs: TestLazyMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSubMessage == rhs.hasSubMessage) && (!lhs.hasSubMessage || lhs.subMessage == rhs.subMessage)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestNestedMessageHasBits.NestedMessage, rhs: TestNestedMessageHasBits.NestedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.nestedmessageRepeatedInt32 == rhs.nestedmessageRepeatedInt32)
  fieldCheck = fieldCheck && (lhs.nestedmessageRepeatedForeignmessage == rhs.nestedmessageRepeatedForeignmessage)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestNestedMessageHasBits, rhs: TestNestedMessageHasBits) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOptionalNestedMessage == rhs.hasOptionalNestedMessage) && (!lhs.hasOptionalNestedMessage || lhs.optionalNestedMessage == rhs.optionalNestedMessage)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestCamelCaseFieldNames, rhs: TestCamelCaseFieldNames) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPrimitiveField == rhs.hasPrimitiveField) && (!lhs.hasPrimitiveField || lhs.primitiveField == rhs.primitiveField)
  fieldCheck = fieldCheck && (lhs.hasStringField == rhs.hasStringField) && (!lhs.hasStringField || lhs.stringField == rhs.stringField)
  fieldCheck = fieldCheck && (lhs.hasEnumField == rhs.hasEnumField) && (!lhs.hasEnumField || lhs.enumField == rhs.enumField)
  fieldCheck = fieldCheck && (lhs.hasMessageField == rhs.hasMessageField) && (!lhs.hasMessageField || lhs.messageField == rhs.messageField)
  fieldCheck = fieldCheck && (lhs.hasStringPieceField == rhs.hasStringPieceField) && (!lhs.hasStringPieceField || lhs.stringPieceField == rhs.stringPieceField)
  fieldCheck = fieldCheck && (lhs.hasCordField == rhs.hasCordField) && (!lhs.hasCordField || lhs.cordField == rhs.cordField)
  fieldCheck = fieldCheck && (lhs.repeatedPrimitiveField == rhs.repeatedPrimitiveField)
  fieldCheck = fieldCheck && (lhs.repeatedStringField == rhs.repeatedStringField)
  fieldCheck = fieldCheck && (lhs.repeatedEnumField == rhs.repeatedEnumField)
  fieldCheck = fieldCheck && (lhs.repeatedMessageField == rhs.repeatedMessageField)
  fieldCheck = fieldCheck && (lhs.repeatedStringPieceField == rhs.repeatedStringPieceField)
  fieldCheck = fieldCheck && (lhs.repeatedCordField == rhs.repeatedCordField)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestFieldOrderings, rhs: TestFieldOrderings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMyInt == rhs.hasMyInt) && (!lhs.hasMyInt || lhs.myInt == rhs.myInt)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(2), endExclusive:Int32(11))
  fieldCheck = fieldCheck && (lhs.hasMyString == rhs.hasMyString) && (!lhs.hasMyString || lhs.myString == rhs.myString)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(12), endExclusive:Int32(101))
  fieldCheck = fieldCheck && (lhs.hasMyFloat == rhs.hasMyFloat) && (!lhs.hasMyFloat || lhs.myFloat == rhs.myFloat)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestExtremeDefaultValues, rhs: TestExtremeDefaultValues) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEscapedBytes == rhs.hasEscapedBytes) && (!lhs.hasEscapedBytes || lhs.escapedBytes == rhs.escapedBytes)
  fieldCheck = fieldCheck && (lhs.hasLargeUint32 == rhs.hasLargeUint32) && (!lhs.hasLargeUint32 || lhs.largeUint32 == rhs.largeUint32)
  fieldCheck = fieldCheck && (lhs.hasLargeUint64 == rhs.hasLargeUint64) && (!lhs.hasLargeUint64 || lhs.largeUint64 == rhs.largeUint64)
  fieldCheck = fieldCheck && (lhs.hasSmallInt32 == rhs.hasSmallInt32) && (!lhs.hasSmallInt32 || lhs.smallInt32 == rhs.smallInt32)
  fieldCheck = fieldCheck && (lhs.hasSmallInt64 == rhs.hasSmallInt64) && (!lhs.hasSmallInt64 || lhs.smallInt64 == rhs.smallInt64)
  fieldCheck = fieldCheck && (lhs.hasUtf8String == rhs.hasUtf8String) && (!lhs.hasUtf8String || lhs.utf8String == rhs.utf8String)
  fieldCheck = fieldCheck && (lhs.hasZeroFloat == rhs.hasZeroFloat) && (!lhs.hasZeroFloat || lhs.zeroFloat == rhs.zeroFloat)
  fieldCheck = fieldCheck && (lhs.hasOneFloat == rhs.hasOneFloat) && (!lhs.hasOneFloat || lhs.oneFloat == rhs.oneFloat)
  fieldCheck = fieldCheck && (lhs.hasSmallFloat == rhs.hasSmallFloat) && (!lhs.hasSmallFloat || lhs.smallFloat == rhs.smallFloat)
  fieldCheck = fieldCheck && (lhs.hasNegativeOneFloat == rhs.hasNegativeOneFloat) && (!lhs.hasNegativeOneFloat || lhs.negativeOneFloat == rhs.negativeOneFloat)
  fieldCheck = fieldCheck && (lhs.hasNegativeFloat == rhs.hasNegativeFloat) && (!lhs.hasNegativeFloat || lhs.negativeFloat == rhs.negativeFloat)
  fieldCheck = fieldCheck && (lhs.hasLargeFloat == rhs.hasLargeFloat) && (!lhs.hasLargeFloat || lhs.largeFloat == rhs.largeFloat)
  fieldCheck = fieldCheck && (lhs.hasSmallNegativeFloat == rhs.hasSmallNegativeFloat) && (!lhs.hasSmallNegativeFloat || lhs.smallNegativeFloat == rhs.smallNegativeFloat)
  fieldCheck = fieldCheck && (lhs.hasInfDouble == rhs.hasInfDouble) && (!lhs.hasInfDouble || lhs.infDouble == rhs.infDouble)
  fieldCheck = fieldCheck && (lhs.hasNegInfDouble == rhs.hasNegInfDouble) && (!lhs.hasNegInfDouble || lhs.negInfDouble == rhs.negInfDouble)
  fieldCheck = fieldCheck && (lhs.hasNanDouble == rhs.hasNanDouble) && (!lhs.hasNanDouble || lhs.nanDouble == rhs.nanDouble)
  fieldCheck = fieldCheck && (lhs.hasInfFloat == rhs.hasInfFloat) && (!lhs.hasInfFloat || lhs.infFloat == rhs.infFloat)
  fieldCheck = fieldCheck && (lhs.hasNegInfFloat == rhs.hasNegInfFloat) && (!lhs.hasNegInfFloat || lhs.negInfFloat == rhs.negInfFloat)
  fieldCheck = fieldCheck && (lhs.hasNanFloat == rhs.hasNanFloat) && (!lhs.hasNanFloat || lhs.nanFloat == rhs.nanFloat)
  fieldCheck = fieldCheck && (lhs.hasCppTrigraph == rhs.hasCppTrigraph) && (!lhs.hasCppTrigraph || lhs.cppTrigraph == rhs.cppTrigraph)
  fieldCheck = fieldCheck && (lhs.hasReallySmallInt32 == rhs.hasReallySmallInt32) && (!lhs.hasReallySmallInt32 || lhs.reallySmallInt32 == rhs.reallySmallInt32)
  fieldCheck = fieldCheck && (lhs.hasReallySmallInt64 == rhs.hasReallySmallInt64) && (!lhs.hasReallySmallInt64 || lhs.reallySmallInt64 == rhs.reallySmallInt64)
  fieldCheck = fieldCheck && (lhs.hasStringWithZero == rhs.hasStringWithZero) && (!lhs.hasStringWithZero || lhs.stringWithZero == rhs.stringWithZero)
  fieldCheck = fieldCheck && (lhs.hasBytesWithZero == rhs.hasBytesWithZero) && (!lhs.hasBytesWithZero || lhs.bytesWithZero == rhs.bytesWithZero)
  fieldCheck = fieldCheck && (lhs.hasStringPieceWithZero == rhs.hasStringPieceWithZero) && (!lhs.hasStringPieceWithZero || lhs.stringPieceWithZero == rhs.stringPieceWithZero)
  fieldCheck = fieldCheck && (lhs.hasCordWithZero == rhs.hasCordWithZero) && (!lhs.hasCordWithZero || lhs.cordWithZero == rhs.cordWithZero)
  fieldCheck = fieldCheck && (lhs.hasReplacementString == rhs.hasReplacementString) && (!lhs.hasReplacementString || lhs.replacementString == rhs.replacementString)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: SparseEnumMessage, rhs: SparseEnumMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSparseEnum == rhs.hasSparseEnum) && (!lhs.hasSparseEnum || lhs.sparseEnum == rhs.sparseEnum)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: OneString, rhs: OneString) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MoreString, rhs: MoreString) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: OneBytes, rhs: OneBytes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: MoreBytes, rhs: MoreBytes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Int32Message, rhs: Int32Message) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Uint32Message, rhs: Uint32Message) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Int64Message, rhs: Int64Message) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: Uint64Message, rhs: Uint64Message) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: BoolMessage, rhs: BoolMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneof.FooGroup, rhs: TestOneof.FooGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasB == rhs.hasB) && (!lhs.hasB || lhs.b == rhs.b)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneof, rhs: TestOneof) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFooInt == rhs.hasFooInt) && (!lhs.hasFooInt || lhs.fooInt == rhs.fooInt)
  fieldCheck = fieldCheck && (lhs.hasFooString == rhs.hasFooString) && (!lhs.hasFooString || lhs.fooString == rhs.fooString)
  fieldCheck = fieldCheck && (lhs.hasFooMessage == rhs.hasFooMessage) && (!lhs.hasFooMessage || lhs.fooMessage == rhs.fooMessage)
  fieldCheck = fieldCheck && (lhs.hasFooGroup == rhs.hasFooGroup) && (!lhs.hasFooGroup || lhs.fooGroup == rhs.fooGroup)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneofBackwardsCompatible.FooGroup, rhs: TestOneofBackwardsCompatible.FooGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasB == rhs.hasB) && (!lhs.hasB || lhs.b == rhs.b)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneofBackwardsCompatible, rhs: TestOneofBackwardsCompatible) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFooInt == rhs.hasFooInt) && (!lhs.hasFooInt || lhs.fooInt == rhs.fooInt)
  fieldCheck = fieldCheck && (lhs.hasFooString == rhs.hasFooString) && (!lhs.hasFooString || lhs.fooString == rhs.fooString)
  fieldCheck = fieldCheck && (lhs.hasFooMessage == rhs.hasFooMessage) && (!lhs.hasFooMessage || lhs.fooMessage == rhs.fooMessage)
  fieldCheck = fieldCheck && (lhs.hasFooGroup == rhs.hasFooGroup) && (!lhs.hasFooGroup || lhs.fooGroup == rhs.fooGroup)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneof2.FooGroup, rhs: TestOneof2.FooGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  fieldCheck = fieldCheck && (lhs.hasB == rhs.hasB) && (!lhs.hasB || lhs.b == rhs.b)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneof2.NestedMessage, rhs: TestOneof2.NestedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasQuxInt == rhs.hasQuxInt) && (!lhs.hasQuxInt || lhs.quxInt == rhs.quxInt)
  fieldCheck = fieldCheck && (lhs.corgeInt == rhs.corgeInt)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestOneof2, rhs: TestOneof2) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFooInt == rhs.hasFooInt) && (!lhs.hasFooInt || lhs.fooInt == rhs.fooInt)
  fieldCheck = fieldCheck && (lhs.hasFooString == rhs.hasFooString) && (!lhs.hasFooString || lhs.fooString == rhs.fooString)
  fieldCheck = fieldCheck && (lhs.hasFooCord == rhs.hasFooCord) && (!lhs.hasFooCord || lhs.fooCord == rhs.fooCord)
  fieldCheck = fieldCheck && (lhs.hasFooStringPiece == rhs.hasFooStringPiece) && (!lhs.hasFooStringPiece || lhs.fooStringPiece == rhs.fooStringPiece)
  fieldCheck = fieldCheck && (lhs.hasFooBytes == rhs.hasFooBytes) && (!lhs.hasFooBytes || lhs.fooBytes == rhs.fooBytes)
  fieldCheck = fieldCheck && (lhs.hasFooEnum == rhs.hasFooEnum) && (!lhs.hasFooEnum || lhs.fooEnum == rhs.fooEnum)
  fieldCheck = fieldCheck && (lhs.hasFooMessage == rhs.hasFooMessage) && (!lhs.hasFooMessage || lhs.fooMessage == rhs.fooMessage)
  fieldCheck = fieldCheck && (lhs.hasFooGroup == rhs.hasFooGroup) && (!lhs.hasFooGroup || lhs.fooGroup == rhs.fooGroup)
  fieldCheck = fieldCheck && (lhs.hasFooLazyMessage == rhs.hasFooLazyMessage) && (!lhs.hasFooLazyMessage || lhs.fooLazyMessage == rhs.fooLazyMessage)
  fieldCheck = fieldCheck && (lhs.hasBarInt == rhs.hasBarInt) && (!lhs.hasBarInt || lhs.barInt == rhs.barInt)
  fieldCheck = fieldCheck && (lhs.hasBarString == rhs.hasBarString) && (!lhs.hasBarString || lhs.barString == rhs.barString)
  fieldCheck = fieldCheck && (lhs.hasBarCord == rhs.hasBarCord) && (!lhs.hasBarCord || lhs.barCord == rhs.barCord)
  fieldCheck = fieldCheck && (lhs.hasBarStringPiece == rhs.hasBarStringPiece) && (!lhs.hasBarStringPiece || lhs.barStringPiece == rhs.barStringPiece)
  fieldCheck = fieldCheck && (lhs.hasBarBytes == rhs.hasBarBytes) && (!lhs.hasBarBytes || lhs.barBytes == rhs.barBytes)
  fieldCheck = fieldCheck && (lhs.hasBarEnum == rhs.hasBarEnum) && (!lhs.hasBarEnum || lhs.barEnum == rhs.barEnum)
  fieldCheck = fieldCheck && (lhs.hasBazInt == rhs.hasBazInt) && (!lhs.hasBazInt || lhs.bazInt == rhs.bazInt)
  fieldCheck = fieldCheck && (lhs.hasBazString == rhs.hasBazString) && (!lhs.hasBazString || lhs.bazString == rhs.bazString)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRequiredOneof.NestedMessage, rhs: TestRequiredOneof.NestedMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequiredDouble == rhs.hasRequiredDouble) && (!lhs.hasRequiredDouble || lhs.requiredDouble == rhs.requiredDouble)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRequiredOneof, rhs: TestRequiredOneof) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFooInt == rhs.hasFooInt) && (!lhs.hasFooInt || lhs.fooInt == rhs.fooInt)
  fieldCheck = fieldCheck && (lhs.hasFooString == rhs.hasFooString) && (!lhs.hasFooString || lhs.fooString == rhs.fooString)
  fieldCheck = fieldCheck && (lhs.hasFooMessage == rhs.hasFooMessage) && (!lhs.hasFooMessage || lhs.fooMessage == rhs.fooMessage)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestPackedTypes, rhs: TestPackedTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.packedInt32 == rhs.packedInt32)
  fieldCheck = fieldCheck && (lhs.packedInt64 == rhs.packedInt64)
  fieldCheck = fieldCheck && (lhs.packedUint32 == rhs.packedUint32)
  fieldCheck = fieldCheck && (lhs.packedUint64 == rhs.packedUint64)
  fieldCheck = fieldCheck && (lhs.packedSint32 == rhs.packedSint32)
  fieldCheck = fieldCheck && (lhs.packedSint64 == rhs.packedSint64)
  fieldCheck = fieldCheck && (lhs.packedFixed32 == rhs.packedFixed32)
  fieldCheck = fieldCheck && (lhs.packedFixed64 == rhs.packedFixed64)
  fieldCheck = fieldCheck && (lhs.packedSfixed32 == rhs.packedSfixed32)
  fieldCheck = fieldCheck && (lhs.packedSfixed64 == rhs.packedSfixed64)
  fieldCheck = fieldCheck && (lhs.packedFloat == rhs.packedFloat)
  fieldCheck = fieldCheck && (lhs.packedDouble == rhs.packedDouble)
  fieldCheck = fieldCheck && (lhs.packedBool == rhs.packedBool)
  fieldCheck = fieldCheck && (lhs.packedEnum == rhs.packedEnum)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestUnpackedTypes, rhs: TestUnpackedTypes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.unpackedInt32 == rhs.unpackedInt32)
  fieldCheck = fieldCheck && (lhs.unpackedInt64 == rhs.unpackedInt64)
  fieldCheck = fieldCheck && (lhs.unpackedUint32 == rhs.unpackedUint32)
  fieldCheck = fieldCheck && (lhs.unpackedUint64 == rhs.unpackedUint64)
  fieldCheck = fieldCheck && (lhs.unpackedSint32 == rhs.unpackedSint32)
  fieldCheck = fieldCheck && (lhs.unpackedSint64 == rhs.unpackedSint64)
  fieldCheck = fieldCheck && (lhs.unpackedFixed32 == rhs.unpackedFixed32)
  fieldCheck = fieldCheck && (lhs.unpackedFixed64 == rhs.unpackedFixed64)
  fieldCheck = fieldCheck && (lhs.unpackedSfixed32 == rhs.unpackedSfixed32)
  fieldCheck = fieldCheck && (lhs.unpackedSfixed64 == rhs.unpackedSfixed64)
  fieldCheck = fieldCheck && (lhs.unpackedFloat == rhs.unpackedFloat)
  fieldCheck = fieldCheck && (lhs.unpackedDouble == rhs.unpackedDouble)
  fieldCheck = fieldCheck && (lhs.unpackedBool == rhs.unpackedBool)
  fieldCheck = fieldCheck && (lhs.unpackedEnum == rhs.unpackedEnum)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestPackedExtensions, rhs: TestPackedExtensions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestUnpackedExtensions, rhs: TestUnpackedExtensions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDynamicExtensions.DynamicMessageType, rhs: TestDynamicExtensions.DynamicMessageType) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDynamicField == rhs.hasDynamicField) && (!lhs.hasDynamicField || lhs.dynamicField == rhs.dynamicField)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestDynamicExtensions, rhs: TestDynamicExtensions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasScalarExtension == rhs.hasScalarExtension) && (!lhs.hasScalarExtension || lhs.scalarExtension == rhs.scalarExtension)
  fieldCheck = fieldCheck && (lhs.hasEnumExtension == rhs.hasEnumExtension) && (!lhs.hasEnumExtension || lhs.enumExtension == rhs.enumExtension)
  fieldCheck = fieldCheck && (lhs.hasDynamicEnumExtension == rhs.hasDynamicEnumExtension) && (!lhs.hasDynamicEnumExtension || lhs.dynamicEnumExtension == rhs.dynamicEnumExtension)
  fieldCheck = fieldCheck && (lhs.hasMessageExtension == rhs.hasMessageExtension) && (!lhs.hasMessageExtension || lhs.messageExtension == rhs.messageExtension)
  fieldCheck = fieldCheck && (lhs.hasDynamicMessageExtension == rhs.hasDynamicMessageExtension) && (!lhs.hasDynamicMessageExtension || lhs.dynamicMessageExtension == rhs.dynamicMessageExtension)
  fieldCheck = fieldCheck && (lhs.repeatedExtension == rhs.repeatedExtension)
  fieldCheck = fieldCheck && (lhs.packedExtension == rhs.packedExtension)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestRepeatedScalarDifferentTagSizes, rhs: TestRepeatedScalarDifferentTagSizes) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.repeatedFixed32 == rhs.repeatedFixed32)
  fieldCheck = fieldCheck && (lhs.repeatedInt32 == rhs.repeatedInt32)
  fieldCheck = fieldCheck && (lhs.repeatedFixed64 == rhs.repeatedFixed64)
  fieldCheck = fieldCheck && (lhs.repeatedInt64 == rhs.repeatedInt64)
  fieldCheck = fieldCheck && (lhs.repeatedFloat == rhs.repeatedFloat)
  fieldCheck = fieldCheck && (lhs.repeatedUint64 == rhs.repeatedUint64)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestParsingMerge.RepeatedFieldsGenerator, rhs: TestParsingMerge.RepeatedFieldsGenerator) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.field1 == rhs.field1)
  fieldCheck = fieldCheck && (lhs.field2 == rhs.field2)
  fieldCheck = fieldCheck && (lhs.field3 == rhs.field3)
  fieldCheck = fieldCheck && (lhs.group1 == rhs.group1)
  fieldCheck = fieldCheck && (lhs.group2 == rhs.group2)
  fieldCheck = fieldCheck && (lhs.ext1 == rhs.ext1)
  fieldCheck = fieldCheck && (lhs.ext2 == rhs.ext2)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestParsingMerge.OptionalGroup, rhs: TestParsingMerge.OptionalGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOptionalGroupAllTypes == rhs.hasOptionalGroupAllTypes) && (!lhs.hasOptionalGroupAllTypes || lhs.optionalGroupAllTypes == rhs.optionalGroupAllTypes)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestParsingMerge.RepeatedGroup, rhs: TestParsingMerge.RepeatedGroup) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRepeatedGroupAllTypes == rhs.hasRepeatedGroupAllTypes) && (!lhs.hasRepeatedGroupAllTypes || lhs.repeatedGroupAllTypes == rhs.repeatedGroupAllTypes)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestParsingMerge, rhs: TestParsingMerge) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequiredAllTypes == rhs.hasRequiredAllTypes) && (!lhs.hasRequiredAllTypes || lhs.requiredAllTypes == rhs.requiredAllTypes)
  fieldCheck = fieldCheck && (lhs.hasOptionalAllTypes == rhs.hasOptionalAllTypes) && (!lhs.hasOptionalAllTypes || lhs.optionalAllTypes == rhs.optionalAllTypes)
  fieldCheck = fieldCheck && (lhs.repeatedAllTypes == rhs.repeatedAllTypes)
  fieldCheck = fieldCheck && (lhs.hasOptionalGroup == rhs.hasOptionalGroup) && (!lhs.hasOptionalGroup || lhs.optionalGroup == rhs.optionalGroup)
  fieldCheck = fieldCheck && (lhs.repeatedGroup == rhs.repeatedGroup)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: TestCommentInjectionMessage, rhs: TestCommentInjectionMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasA == rhs.hasA) && (!lhs.hasA || lhs.a == rhs.a)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FooRequest, rhs: FooRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FooResponse, rhs: FooResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FooClientMessage, rhs: FooClientMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: FooServerMessage, rhs: FooServerMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: BarRequest, rhs: BarRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: BarResponse, rhs: BarResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class TestAllTypes : GeneratedMessage {


  //Nested type declaration start

    final public class NestedMessage : GeneratedMessage {
      private(set) var hasBb:Bool = false
      private(set) var bb:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasBb {
          output.writeInt32(1, value:bb)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasBb {
          size += WireFormat.computeInt32Size(1, value:bb)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.NestedMessage {
        return TestAllTypes.NestedMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestAllTypes.NestedMessageBuilder {
        return TestAllTypes.NestedMessageBuilder()
      }
      class func builderWithPrototype(prototype:TestAllTypes.NestedMessage) -> TestAllTypes.NestedMessageBuilder {
        return TestAllTypes.NestedMessage.builder().mergeFrom(prototype)
      }
      func builder() -> TestAllTypes.NestedMessageBuilder {
        return TestAllTypes.NestedMessage.builder()
      }
      func toBuilder() -> TestAllTypes.NestedMessageBuilder {
        return TestAllTypes.NestedMessage.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasBb {
          output += "\(indent) bb: \(bb) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasBb {
                 hashCode = (hashCode &* 31) &+ bb.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestAllTypes.NestedMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestAllTypes.NestedMessage.self
      }


      //Meta information declaration end

    }

    final class NestedMessageBuilder : GeneratedMessageBuilder {
      private var builderResult:TestAllTypes.NestedMessage

      required override init () {
         builderResult = TestAllTypes.NestedMessage()
         super.init()
      }
      var hasBb:Bool {
           get {
                return builderResult.hasBb
           }
      }
      var bb:Int32 {
           get {
                return builderResult.bb
           }
           set (value) {
               builderResult.hasBb = true
               builderResult.bb = value
           }
      }
      func clearBb() -> TestAllTypes.NestedMessageBuilder{
           builderResult.hasBb = false
           builderResult.bb = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestAllTypes.NestedMessageBuilder {
        builderResult = TestAllTypes.NestedMessage()
        return self
      }
      override func clone() -> TestAllTypes.NestedMessageBuilder {
        return TestAllTypes.NestedMessage.builderWithPrototype(builderResult)
      }
      override func build() -> TestAllTypes.NestedMessage {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestAllTypes.NestedMessage {
        var returnMe:TestAllTypes.NestedMessage = builderResult
        return returnMe
      }
      func mergeFrom(other:TestAllTypes.NestedMessage) -> TestAllTypes.NestedMessageBuilder {
        if (other == TestAllTypes.NestedMessage()) {
         return self
        }
        if other.hasBb {
             bb = other.bb
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestAllTypes.NestedMessageBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.NestedMessageBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            bb = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class OptionalGroup : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(17, value:a)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(17, value:a)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.OptionalGroup {
        return TestAllTypes.OptionalGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestAllTypes.OptionalGroupBuilder {
        return TestAllTypes.OptionalGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestAllTypes.OptionalGroup) -> TestAllTypes.OptionalGroupBuilder {
        return TestAllTypes.OptionalGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestAllTypes.OptionalGroupBuilder {
        return TestAllTypes.OptionalGroup.builder()
      }
      func toBuilder() -> TestAllTypes.OptionalGroupBuilder {
        return TestAllTypes.OptionalGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestAllTypes.OptionalGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestAllTypes.OptionalGroup.self
      }


      //Meta information declaration end

    }

    final class OptionalGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestAllTypes.OptionalGroup

      required override init () {
         builderResult = TestAllTypes.OptionalGroup()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestAllTypes.OptionalGroupBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestAllTypes.OptionalGroupBuilder {
        builderResult = TestAllTypes.OptionalGroup()
        return self
      }
      override func clone() -> TestAllTypes.OptionalGroupBuilder {
        return TestAllTypes.OptionalGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestAllTypes.OptionalGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestAllTypes.OptionalGroup {
        var returnMe:TestAllTypes.OptionalGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestAllTypes.OptionalGroup) -> TestAllTypes.OptionalGroupBuilder {
        if (other == TestAllTypes.OptionalGroup()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestAllTypes.OptionalGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.OptionalGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 136 :
            a = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class RepeatedGroup : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(47, value:a)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(47, value:a)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.RepeatedGroup {
        return TestAllTypes.RepeatedGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestAllTypes.RepeatedGroupBuilder {
        return TestAllTypes.RepeatedGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestAllTypes.RepeatedGroup) -> TestAllTypes.RepeatedGroupBuilder {
        return TestAllTypes.RepeatedGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestAllTypes.RepeatedGroupBuilder {
        return TestAllTypes.RepeatedGroup.builder()
      }
      func toBuilder() -> TestAllTypes.RepeatedGroupBuilder {
        return TestAllTypes.RepeatedGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestAllTypes.RepeatedGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestAllTypes.RepeatedGroup.self
      }


      //Meta information declaration end

    }

    final class RepeatedGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestAllTypes.RepeatedGroup

      required override init () {
         builderResult = TestAllTypes.RepeatedGroup()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestAllTypes.RepeatedGroupBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestAllTypes.RepeatedGroupBuilder {
        builderResult = TestAllTypes.RepeatedGroup()
        return self
      }
      override func clone() -> TestAllTypes.RepeatedGroupBuilder {
        return TestAllTypes.RepeatedGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestAllTypes.RepeatedGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestAllTypes.RepeatedGroup {
        var returnMe:TestAllTypes.RepeatedGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestAllTypes.RepeatedGroup) -> TestAllTypes.RepeatedGroupBuilder {
        if (other == TestAllTypes.RepeatedGroup()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestAllTypes.RepeatedGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes.RepeatedGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 376 :
            a = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //OneOf declaration start

  enum OneofField {
    case OneofFieldOneOfNotSet

    func checkOneOfIsSet() -> Bool {
         switch self {
         case .OneofFieldOneOfNotSet:
              return false
         default:
              return true
         }
    }
    case OneofUint32(UInt32)

    static func getOneofUint32(value:OneofField) ->UInt32? {
         switch value {
         case .OneofUint32(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case OneofNestedMessage(TestAllTypes.NestedMessage)

    static func getOneofNestedMessage(value:OneofField) ->TestAllTypes.NestedMessage? {
         switch value {
         case .OneofNestedMessage(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case OneofString(String)

    static func getOneofString(value:OneofField) ->String? {
         switch value {
         case .OneofString(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case OneofBytes([Byte])

    static func getOneofBytes(value:OneofField) ->[Byte]? {
         switch value {
         case .OneofBytes(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
  }



  //OneOf declaration end

  private var storageOneofField:TestAllTypes.OneofField =  TestAllTypes.OneofField.OneofFieldOneOfNotSet


    //Enum type declaration start 

    enum NestedEnum:Int32 {
      case Foo = 1
      case Bar = 2
      case Baz = 3
      case Neg = -1

      static func IsValidValue(value:NestedEnum) ->Bool {
        switch value {
          case .Foo, .Bar, .Baz, .Neg:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var hasOptionalInt32:Bool = false
  private(set) var optionalInt32:Int32 = Int32(0)

  private(set) var hasOptionalInt64:Bool = false
  private(set) var optionalInt64:Int64 = Int64(0)

  private(set) var hasOptionalUint32:Bool = false
  private(set) var optionalUint32:UInt32 = UInt32(0)

  private(set) var hasOptionalUint64:Bool = false
  private(set) var optionalUint64:UInt64 = UInt64(0)

  private(set) var hasOptionalSint32:Bool = false
  private(set) var optionalSint32:Int32 = Int32(0)

  private(set) var hasOptionalSint64:Bool = false
  private(set) var optionalSint64:Int64 = Int64(0)

  private(set) var hasOptionalFixed32:Bool = false
  private(set) var optionalFixed32:UInt32 = UInt32(0)

  private(set) var hasOptionalFixed64:Bool = false
  private(set) var optionalFixed64:UInt64 = UInt64(0)

  private(set) var hasOptionalSfixed32:Bool = false
  private(set) var optionalSfixed32:Int32 = Int32(0)

  private(set) var hasOptionalSfixed64:Bool = false
  private(set) var optionalSfixed64:Int64 = Int64(0)

  private(set) var hasOptionalFloat:Bool = false
  private(set) var optionalFloat:Float = Float(0)

  private(set) var hasOptionalDouble:Bool = false
  private(set) var optionalDouble:Double = Double(0)

  private(set) var hasOptionalBool:Bool = false
  private(set) var optionalBool:Bool = false

  private(set) var hasOptionalString:Bool = false
  private(set) var optionalString:String = ""

  private(set) var hasOptionalBytes:Bool = false
  private(set) var optionalBytes:Array<Byte> = [Byte]()

  private(set) var hasOptionalGroup:Bool = false
  private(set) var optionalGroup:TestAllTypes.OptionalGroup = TestAllTypes.OptionalGroup()
  private(set) var hasOptionalNestedMessage:Bool = false
  private(set) var optionalNestedMessage:TestAllTypes.NestedMessage = TestAllTypes.NestedMessage()
  private(set) var hasOptionalForeignMessage:Bool = false
  private(set) var optionalForeignMessage:ForeignMessage = ForeignMessage()
  private(set) var hasOptionalImportMessage:Bool = false
  private(set) var optionalImportMessage:ImportMessage = ImportMessage()
  private(set) var optionalNestedEnum:TestAllTypes.NestedEnum = TestAllTypes.NestedEnum.Foo
  private(set) var hasOptionalNestedEnum:Bool = false
  private(set) var optionalForeignEnum:ForeignEnum = ForeignEnum.ForeignFoo
  private(set) var hasOptionalForeignEnum:Bool = false
  private(set) var optionalImportEnum:ImportEnum = ImportEnum.ImportFoo
  private(set) var hasOptionalImportEnum:Bool = false
  private(set) var hasOptionalStringPiece:Bool = false
  private(set) var optionalStringPiece:String = ""

  private(set) var hasOptionalCord:Bool = false
  private(set) var optionalCord:String = ""

  private(set) var hasOptionalPublicImportMessage:Bool = false
  private(set) var optionalPublicImportMessage:PublicImportMessage = PublicImportMessage()
  private(set) var hasOptionalLazyMessage:Bool = false
  private(set) var optionalLazyMessage:TestAllTypes.NestedMessage = TestAllTypes.NestedMessage()
  private(set) var hasDefaultInt32:Bool = false
  private(set) var defaultInt32:Int32 = Int32(41)

  private(set) var hasDefaultInt64:Bool = false
  private(set) var defaultInt64:Int64 = Int64(42)

  private(set) var hasDefaultUint32:Bool = false
  private(set) var defaultUint32:UInt32 = UInt32(43)

  private(set) var hasDefaultUint64:Bool = false
  private(set) var defaultUint64:UInt64 = UInt64(44)

  private(set) var hasDefaultSint32:Bool = false
  private(set) var defaultSint32:Int32 = Int32(-45)

  private(set) var hasDefaultSint64:Bool = false
  private(set) var defaultSint64:Int64 = Int64(46)

  private(set) var hasDefaultFixed32:Bool = false
  private(set) var defaultFixed32:UInt32 = UInt32(47)

  private(set) var hasDefaultFixed64:Bool = false
  private(set) var defaultFixed64:UInt64 = UInt64(48)

  private(set) var hasDefaultSfixed32:Bool = false
  private(set) var defaultSfixed32:Int32 = Int32(49)

  private(set) var hasDefaultSfixed64:Bool = false
  private(set) var defaultSfixed64:Int64 = Int64(-50)

  private(set) var hasDefaultFloat:Bool = false
  private(set) var defaultFloat:Float = Float(51.5)

  private(set) var hasDefaultDouble:Bool = false
  private(set) var defaultDouble:Double = Double(52000)

  private(set) var hasDefaultBool:Bool = false
  private(set) var defaultBool:Bool = true

  private(set) var hasDefaultString:Bool = false
  private(set) var defaultString:String = "hello"

  private(set) var hasDefaultBytes:Bool = false
  private(set) var defaultBytes:Array<Byte> = ([Byte]() + "world".utf8)

  private(set) var defaultNestedEnum:TestAllTypes.NestedEnum = TestAllTypes.NestedEnum.Bar
  private(set) var hasDefaultNestedEnum:Bool = false
  private(set) var defaultForeignEnum:ForeignEnum = ForeignEnum.ForeignBar
  private(set) var hasDefaultForeignEnum:Bool = false
  private(set) var defaultImportEnum:ImportEnum = ImportEnum.ImportBar
  private(set) var hasDefaultImportEnum:Bool = false
  private(set) var hasDefaultStringPiece:Bool = false
  private(set) var defaultStringPiece:String = "abc"

  private(set) var hasDefaultCord:Bool = false
  private(set) var defaultCord:String = "123"

  private(set) var hasOneofUint32:Bool {
        get {
             if TestAllTypes.OneofField.getOneofUint32(storageOneofField) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var oneofUint32:UInt32!{
       get {
            return TestAllTypes.OneofField.getOneofUint32(storageOneofField)
       }
       set (newvalue) {
            storageOneofField = TestAllTypes.OneofField.OneofUint32(newvalue)
       }
  }
  private(set) var hasOneofNestedMessage:Bool {
        get {
             if TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var oneofNestedMessage:TestAllTypes.NestedMessage!{
       get {
            return TestAllTypes.OneofField.getOneofNestedMessage(storageOneofField)
       }
       set (newvalue) {
            storageOneofField = TestAllTypes.OneofField.OneofNestedMessage(newvalue)
       }
  }
  private(set) var hasOneofString:Bool {
        get {
             if TestAllTypes.OneofField.getOneofString(storageOneofField) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var oneofString:String!{
       get {
            return TestAllTypes.OneofField.getOneofString(storageOneofField)
       }
       set (newvalue) {
            storageOneofField = TestAllTypes.OneofField.OneofString(newvalue)
       }
  }
  private(set) var hasOneofBytes:Bool {
        get {
             if TestAllTypes.OneofField.getOneofBytes(storageOneofField) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var oneofBytes:Array<Byte>!{
       get {
            return TestAllTypes.OneofField.getOneofBytes(storageOneofField)
       }
       set (newvalue) {
            storageOneofField = TestAllTypes.OneofField.OneofBytes(newvalue)
       }
  }
  private(set) var repeatedInt32:Array<Int32> = Array<Int32>()
  private(set) var repeatedInt64:Array<Int64> = Array<Int64>()
  private(set) var repeatedUint32:Array<UInt32> = Array<UInt32>()
  private(set) var repeatedUint64:Array<UInt64> = Array<UInt64>()
  private(set) var repeatedSint32:Array<Int32> = Array<Int32>()
  private(set) var repeatedSint64:Array<Int64> = Array<Int64>()
  private(set) var repeatedFixed32:Array<UInt32> = Array<UInt32>()
  private(set) var repeatedFixed64:Array<UInt64> = Array<UInt64>()
  private(set) var repeatedSfixed32:Array<Int32> = Array<Int32>()
  private(set) var repeatedSfixed64:Array<Int64> = Array<Int64>()
  private(set) var repeatedFloat:Array<Float> = Array<Float>()
  private(set) var repeatedDouble:Array<Double> = Array<Double>()
  private(set) var repeatedBool:Array<Bool> = Array<Bool>()
  private(set) var repeatedString:Array<String> = Array<String>()
  private(set) var repeatedBytes:Array<Array<Byte>> = Array<Array<Byte>>()
  private(set) var repeatedGroup:Array<TestAllTypes.RepeatedGroup>  = Array<TestAllTypes.RepeatedGroup>()
  private(set) var repeatedNestedMessage:Array<TestAllTypes.NestedMessage>  = Array<TestAllTypes.NestedMessage>()
  private(set) var repeatedForeignMessage:Array<ForeignMessage>  = Array<ForeignMessage>()
  private(set) var repeatedImportMessage:Array<ImportMessage>  = Array<ImportMessage>()
  private var repeatedNestedEnumMemoizedSerializedSize:Int32 = 0
  private(set) var repeatedNestedEnum:Array<TestAllTypes.NestedEnum> = Array<TestAllTypes.NestedEnum>()
  private var repeatedForeignEnumMemoizedSerializedSize:Int32 = 0
  private(set) var repeatedForeignEnum:Array<ForeignEnum> = Array<ForeignEnum>()
  private var repeatedImportEnumMemoizedSerializedSize:Int32 = 0
  private(set) var repeatedImportEnum:Array<ImportEnum> = Array<ImportEnum>()
  private(set) var repeatedStringPiece:Array<String> = Array<String>()
  private(set) var repeatedCord:Array<String> = Array<String>()
  private(set) var repeatedLazyMessage:Array<TestAllTypes.NestedMessage>  = Array<TestAllTypes.NestedMessage>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasOptionalInt32 {
      output.writeInt32(1, value:optionalInt32)
    }
    if hasOptionalInt64 {
      output.writeInt64(2, value:optionalInt64)
    }
    if hasOptionalUint32 {
      output.writeUInt32(3, value:optionalUint32)
    }
    if hasOptionalUint64 {
      output.writeUInt64(4, value:optionalUint64)
    }
    if hasOptionalSint32 {
      output.writeSInt32(5, value:optionalSint32)
    }
    if hasOptionalSint64 {
      output.writeSInt64(6, value:optionalSint64)
    }
    if hasOptionalFixed32 {
      output.writeFixed32(7, value:optionalFixed32)
    }
    if hasOptionalFixed64 {
      output.writeFixed64(8, value:optionalFixed64)
    }
    if hasOptionalSfixed32 {
      output.writeSFixed32(9, value:optionalSfixed32)
    }
    if hasOptionalSfixed64 {
      output.writeSFixed64(10, value:optionalSfixed64)
    }
    if hasOptionalFloat {
      output.writeFloat(11, value:optionalFloat)
    }
    if hasOptionalDouble {
      output.writeDouble(12, value:optionalDouble)
    }
    if hasOptionalBool {
      output.writeBool(13, value:optionalBool)
    }
    if hasOptionalString {
      output.writeString(14, value:optionalString)
    }
    if hasOptionalBytes {
      output.writeData(15, value:optionalBytes)
    }
    if hasOptionalGroup {
      output.writeGroup(16, value:optionalGroup)
    }
    if hasOptionalNestedMessage {
      output.writeMessage(18, value:optionalNestedMessage)
    }
    if hasOptionalForeignMessage {
      output.writeMessage(19, value:optionalForeignMessage)
    }
    if hasOptionalImportMessage {
      output.writeMessage(20, value:optionalImportMessage)
    }
    if hasOptionalNestedEnum {
      output.writeEnum(21, value:optionalNestedEnum.rawValue)
    }
    if hasOptionalForeignEnum {
      output.writeEnum(22, value:optionalForeignEnum.rawValue)
    }
    if hasOptionalImportEnum {
      output.writeEnum(23, value:optionalImportEnum.rawValue)
    }
    if hasOptionalStringPiece {
      output.writeString(24, value:optionalStringPiece)
    }
    if hasOptionalCord {
      output.writeString(25, value:optionalCord)
    }
    if hasOptionalPublicImportMessage {
      output.writeMessage(26, value:optionalPublicImportMessage)
    }
    if hasOptionalLazyMessage {
      output.writeMessage(27, value:optionalLazyMessage)
    }
    if !repeatedInt32.isEmpty {
      for value in repeatedInt32 {
        output.writeInt32(31, value:value)
      }
    }
    if !repeatedInt64.isEmpty {
      for value in repeatedInt64 {
        output.writeInt64(32, value:value)
      }
    }
    if !repeatedUint32.isEmpty {
      for value in repeatedUint32 {
        output.writeUInt32(33, value:value)
      }
    }
    if !repeatedUint64.isEmpty {
      for value in repeatedUint64 {
        output.writeUInt64(34, value:value)
      }
    }
    if !repeatedSint32.isEmpty {
      for value in repeatedSint32 {
        output.writeSInt32(35, value:value)
      }
    }
    if !repeatedSint64.isEmpty {
      for value in repeatedSint64 {
        output.writeSInt64(36, value:value)
      }
    }
    if !repeatedFixed32.isEmpty {
      for value in repeatedFixed32 {
        output.writeFixed32(37, value:value)
      }
    }
    if !repeatedFixed64.isEmpty {
      for value in repeatedFixed64 {
        output.writeFixed64(38, value:value)
      }
    }
    if !repeatedSfixed32.isEmpty {
      for value in repeatedSfixed32 {
        output.writeSFixed32(39, value:value)
      }
    }
    if !repeatedSfixed64.isEmpty {
      for value in repeatedSfixed64 {
        output.writeSFixed64(40, value:value)
      }
    }
    if !repeatedFloat.isEmpty {
      for value in repeatedFloat {
        output.writeFloat(41, value:value)
      }
    }
    if !repeatedDouble.isEmpty {
      for value in repeatedDouble {
        output.writeDouble(42, value:value)
      }
    }
    if !repeatedBool.isEmpty {
      for value in repeatedBool {
        output.writeBool(43, value:value)
      }
    }
    if !repeatedString.isEmpty {
      for value in repeatedString {
        output.writeString(44, value:value)
      }
    }
    if !repeatedBytes.isEmpty {
      for value in repeatedBytes {
        output.writeData(45, value:value)
      }
    }
    for element in repeatedGroup {
        output.writeGroup(46, value:element)
    }
    for element in repeatedNestedMessage {
        output.writeMessage(48, value:element)
    }
    for element in repeatedForeignMessage {
        output.writeMessage(49, value:element)
    }
    for element in repeatedImportMessage {
        output.writeMessage(50, value:element)
    }
    for value in repeatedNestedEnum {
        output.writeEnum(51, value:value.rawValue)
    }
    for value in repeatedForeignEnum {
        output.writeEnum(52, value:value.rawValue)
    }
    for value in repeatedImportEnum {
        output.writeEnum(53, value:value.rawValue)
    }
    if !repeatedStringPiece.isEmpty {
      for value in repeatedStringPiece {
        output.writeString(54, value:value)
      }
    }
    if !repeatedCord.isEmpty {
      for value in repeatedCord {
        output.writeString(55, value:value)
      }
    }
    for element in repeatedLazyMessage {
        output.writeMessage(57, value:element)
    }
    if hasDefaultInt32 {
      output.writeInt32(61, value:defaultInt32)
    }
    if hasDefaultInt64 {
      output.writeInt64(62, value:defaultInt64)
    }
    if hasDefaultUint32 {
      output.writeUInt32(63, value:defaultUint32)
    }
    if hasDefaultUint64 {
      output.writeUInt64(64, value:defaultUint64)
    }
    if hasDefaultSint32 {
      output.writeSInt32(65, value:defaultSint32)
    }
    if hasDefaultSint64 {
      output.writeSInt64(66, value:defaultSint64)
    }
    if hasDefaultFixed32 {
      output.writeFixed32(67, value:defaultFixed32)
    }
    if hasDefaultFixed64 {
      output.writeFixed64(68, value:defaultFixed64)
    }
    if hasDefaultSfixed32 {
      output.writeSFixed32(69, value:defaultSfixed32)
    }
    if hasDefaultSfixed64 {
      output.writeSFixed64(70, value:defaultSfixed64)
    }
    if hasDefaultFloat {
      output.writeFloat(71, value:defaultFloat)
    }
    if hasDefaultDouble {
      output.writeDouble(72, value:defaultDouble)
    }
    if hasDefaultBool {
      output.writeBool(73, value:defaultBool)
    }
    if hasDefaultString {
      output.writeString(74, value:defaultString)
    }
    if hasDefaultBytes {
      output.writeData(75, value:defaultBytes)
    }
    if hasDefaultNestedEnum {
      output.writeEnum(81, value:defaultNestedEnum.rawValue)
    }
    if hasDefaultForeignEnum {
      output.writeEnum(82, value:defaultForeignEnum.rawValue)
    }
    if hasDefaultImportEnum {
      output.writeEnum(83, value:defaultImportEnum.rawValue)
    }
    if hasDefaultStringPiece {
      output.writeString(84, value:defaultStringPiece)
    }
    if hasDefaultCord {
      output.writeString(85, value:defaultCord)
    }
    if hasOneofUint32 {
      output.writeUInt32(111, value:oneofUint32)
    }
    if hasOneofNestedMessage {
      output.writeMessage(112, value:oneofNestedMessage)
    }
    if hasOneofString {
      output.writeString(113, value:oneofString)
    }
    if hasOneofBytes {
      output.writeData(114, value:oneofBytes)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasOptionalInt32 {
      size += WireFormat.computeInt32Size(1, value:optionalInt32)
    }
    if hasOptionalInt64 {
      size += WireFormat.computeInt64Size(2, value:optionalInt64)
    }
    if hasOptionalUint32 {
      size += WireFormat.computeUInt32Size(3, value:optionalUint32)
    }
    if hasOptionalUint64 {
      size += WireFormat.computeUInt64Size(4, value:optionalUint64)
    }
    if hasOptionalSint32 {
      size += WireFormat.computeSInt32Size(5, value:optionalSint32)
    }
    if hasOptionalSint64 {
      size += WireFormat.computeSInt64Size(6, value:optionalSint64)
    }
    if hasOptionalFixed32 {
      size += WireFormat.computeFixed32Size(7, value:optionalFixed32)
    }
    if hasOptionalFixed64 {
      size += WireFormat.computeFixed64Size(8, value:optionalFixed64)
    }
    if hasOptionalSfixed32 {
      size += WireFormat.computeSFixed32Size(9, value:optionalSfixed32)
    }
    if hasOptionalSfixed64 {
      size += WireFormat.computeSFixed64Size(10, value:optionalSfixed64)
    }
    if hasOptionalFloat {
      size += WireFormat.computeFloatSize(11, value:optionalFloat)
    }
    if hasOptionalDouble {
      size += WireFormat.computeDoubleSize(12, value:optionalDouble)
    }
    if hasOptionalBool {
      size += WireFormat.computeBoolSize(13, value:optionalBool)
    }
    if hasOptionalString {
      size += WireFormat.computeStringSize(14, value:optionalString)
    }
    if hasOptionalBytes {
      size += WireFormat.computeDataSize(15, value:optionalBytes)
    }
    if hasOptionalGroup {
      size += WireFormat.computeGroupSize(16, value:optionalGroup)
    }
    if hasOptionalNestedMessage {
      size += WireFormat.computeMessageSize(18, value:optionalNestedMessage)
    }
    if hasOptionalForeignMessage {
      size += WireFormat.computeMessageSize(19, value:optionalForeignMessage)
    }
    if hasOptionalImportMessage {
      size += WireFormat.computeMessageSize(20, value:optionalImportMessage)
    }
    if (hasOptionalNestedEnum) {
      size += WireFormat.computeEnumSize(21, value:optionalNestedEnum.rawValue)
    }
    if (hasOptionalForeignEnum) {
      size += WireFormat.computeEnumSize(22, value:optionalForeignEnum.rawValue)
    }
    if (hasOptionalImportEnum) {
      size += WireFormat.computeEnumSize(23, value:optionalImportEnum.rawValue)
    }
    if hasOptionalStringPiece {
      size += WireFormat.computeStringSize(24, value:optionalStringPiece)
    }
    if hasOptionalCord {
      size += WireFormat.computeStringSize(25, value:optionalCord)
    }
    if hasOptionalPublicImportMessage {
      size += WireFormat.computeMessageSize(26, value:optionalPublicImportMessage)
    }
    if hasOptionalLazyMessage {
      size += WireFormat.computeMessageSize(27, value:optionalLazyMessage)
    }
    var dataSizeRepeatedInt32:Int32 = 0
    for element in repeatedInt32 {
        dataSizeRepeatedInt32 += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizeRepeatedInt32
    size += 2 * Int32(repeatedInt32.count)
    var dataSizeRepeatedInt64:Int32 = 0
    for element in repeatedInt64 {
        dataSizeRepeatedInt64 += WireFormat.computeInt64SizeNoTag(element)
    }
    size += dataSizeRepeatedInt64
    size += 2 * Int32(repeatedInt64.count)
    var dataSizeRepeatedUint32:Int32 = 0
    for element in repeatedUint32 {
        dataSizeRepeatedUint32 += WireFormat.computeUInt32SizeNoTag(element)
    }
    size += dataSizeRepeatedUint32
    size += 2 * Int32(repeatedUint32.count)
    var dataSizeRepeatedUint64:Int32 = 0
    for element in repeatedUint64 {
        dataSizeRepeatedUint64 += WireFormat.computeUInt64SizeNoTag(element)
    }
    size += dataSizeRepeatedUint64
    size += 2 * Int32(repeatedUint64.count)
    var dataSizeRepeatedSint32:Int32 = 0
    for element in repeatedSint32 {
        dataSizeRepeatedSint32 += WireFormat.computeSInt32SizeNoTag(element)
    }
    size += dataSizeRepeatedSint32
    size += 2 * Int32(repeatedSint32.count)
    var dataSizeRepeatedSint64:Int32 = 0
    for element in repeatedSint64 {
        dataSizeRepeatedSint64 += WireFormat.computeSInt64SizeNoTag(element)
    }
    size += dataSizeRepeatedSint64
    size += 2 * Int32(repeatedSint64.count)
    var dataSizeRepeatedFixed32:Int32 = 0
    dataSizeRepeatedFixed32 = 4 * Int32(repeatedFixed32.count)
    size += dataSizeRepeatedFixed32
    size += 2 * Int32(repeatedFixed32.count)
    var dataSizeRepeatedFixed64:Int32 = 0
    dataSizeRepeatedFixed64 = 8 * Int32(repeatedFixed64.count)
    size += dataSizeRepeatedFixed64
    size += 2 * Int32(repeatedFixed64.count)
    var dataSizeRepeatedSfixed32:Int32 = 0
    dataSizeRepeatedSfixed32 = 4 * Int32(repeatedSfixed32.count)
    size += dataSizeRepeatedSfixed32
    size += 2 * Int32(repeatedSfixed32.count)
    var dataSizeRepeatedSfixed64:Int32 = 0
    dataSizeRepeatedSfixed64 = 8 * Int32(repeatedSfixed64.count)
    size += dataSizeRepeatedSfixed64
    size += 2 * Int32(repeatedSfixed64.count)
    var dataSizeRepeatedFloat:Int32 = 0
    dataSizeRepeatedFloat = 4 * Int32(repeatedFloat.count)
    size += dataSizeRepeatedFloat
    size += 2 * Int32(repeatedFloat.count)
    var dataSizeRepeatedDouble:Int32 = 0
    dataSizeRepeatedDouble = 8 * Int32(repeatedDouble.count)
    size += dataSizeRepeatedDouble
    size += 2 * Int32(repeatedDouble.count)
    var dataSizeRepeatedBool:Int32 = 0
    dataSizeRepeatedBool = 1 * Int32(repeatedBool.count)
    size += dataSizeRepeatedBool
    size += 2 * Int32(repeatedBool.count)
    var dataSizeRepeatedString:Int32 = 0
    for element in repeatedString {
        dataSizeRepeatedString += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedString
    size += 2 * Int32(repeatedString.count)
    var dataSizeRepeatedBytes:Int32 = 0
    for element in repeatedBytes {
        dataSizeRepeatedBytes += WireFormat.computeDataSizeNoTag(element)
    }
    size += dataSizeRepeatedBytes
    size += 2 * Int32(repeatedBytes.count)
    for element in repeatedGroup {
        size += WireFormat.computeGroupSize(46, value:element)
    }
    for element in repeatedNestedMessage {
        size += WireFormat.computeMessageSize(48, value:element)
    }
    for element in repeatedForeignMessage {
        size += WireFormat.computeMessageSize(49, value:element)
    }
    for element in repeatedImportMessage {
        size += WireFormat.computeMessageSize(50, value:element)
    }
    var dataSizerepeatedNestedEnum:Int32 = 0
    for value in repeatedNestedEnum {
        dataSizerepeatedNestedEnum += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizerepeatedNestedEnum
    size += (2 * Int32(repeatedNestedEnum.count))
    var dataSizerepeatedForeignEnum:Int32 = 0
    for value in repeatedForeignEnum {
        dataSizerepeatedForeignEnum += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizerepeatedForeignEnum
    size += (2 * Int32(repeatedForeignEnum.count))
    var dataSizerepeatedImportEnum:Int32 = 0
    for value in repeatedImportEnum {
        dataSizerepeatedImportEnum += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizerepeatedImportEnum
    size += (2 * Int32(repeatedImportEnum.count))
    var dataSizeRepeatedStringPiece:Int32 = 0
    for element in repeatedStringPiece {
        dataSizeRepeatedStringPiece += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedStringPiece
    size += 2 * Int32(repeatedStringPiece.count)
    var dataSizeRepeatedCord:Int32 = 0
    for element in repeatedCord {
        dataSizeRepeatedCord += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedCord
    size += 2 * Int32(repeatedCord.count)
    for element in repeatedLazyMessage {
        size += WireFormat.computeMessageSize(57, value:element)
    }
    if hasDefaultInt32 {
      size += WireFormat.computeInt32Size(61, value:defaultInt32)
    }
    if hasDefaultInt64 {
      size += WireFormat.computeInt64Size(62, value:defaultInt64)
    }
    if hasDefaultUint32 {
      size += WireFormat.computeUInt32Size(63, value:defaultUint32)
    }
    if hasDefaultUint64 {
      size += WireFormat.computeUInt64Size(64, value:defaultUint64)
    }
    if hasDefaultSint32 {
      size += WireFormat.computeSInt32Size(65, value:defaultSint32)
    }
    if hasDefaultSint64 {
      size += WireFormat.computeSInt64Size(66, value:defaultSint64)
    }
    if hasDefaultFixed32 {
      size += WireFormat.computeFixed32Size(67, value:defaultFixed32)
    }
    if hasDefaultFixed64 {
      size += WireFormat.computeFixed64Size(68, value:defaultFixed64)
    }
    if hasDefaultSfixed32 {
      size += WireFormat.computeSFixed32Size(69, value:defaultSfixed32)
    }
    if hasDefaultSfixed64 {
      size += WireFormat.computeSFixed64Size(70, value:defaultSfixed64)
    }
    if hasDefaultFloat {
      size += WireFormat.computeFloatSize(71, value:defaultFloat)
    }
    if hasDefaultDouble {
      size += WireFormat.computeDoubleSize(72, value:defaultDouble)
    }
    if hasDefaultBool {
      size += WireFormat.computeBoolSize(73, value:defaultBool)
    }
    if hasDefaultString {
      size += WireFormat.computeStringSize(74, value:defaultString)
    }
    if hasDefaultBytes {
      size += WireFormat.computeDataSize(75, value:defaultBytes)
    }
    if (hasDefaultNestedEnum) {
      size += WireFormat.computeEnumSize(81, value:defaultNestedEnum.rawValue)
    }
    if (hasDefaultForeignEnum) {
      size += WireFormat.computeEnumSize(82, value:defaultForeignEnum.rawValue)
    }
    if (hasDefaultImportEnum) {
      size += WireFormat.computeEnumSize(83, value:defaultImportEnum.rawValue)
    }
    if hasDefaultStringPiece {
      size += WireFormat.computeStringSize(84, value:defaultStringPiece)
    }
    if hasDefaultCord {
      size += WireFormat.computeStringSize(85, value:defaultCord)
    }
    if hasOneofUint32 {
      size += WireFormat.computeUInt32Size(111, value:oneofUint32)
    }
    if hasOneofNestedMessage {
      size += WireFormat.computeMessageSize(112, value:oneofNestedMessage)
    }
    if hasOneofString {
      size += WireFormat.computeStringSize(113, value:oneofString)
    }
    if hasOneofBytes {
      size += WireFormat.computeDataSize(114, value:oneofBytes)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestAllTypes {
    return TestAllTypes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestAllTypes {
    return TestAllTypes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestAllTypes {
    return TestAllTypes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestAllTypes {
    return TestAllTypes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestAllTypes {
    return TestAllTypes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypes {
    return TestAllTypes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestAllTypesBuilder {
    return TestAllTypesBuilder()
  }
  class func builderWithPrototype(prototype:TestAllTypes) -> TestAllTypesBuilder {
    return TestAllTypes.builder().mergeFrom(prototype)
  }
  func builder() -> TestAllTypesBuilder {
    return TestAllTypes.builder()
  }
  func toBuilder() -> TestAllTypesBuilder {
    return TestAllTypes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasOptionalInt32 {
      output += "\(indent) optionalInt32: \(optionalInt32) \n"
    }
    if hasOptionalInt64 {
      output += "\(indent) optionalInt64: \(optionalInt64) \n"
    }
    if hasOptionalUint32 {
      output += "\(indent) optionalUint32: \(optionalUint32) \n"
    }
    if hasOptionalUint64 {
      output += "\(indent) optionalUint64: \(optionalUint64) \n"
    }
    if hasOptionalSint32 {
      output += "\(indent) optionalSint32: \(optionalSint32) \n"
    }
    if hasOptionalSint64 {
      output += "\(indent) optionalSint64: \(optionalSint64) \n"
    }
    if hasOptionalFixed32 {
      output += "\(indent) optionalFixed32: \(optionalFixed32) \n"
    }
    if hasOptionalFixed64 {
      output += "\(indent) optionalFixed64: \(optionalFixed64) \n"
    }
    if hasOptionalSfixed32 {
      output += "\(indent) optionalSfixed32: \(optionalSfixed32) \n"
    }
    if hasOptionalSfixed64 {
      output += "\(indent) optionalSfixed64: \(optionalSfixed64) \n"
    }
    if hasOptionalFloat {
      output += "\(indent) optionalFloat: \(optionalFloat) \n"
    }
    if hasOptionalDouble {
      output += "\(indent) optionalDouble: \(optionalDouble) \n"
    }
    if hasOptionalBool {
      output += "\(indent) optionalBool: \(optionalBool) \n"
    }
    if hasOptionalString {
      output += "\(indent) optionalString: \(optionalString) \n"
    }
    if hasOptionalBytes {
      output += "\(indent) optionalBytes: \(optionalBytes) \n"
    }
    if hasOptionalGroup {
      output += "\(indent) optionalGroup {\n"
      optionalGroup.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalNestedMessage {
      output += "\(indent) optionalNestedMessage {\n"
      optionalNestedMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalForeignMessage {
      output += "\(indent) optionalForeignMessage {\n"
      optionalForeignMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalImportMessage {
      output += "\(indent) optionalImportMessage {\n"
      optionalImportMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if (hasOptionalNestedEnum) {
      output += "\(indent) optionalNestedEnum: \(optionalNestedEnum.rawValue)\n"
    }
    if (hasOptionalForeignEnum) {
      output += "\(indent) optionalForeignEnum: \(optionalForeignEnum.rawValue)\n"
    }
    if (hasOptionalImportEnum) {
      output += "\(indent) optionalImportEnum: \(optionalImportEnum.rawValue)\n"
    }
    if hasOptionalStringPiece {
      output += "\(indent) optionalStringPiece: \(optionalStringPiece) \n"
    }
    if hasOptionalCord {
      output += "\(indent) optionalCord: \(optionalCord) \n"
    }
    if hasOptionalPublicImportMessage {
      output += "\(indent) optionalPublicImportMessage {\n"
      optionalPublicImportMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalLazyMessage {
      output += "\(indent) optionalLazyMessage {\n"
      optionalLazyMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var repeatedInt32ElementIndex:Int = 0
    for element in repeatedInt32  {
        output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(element)\n"
        repeatedInt32ElementIndex++
    }
    var repeatedInt64ElementIndex:Int = 0
    for element in repeatedInt64  {
        output += "\(indent) repeatedInt64[\(repeatedInt64ElementIndex)]: \(element)\n"
        repeatedInt64ElementIndex++
    }
    var repeatedUint32ElementIndex:Int = 0
    for element in repeatedUint32  {
        output += "\(indent) repeatedUint32[\(repeatedUint32ElementIndex)]: \(element)\n"
        repeatedUint32ElementIndex++
    }
    var repeatedUint64ElementIndex:Int = 0
    for element in repeatedUint64  {
        output += "\(indent) repeatedUint64[\(repeatedUint64ElementIndex)]: \(element)\n"
        repeatedUint64ElementIndex++
    }
    var repeatedSint32ElementIndex:Int = 0
    for element in repeatedSint32  {
        output += "\(indent) repeatedSint32[\(repeatedSint32ElementIndex)]: \(element)\n"
        repeatedSint32ElementIndex++
    }
    var repeatedSint64ElementIndex:Int = 0
    for element in repeatedSint64  {
        output += "\(indent) repeatedSint64[\(repeatedSint64ElementIndex)]: \(element)\n"
        repeatedSint64ElementIndex++
    }
    var repeatedFixed32ElementIndex:Int = 0
    for element in repeatedFixed32  {
        output += "\(indent) repeatedFixed32[\(repeatedFixed32ElementIndex)]: \(element)\n"
        repeatedFixed32ElementIndex++
    }
    var repeatedFixed64ElementIndex:Int = 0
    for element in repeatedFixed64  {
        output += "\(indent) repeatedFixed64[\(repeatedFixed64ElementIndex)]: \(element)\n"
        repeatedFixed64ElementIndex++
    }
    var repeatedSfixed32ElementIndex:Int = 0
    for element in repeatedSfixed32  {
        output += "\(indent) repeatedSfixed32[\(repeatedSfixed32ElementIndex)]: \(element)\n"
        repeatedSfixed32ElementIndex++
    }
    var repeatedSfixed64ElementIndex:Int = 0
    for element in repeatedSfixed64  {
        output += "\(indent) repeatedSfixed64[\(repeatedSfixed64ElementIndex)]: \(element)\n"
        repeatedSfixed64ElementIndex++
    }
    var repeatedFloatElementIndex:Int = 0
    for element in repeatedFloat  {
        output += "\(indent) repeatedFloat[\(repeatedFloatElementIndex)]: \(element)\n"
        repeatedFloatElementIndex++
    }
    var repeatedDoubleElementIndex:Int = 0
    for element in repeatedDouble  {
        output += "\(indent) repeatedDouble[\(repeatedDoubleElementIndex)]: \(element)\n"
        repeatedDoubleElementIndex++
    }
    var repeatedBoolElementIndex:Int = 0
    for element in repeatedBool  {
        output += "\(indent) repeatedBool[\(repeatedBoolElementIndex)]: \(element)\n"
        repeatedBoolElementIndex++
    }
    var repeatedStringElementIndex:Int = 0
    for element in repeatedString  {
        output += "\(indent) repeatedString[\(repeatedStringElementIndex)]: \(element)\n"
        repeatedStringElementIndex++
    }
    var repeatedBytesElementIndex:Int = 0
    for element in repeatedBytes  {
        output += "\(indent) repeatedBytes[\(repeatedBytesElementIndex)]: \(element)\n"
        repeatedBytesElementIndex++
    }
    var repeatedGroupElementIndex:Int = 0
    for element in repeatedGroup {
        output += "\(indent) repeatedGroup[\(repeatedGroupElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedGroupElementIndex++
    }
    var repeatedNestedMessageElementIndex:Int = 0
    for element in repeatedNestedMessage {
        output += "\(indent) repeatedNestedMessage[\(repeatedNestedMessageElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedNestedMessageElementIndex++
    }
    var repeatedForeignMessageElementIndex:Int = 0
    for element in repeatedForeignMessage {
        output += "\(indent) repeatedForeignMessage[\(repeatedForeignMessageElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedForeignMessageElementIndex++
    }
    var repeatedImportMessageElementIndex:Int = 0
    for element in repeatedImportMessage {
        output += "\(indent) repeatedImportMessage[\(repeatedImportMessageElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedImportMessageElementIndex++
    }
    var repeatedNestedEnumElementIndex:Int = 0
    for element in repeatedNestedEnum {
        output += "\(indent) repeatedNestedEnum[\(repeatedNestedEnumElementIndex)]: \(element.rawValue)"
        repeatedNestedEnumElementIndex++
    }
    var repeatedForeignEnumElementIndex:Int = 0
    for element in repeatedForeignEnum {
        output += "\(indent) repeatedForeignEnum[\(repeatedForeignEnumElementIndex)]: \(element.rawValue)"
        repeatedForeignEnumElementIndex++
    }
    var repeatedImportEnumElementIndex:Int = 0
    for element in repeatedImportEnum {
        output += "\(indent) repeatedImportEnum[\(repeatedImportEnumElementIndex)]: \(element.rawValue)"
        repeatedImportEnumElementIndex++
    }
    var repeatedStringPieceElementIndex:Int = 0
    for element in repeatedStringPiece  {
        output += "\(indent) repeatedStringPiece[\(repeatedStringPieceElementIndex)]: \(element)\n"
        repeatedStringPieceElementIndex++
    }
    var repeatedCordElementIndex:Int = 0
    for element in repeatedCord  {
        output += "\(indent) repeatedCord[\(repeatedCordElementIndex)]: \(element)\n"
        repeatedCordElementIndex++
    }
    var repeatedLazyMessageElementIndex:Int = 0
    for element in repeatedLazyMessage {
        output += "\(indent) repeatedLazyMessage[\(repeatedLazyMessageElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedLazyMessageElementIndex++
    }
    if hasDefaultInt32 {
      output += "\(indent) defaultInt32: \(defaultInt32) \n"
    }
    if hasDefaultInt64 {
      output += "\(indent) defaultInt64: \(defaultInt64) \n"
    }
    if hasDefaultUint32 {
      output += "\(indent) defaultUint32: \(defaultUint32) \n"
    }
    if hasDefaultUint64 {
      output += "\(indent) defaultUint64: \(defaultUint64) \n"
    }
    if hasDefaultSint32 {
      output += "\(indent) defaultSint32: \(defaultSint32) \n"
    }
    if hasDefaultSint64 {
      output += "\(indent) defaultSint64: \(defaultSint64) \n"
    }
    if hasDefaultFixed32 {
      output += "\(indent) defaultFixed32: \(defaultFixed32) \n"
    }
    if hasDefaultFixed64 {
      output += "\(indent) defaultFixed64: \(defaultFixed64) \n"
    }
    if hasDefaultSfixed32 {
      output += "\(indent) defaultSfixed32: \(defaultSfixed32) \n"
    }
    if hasDefaultSfixed64 {
      output += "\(indent) defaultSfixed64: \(defaultSfixed64) \n"
    }
    if hasDefaultFloat {
      output += "\(indent) defaultFloat: \(defaultFloat) \n"
    }
    if hasDefaultDouble {
      output += "\(indent) defaultDouble: \(defaultDouble) \n"
    }
    if hasDefaultBool {
      output += "\(indent) defaultBool: \(defaultBool) \n"
    }
    if hasDefaultString {
      output += "\(indent) defaultString: \(defaultString) \n"
    }
    if hasDefaultBytes {
      output += "\(indent) defaultBytes: \(defaultBytes) \n"
    }
    if (hasDefaultNestedEnum) {
      output += "\(indent) defaultNestedEnum: \(defaultNestedEnum.rawValue)\n"
    }
    if (hasDefaultForeignEnum) {
      output += "\(indent) defaultForeignEnum: \(defaultForeignEnum.rawValue)\n"
    }
    if (hasDefaultImportEnum) {
      output += "\(indent) defaultImportEnum: \(defaultImportEnum.rawValue)\n"
    }
    if hasDefaultStringPiece {
      output += "\(indent) defaultStringPiece: \(defaultStringPiece) \n"
    }
    if hasDefaultCord {
      output += "\(indent) defaultCord: \(defaultCord) \n"
    }
    if hasOneofUint32 {
      output += "\(indent) oneofUint32: \(oneofUint32) \n"
    }
    if hasOneofNestedMessage {
      output += "\(indent) oneofNestedMessage {\n"
      oneofNestedMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOneofString {
      output += "\(indent) oneofString: \(oneofString) \n"
    }
    if hasOneofBytes {
      output += "\(indent) oneofBytes: \(oneofBytes) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOptionalInt32 {
             hashCode = (hashCode &* 31) &+ optionalInt32.hashValue
          }
          if hasOptionalInt64 {
             hashCode = (hashCode &* 31) &+ optionalInt64.hashValue
          }
          if hasOptionalUint32 {
             hashCode = (hashCode &* 31) &+ optionalUint32.hashValue
          }
          if hasOptionalUint64 {
             hashCode = (hashCode &* 31) &+ optionalUint64.hashValue
          }
          if hasOptionalSint32 {
             hashCode = (hashCode &* 31) &+ optionalSint32.hashValue
          }
          if hasOptionalSint64 {
             hashCode = (hashCode &* 31) &+ optionalSint64.hashValue
          }
          if hasOptionalFixed32 {
             hashCode = (hashCode &* 31) &+ optionalFixed32.hashValue
          }
          if hasOptionalFixed64 {
             hashCode = (hashCode &* 31) &+ optionalFixed64.hashValue
          }
          if hasOptionalSfixed32 {
             hashCode = (hashCode &* 31) &+ optionalSfixed32.hashValue
          }
          if hasOptionalSfixed64 {
             hashCode = (hashCode &* 31) &+ optionalSfixed64.hashValue
          }
          if hasOptionalFloat {
             hashCode = (hashCode &* 31) &+ optionalFloat.hashValue
          }
          if hasOptionalDouble {
             hashCode = (hashCode &* 31) &+ optionalDouble.hashValue
          }
          if hasOptionalBool {
             hashCode = (hashCode &* 31) &+ optionalBool.hashValue
          }
          if hasOptionalString {
             hashCode = (hashCode &* 31) &+ optionalString.hashValue
          }
          for value in optionalBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasOptionalGroup {
            hashCode = (hashCode &* 31) &+ optionalGroup.hashValue
          }
          if hasOptionalNestedMessage {
            hashCode = (hashCode &* 31) &+ optionalNestedMessage.hashValue
          }
          if hasOptionalForeignMessage {
            hashCode = (hashCode &* 31) &+ optionalForeignMessage.hashValue
          }
          if hasOptionalImportMessage {
            hashCode = (hashCode &* 31) &+ optionalImportMessage.hashValue
          }
          if hasOptionalNestedEnum {
             hashCode = (hashCode &* 31) &+ Int(optionalNestedEnum.rawValue)
          }
          if hasOptionalForeignEnum {
             hashCode = (hashCode &* 31) &+ Int(optionalForeignEnum.rawValue)
          }
          if hasOptionalImportEnum {
             hashCode = (hashCode &* 31) &+ Int(optionalImportEnum.rawValue)
          }
          if hasOptionalStringPiece {
             hashCode = (hashCode &* 31) &+ optionalStringPiece.hashValue
          }
          if hasOptionalCord {
             hashCode = (hashCode &* 31) &+ optionalCord.hashValue
          }
          if hasOptionalPublicImportMessage {
            hashCode = (hashCode &* 31) &+ optionalPublicImportMessage.hashValue
          }
          if hasOptionalLazyMessage {
            hashCode = (hashCode &* 31) &+ optionalLazyMessage.hashValue
          }
          for element in repeatedInt32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedInt64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedUint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedUint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedSint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedSint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedFixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedFixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedSfixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedSfixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedFloat {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedDouble {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedBool {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedString {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for value in repeatedBytes {
            for element in value {
                hashCode = (hashCode &* 31) &+ element.hashValue
            }
          }
          for element in repeatedGroup {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedNestedMessage {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedForeignMessage {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedImportMessage {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedNestedEnum {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          for element in repeatedForeignEnum {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          for element in repeatedImportEnum {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          for element in repeatedStringPiece {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedCord {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedLazyMessage {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasDefaultInt32 {
             hashCode = (hashCode &* 31) &+ defaultInt32.hashValue
          }
          if hasDefaultInt64 {
             hashCode = (hashCode &* 31) &+ defaultInt64.hashValue
          }
          if hasDefaultUint32 {
             hashCode = (hashCode &* 31) &+ defaultUint32.hashValue
          }
          if hasDefaultUint64 {
             hashCode = (hashCode &* 31) &+ defaultUint64.hashValue
          }
          if hasDefaultSint32 {
             hashCode = (hashCode &* 31) &+ defaultSint32.hashValue
          }
          if hasDefaultSint64 {
             hashCode = (hashCode &* 31) &+ defaultSint64.hashValue
          }
          if hasDefaultFixed32 {
             hashCode = (hashCode &* 31) &+ defaultFixed32.hashValue
          }
          if hasDefaultFixed64 {
             hashCode = (hashCode &* 31) &+ defaultFixed64.hashValue
          }
          if hasDefaultSfixed32 {
             hashCode = (hashCode &* 31) &+ defaultSfixed32.hashValue
          }
          if hasDefaultSfixed64 {
             hashCode = (hashCode &* 31) &+ defaultSfixed64.hashValue
          }
          if hasDefaultFloat {
             hashCode = (hashCode &* 31) &+ defaultFloat.hashValue
          }
          if hasDefaultDouble {
             hashCode = (hashCode &* 31) &+ defaultDouble.hashValue
          }
          if hasDefaultBool {
             hashCode = (hashCode &* 31) &+ defaultBool.hashValue
          }
          if hasDefaultString {
             hashCode = (hashCode &* 31) &+ defaultString.hashValue
          }
          for value in defaultBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasDefaultNestedEnum {
             hashCode = (hashCode &* 31) &+ Int(defaultNestedEnum.rawValue)
          }
          if hasDefaultForeignEnum {
             hashCode = (hashCode &* 31) &+ Int(defaultForeignEnum.rawValue)
          }
          if hasDefaultImportEnum {
             hashCode = (hashCode &* 31) &+ Int(defaultImportEnum.rawValue)
          }
          if hasDefaultStringPiece {
             hashCode = (hashCode &* 31) &+ defaultStringPiece.hashValue
          }
          if hasDefaultCord {
             hashCode = (hashCode &* 31) &+ defaultCord.hashValue
          }
          if hasOneofUint32 {
             hashCode = (hashCode &* 31) &+ oneofUint32.hashValue
          }
          if hasOneofNestedMessage {
            hashCode = (hashCode &* 31) &+ oneofNestedMessage.hashValue
          }
          if hasOneofString {
             hashCode = (hashCode &* 31) &+ oneofString.hashValue
          }
          for value in oneofBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestAllTypes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestAllTypes.self
  }


  //Meta information declaration end

}

final class TestAllTypesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestAllTypes

  required override init () {
     builderResult = TestAllTypes()
     super.init()
  }
  var hasOptionalInt32:Bool {
       get {
            return builderResult.hasOptionalInt32
       }
  }
  var optionalInt32:Int32 {
       get {
            return builderResult.optionalInt32
       }
       set (value) {
           builderResult.hasOptionalInt32 = true
           builderResult.optionalInt32 = value
       }
  }
  func clearOptionalInt32() -> TestAllTypesBuilder{
       builderResult.hasOptionalInt32 = false
       builderResult.optionalInt32 = Int32(0)
       return self
  }
  var hasOptionalInt64:Bool {
       get {
            return builderResult.hasOptionalInt64
       }
  }
  var optionalInt64:Int64 {
       get {
            return builderResult.optionalInt64
       }
       set (value) {
           builderResult.hasOptionalInt64 = true
           builderResult.optionalInt64 = value
       }
  }
  func clearOptionalInt64() -> TestAllTypesBuilder{
       builderResult.hasOptionalInt64 = false
       builderResult.optionalInt64 = Int64(0)
       return self
  }
  var hasOptionalUint32:Bool {
       get {
            return builderResult.hasOptionalUint32
       }
  }
  var optionalUint32:UInt32 {
       get {
            return builderResult.optionalUint32
       }
       set (value) {
           builderResult.hasOptionalUint32 = true
           builderResult.optionalUint32 = value
       }
  }
  func clearOptionalUint32() -> TestAllTypesBuilder{
       builderResult.hasOptionalUint32 = false
       builderResult.optionalUint32 = UInt32(0)
       return self
  }
  var hasOptionalUint64:Bool {
       get {
            return builderResult.hasOptionalUint64
       }
  }
  var optionalUint64:UInt64 {
       get {
            return builderResult.optionalUint64
       }
       set (value) {
           builderResult.hasOptionalUint64 = true
           builderResult.optionalUint64 = value
       }
  }
  func clearOptionalUint64() -> TestAllTypesBuilder{
       builderResult.hasOptionalUint64 = false
       builderResult.optionalUint64 = UInt64(0)
       return self
  }
  var hasOptionalSint32:Bool {
       get {
            return builderResult.hasOptionalSint32
       }
  }
  var optionalSint32:Int32 {
       get {
            return builderResult.optionalSint32
       }
       set (value) {
           builderResult.hasOptionalSint32 = true
           builderResult.optionalSint32 = value
       }
  }
  func clearOptionalSint32() -> TestAllTypesBuilder{
       builderResult.hasOptionalSint32 = false
       builderResult.optionalSint32 = Int32(0)
       return self
  }
  var hasOptionalSint64:Bool {
       get {
            return builderResult.hasOptionalSint64
       }
  }
  var optionalSint64:Int64 {
       get {
            return builderResult.optionalSint64
       }
       set (value) {
           builderResult.hasOptionalSint64 = true
           builderResult.optionalSint64 = value
       }
  }
  func clearOptionalSint64() -> TestAllTypesBuilder{
       builderResult.hasOptionalSint64 = false
       builderResult.optionalSint64 = Int64(0)
       return self
  }
  var hasOptionalFixed32:Bool {
       get {
            return builderResult.hasOptionalFixed32
       }
  }
  var optionalFixed32:UInt32 {
       get {
            return builderResult.optionalFixed32
       }
       set (value) {
           builderResult.hasOptionalFixed32 = true
           builderResult.optionalFixed32 = value
       }
  }
  func clearOptionalFixed32() -> TestAllTypesBuilder{
       builderResult.hasOptionalFixed32 = false
       builderResult.optionalFixed32 = UInt32(0)
       return self
  }
  var hasOptionalFixed64:Bool {
       get {
            return builderResult.hasOptionalFixed64
       }
  }
  var optionalFixed64:UInt64 {
       get {
            return builderResult.optionalFixed64
       }
       set (value) {
           builderResult.hasOptionalFixed64 = true
           builderResult.optionalFixed64 = value
       }
  }
  func clearOptionalFixed64() -> TestAllTypesBuilder{
       builderResult.hasOptionalFixed64 = false
       builderResult.optionalFixed64 = UInt64(0)
       return self
  }
  var hasOptionalSfixed32:Bool {
       get {
            return builderResult.hasOptionalSfixed32
       }
  }
  var optionalSfixed32:Int32 {
       get {
            return builderResult.optionalSfixed32
       }
       set (value) {
           builderResult.hasOptionalSfixed32 = true
           builderResult.optionalSfixed32 = value
       }
  }
  func clearOptionalSfixed32() -> TestAllTypesBuilder{
       builderResult.hasOptionalSfixed32 = false
       builderResult.optionalSfixed32 = Int32(0)
       return self
  }
  var hasOptionalSfixed64:Bool {
       get {
            return builderResult.hasOptionalSfixed64
       }
  }
  var optionalSfixed64:Int64 {
       get {
            return builderResult.optionalSfixed64
       }
       set (value) {
           builderResult.hasOptionalSfixed64 = true
           builderResult.optionalSfixed64 = value
       }
  }
  func clearOptionalSfixed64() -> TestAllTypesBuilder{
       builderResult.hasOptionalSfixed64 = false
       builderResult.optionalSfixed64 = Int64(0)
       return self
  }
  var hasOptionalFloat:Bool {
       get {
            return builderResult.hasOptionalFloat
       }
  }
  var optionalFloat:Float {
       get {
            return builderResult.optionalFloat
       }
       set (value) {
           builderResult.hasOptionalFloat = true
           builderResult.optionalFloat = value
       }
  }
  func clearOptionalFloat() -> TestAllTypesBuilder{
       builderResult.hasOptionalFloat = false
       builderResult.optionalFloat = Float(0)
       return self
  }
  var hasOptionalDouble:Bool {
       get {
            return builderResult.hasOptionalDouble
       }
  }
  var optionalDouble:Double {
       get {
            return builderResult.optionalDouble
       }
       set (value) {
           builderResult.hasOptionalDouble = true
           builderResult.optionalDouble = value
       }
  }
  func clearOptionalDouble() -> TestAllTypesBuilder{
       builderResult.hasOptionalDouble = false
       builderResult.optionalDouble = Double(0)
       return self
  }
  var hasOptionalBool:Bool {
       get {
            return builderResult.hasOptionalBool
       }
  }
  var optionalBool:Bool {
       get {
            return builderResult.optionalBool
       }
       set (value) {
           builderResult.hasOptionalBool = true
           builderResult.optionalBool = value
       }
  }
  func clearOptionalBool() -> TestAllTypesBuilder{
       builderResult.hasOptionalBool = false
       builderResult.optionalBool = false
       return self
  }
  var hasOptionalString:Bool {
       get {
            return builderResult.hasOptionalString
       }
  }
  var optionalString:String {
       get {
            return builderResult.optionalString
       }
       set (value) {
           builderResult.hasOptionalString = true
           builderResult.optionalString = value
       }
  }
  func clearOptionalString() -> TestAllTypesBuilder{
       builderResult.hasOptionalString = false
       builderResult.optionalString = ""
       return self
  }
  var hasOptionalBytes:Bool {
       get {
            return builderResult.hasOptionalBytes
       }
  }
  var optionalBytes:Array<Byte> {
       get {
            return builderResult.optionalBytes
       }
       set (value) {
           builderResult.hasOptionalBytes = true
           builderResult.optionalBytes = value
       }
  }
  func clearOptionalBytes() -> TestAllTypesBuilder{
       builderResult.hasOptionalBytes = false
       builderResult.optionalBytes = [Byte]()
       return self
  }
  var hasOptionalGroup:Bool {
       get {
           return builderResult.hasOptionalGroup
       }
  }
  var optionalGroup:TestAllTypes.OptionalGroup {
       get {
           return builderResult.optionalGroup
       }
       set (value) {
           builderResult.hasOptionalGroup = true
           builderResult.optionalGroup = value
       }
  }
  func setOptionalGroupBuilder(builderForValue:TestAllTypes.OptionalGroupBuilder) -> TestAllTypesBuilder {
    optionalGroup = builderForValue.build()
    return self
  }
  func mergeOptionalGroup(value:TestAllTypes.OptionalGroup) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalGroup && builderResult.optionalGroup != TestAllTypes.OptionalGroup()) {
      builderResult.optionalGroup = TestAllTypes.OptionalGroup.builderWithPrototype(builderResult.optionalGroup).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalGroup = value
    }
    builderResult.hasOptionalGroup = true
    return self
  }
  func clearOptionalGroup() -> TestAllTypesBuilder {
    builderResult.hasOptionalGroup = false
    builderResult.optionalGroup = TestAllTypes.OptionalGroup()
    return self
  }
  var hasOptionalNestedMessage:Bool {
       get {
           return builderResult.hasOptionalNestedMessage
       }
  }
  var optionalNestedMessage:TestAllTypes.NestedMessage {
       get {
           return builderResult.optionalNestedMessage
       }
       set (value) {
           builderResult.hasOptionalNestedMessage = true
           builderResult.optionalNestedMessage = value
       }
  }
  func setOptionalNestedMessageBuilder(builderForValue:TestAllTypes.NestedMessageBuilder) -> TestAllTypesBuilder {
    optionalNestedMessage = builderForValue.build()
    return self
  }
  func mergeOptionalNestedMessage(value:TestAllTypes.NestedMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalNestedMessage && builderResult.optionalNestedMessage != TestAllTypes.NestedMessage()) {
      builderResult.optionalNestedMessage = TestAllTypes.NestedMessage.builderWithPrototype(builderResult.optionalNestedMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalNestedMessage = value
    }
    builderResult.hasOptionalNestedMessage = true
    return self
  }
  func clearOptionalNestedMessage() -> TestAllTypesBuilder {
    builderResult.hasOptionalNestedMessage = false
    builderResult.optionalNestedMessage = TestAllTypes.NestedMessage()
    return self
  }
  var hasOptionalForeignMessage:Bool {
       get {
           return builderResult.hasOptionalForeignMessage
       }
  }
  var optionalForeignMessage:ForeignMessage {
       get {
           return builderResult.optionalForeignMessage
       }
       set (value) {
           builderResult.hasOptionalForeignMessage = true
           builderResult.optionalForeignMessage = value
       }
  }
  func setOptionalForeignMessageBuilder(builderForValue:ForeignMessageBuilder) -> TestAllTypesBuilder {
    optionalForeignMessage = builderForValue.build()
    return self
  }
  func mergeOptionalForeignMessage(value:ForeignMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalForeignMessage && builderResult.optionalForeignMessage != ForeignMessage()) {
      builderResult.optionalForeignMessage = ForeignMessage.builderWithPrototype(builderResult.optionalForeignMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalForeignMessage = value
    }
    builderResult.hasOptionalForeignMessage = true
    return self
  }
  func clearOptionalForeignMessage() -> TestAllTypesBuilder {
    builderResult.hasOptionalForeignMessage = false
    builderResult.optionalForeignMessage = ForeignMessage()
    return self
  }
  var hasOptionalImportMessage:Bool {
       get {
           return builderResult.hasOptionalImportMessage
       }
  }
  var optionalImportMessage:ImportMessage {
       get {
           return builderResult.optionalImportMessage
       }
       set (value) {
           builderResult.hasOptionalImportMessage = true
           builderResult.optionalImportMessage = value
       }
  }
  func setOptionalImportMessageBuilder(builderForValue:ImportMessageBuilder) -> TestAllTypesBuilder {
    optionalImportMessage = builderForValue.build()
    return self
  }
  func mergeOptionalImportMessage(value:ImportMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalImportMessage && builderResult.optionalImportMessage != ImportMessage()) {
      builderResult.optionalImportMessage = ImportMessage.builderWithPrototype(builderResult.optionalImportMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalImportMessage = value
    }
    builderResult.hasOptionalImportMessage = true
    return self
  }
  func clearOptionalImportMessage() -> TestAllTypesBuilder {
    builderResult.hasOptionalImportMessage = false
    builderResult.optionalImportMessage = ImportMessage()
    return self
  }
    var hasOptionalNestedEnum:Bool{
        get {
            return builderResult.hasOptionalNestedEnum
        }
    }
    var optionalNestedEnum:TestAllTypes.NestedEnum {
        get {
            return builderResult.optionalNestedEnum
        }
        set (value) {
            builderResult.hasOptionalNestedEnum = true
            builderResult.optionalNestedEnum = value
        }
    }
    func clearOptionalNestedEnum() -> TestAllTypesBuilder {
       builderResult.hasOptionalNestedEnum = false
       builderResult.optionalNestedEnum = .Foo
       return self
    }
    var hasOptionalForeignEnum:Bool{
        get {
            return builderResult.hasOptionalForeignEnum
        }
    }
    var optionalForeignEnum:ForeignEnum {
        get {
            return builderResult.optionalForeignEnum
        }
        set (value) {
            builderResult.hasOptionalForeignEnum = true
            builderResult.optionalForeignEnum = value
        }
    }
    func clearOptionalForeignEnum() -> TestAllTypesBuilder {
       builderResult.hasOptionalForeignEnum = false
       builderResult.optionalForeignEnum = .ForeignFoo
       return self
    }
    var hasOptionalImportEnum:Bool{
        get {
            return builderResult.hasOptionalImportEnum
        }
    }
    var optionalImportEnum:ImportEnum {
        get {
            return builderResult.optionalImportEnum
        }
        set (value) {
            builderResult.hasOptionalImportEnum = true
            builderResult.optionalImportEnum = value
        }
    }
    func clearOptionalImportEnum() -> TestAllTypesBuilder {
       builderResult.hasOptionalImportEnum = false
       builderResult.optionalImportEnum = .ImportFoo
       return self
    }
  var hasOptionalStringPiece:Bool {
       get {
            return builderResult.hasOptionalStringPiece
       }
  }
  var optionalStringPiece:String {
       get {
            return builderResult.optionalStringPiece
       }
       set (value) {
           builderResult.hasOptionalStringPiece = true
           builderResult.optionalStringPiece = value
       }
  }
  func clearOptionalStringPiece() -> TestAllTypesBuilder{
       builderResult.hasOptionalStringPiece = false
       builderResult.optionalStringPiece = ""
       return self
  }
  var hasOptionalCord:Bool {
       get {
            return builderResult.hasOptionalCord
       }
  }
  var optionalCord:String {
       get {
            return builderResult.optionalCord
       }
       set (value) {
           builderResult.hasOptionalCord = true
           builderResult.optionalCord = value
       }
  }
  func clearOptionalCord() -> TestAllTypesBuilder{
       builderResult.hasOptionalCord = false
       builderResult.optionalCord = ""
       return self
  }
  var hasOptionalPublicImportMessage:Bool {
       get {
           return builderResult.hasOptionalPublicImportMessage
       }
  }
  var optionalPublicImportMessage:PublicImportMessage {
       get {
           return builderResult.optionalPublicImportMessage
       }
       set (value) {
           builderResult.hasOptionalPublicImportMessage = true
           builderResult.optionalPublicImportMessage = value
       }
  }
  func setOptionalPublicImportMessageBuilder(builderForValue:PublicImportMessageBuilder) -> TestAllTypesBuilder {
    optionalPublicImportMessage = builderForValue.build()
    return self
  }
  func mergeOptionalPublicImportMessage(value:PublicImportMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalPublicImportMessage && builderResult.optionalPublicImportMessage != PublicImportMessage()) {
      builderResult.optionalPublicImportMessage = PublicImportMessage.builderWithPrototype(builderResult.optionalPublicImportMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalPublicImportMessage = value
    }
    builderResult.hasOptionalPublicImportMessage = true
    return self
  }
  func clearOptionalPublicImportMessage() -> TestAllTypesBuilder {
    builderResult.hasOptionalPublicImportMessage = false
    builderResult.optionalPublicImportMessage = PublicImportMessage()
    return self
  }
  var hasOptionalLazyMessage:Bool {
       get {
           return builderResult.hasOptionalLazyMessage
       }
  }
  var optionalLazyMessage:TestAllTypes.NestedMessage {
       get {
           return builderResult.optionalLazyMessage
       }
       set (value) {
           builderResult.hasOptionalLazyMessage = true
           builderResult.optionalLazyMessage = value
       }
  }
  func setOptionalLazyMessageBuilder(builderForValue:TestAllTypes.NestedMessageBuilder) -> TestAllTypesBuilder {
    optionalLazyMessage = builderForValue.build()
    return self
  }
  func mergeOptionalLazyMessage(value:TestAllTypes.NestedMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOptionalLazyMessage && builderResult.optionalLazyMessage != TestAllTypes.NestedMessage()) {
      builderResult.optionalLazyMessage = TestAllTypes.NestedMessage.builderWithPrototype(builderResult.optionalLazyMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalLazyMessage = value
    }
    builderResult.hasOptionalLazyMessage = true
    return self
  }
  func clearOptionalLazyMessage() -> TestAllTypesBuilder {
    builderResult.hasOptionalLazyMessage = false
    builderResult.optionalLazyMessage = TestAllTypes.NestedMessage()
    return self
  }
  var repeatedInt32:Array<Int32> {
       get {
           return builderResult.repeatedInt32
       }
       set (array) {
           builderResult.repeatedInt32 = array
       }
  }
  func clearRepeatedInt32() -> TestAllTypesBuilder {
     builderResult.repeatedInt32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedInt64:Array<Int64> {
       get {
           return builderResult.repeatedInt64
       }
       set (array) {
           builderResult.repeatedInt64 = array
       }
  }
  func clearRepeatedInt64() -> TestAllTypesBuilder {
     builderResult.repeatedInt64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedUint32:Array<UInt32> {
       get {
           return builderResult.repeatedUint32
       }
       set (array) {
           builderResult.repeatedUint32 = array
       }
  }
  func clearRepeatedUint32() -> TestAllTypesBuilder {
     builderResult.repeatedUint32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedUint64:Array<UInt64> {
       get {
           return builderResult.repeatedUint64
       }
       set (array) {
           builderResult.repeatedUint64 = array
       }
  }
  func clearRepeatedUint64() -> TestAllTypesBuilder {
     builderResult.repeatedUint64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedSint32:Array<Int32> {
       get {
           return builderResult.repeatedSint32
       }
       set (array) {
           builderResult.repeatedSint32 = array
       }
  }
  func clearRepeatedSint32() -> TestAllTypesBuilder {
     builderResult.repeatedSint32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedSint64:Array<Int64> {
       get {
           return builderResult.repeatedSint64
       }
       set (array) {
           builderResult.repeatedSint64 = array
       }
  }
  func clearRepeatedSint64() -> TestAllTypesBuilder {
     builderResult.repeatedSint64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedFixed32:Array<UInt32> {
       get {
           return builderResult.repeatedFixed32
       }
       set (array) {
           builderResult.repeatedFixed32 = array
       }
  }
  func clearRepeatedFixed32() -> TestAllTypesBuilder {
     builderResult.repeatedFixed32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedFixed64:Array<UInt64> {
       get {
           return builderResult.repeatedFixed64
       }
       set (array) {
           builderResult.repeatedFixed64 = array
       }
  }
  func clearRepeatedFixed64() -> TestAllTypesBuilder {
     builderResult.repeatedFixed64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedSfixed32:Array<Int32> {
       get {
           return builderResult.repeatedSfixed32
       }
       set (array) {
           builderResult.repeatedSfixed32 = array
       }
  }
  func clearRepeatedSfixed32() -> TestAllTypesBuilder {
     builderResult.repeatedSfixed32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedSfixed64:Array<Int64> {
       get {
           return builderResult.repeatedSfixed64
       }
       set (array) {
           builderResult.repeatedSfixed64 = array
       }
  }
  func clearRepeatedSfixed64() -> TestAllTypesBuilder {
     builderResult.repeatedSfixed64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedFloat:Array<Float> {
       get {
           return builderResult.repeatedFloat
       }
       set (array) {
           builderResult.repeatedFloat = array
       }
  }
  func clearRepeatedFloat() -> TestAllTypesBuilder {
     builderResult.repeatedFloat.removeAll(keepCapacity: false)
     return self
  }
  var repeatedDouble:Array<Double> {
       get {
           return builderResult.repeatedDouble
       }
       set (array) {
           builderResult.repeatedDouble = array
       }
  }
  func clearRepeatedDouble() -> TestAllTypesBuilder {
     builderResult.repeatedDouble.removeAll(keepCapacity: false)
     return self
  }
  var repeatedBool:Array<Bool> {
       get {
           return builderResult.repeatedBool
       }
       set (array) {
           builderResult.repeatedBool = array
       }
  }
  func clearRepeatedBool() -> TestAllTypesBuilder {
     builderResult.repeatedBool.removeAll(keepCapacity: false)
     return self
  }
  var repeatedString:Array<String> {
       get {
           return builderResult.repeatedString
       }
       set (array) {
           builderResult.repeatedString = array
       }
  }
  func clearRepeatedString() -> TestAllTypesBuilder {
     builderResult.repeatedString.removeAll(keepCapacity: false)
     return self
  }
  var repeatedBytes:Array<Array<Byte>> {
       get {
           return builderResult.repeatedBytes
       }
       set (array) {
           builderResult.repeatedBytes = array
       }
  }
  func clearRepeatedBytes() -> TestAllTypesBuilder {
     builderResult.repeatedBytes.removeAll(keepCapacity: false)
     return self
  }
  var repeatedGroup:Array<TestAllTypes.RepeatedGroup> {
       get {
           return builderResult.repeatedGroup
       }
       set (value) {
           builderResult.repeatedGroup = value
       }
  }
  func clearRepeatedGroup() -> TestAllTypesBuilder {
    builderResult.repeatedGroup.removeAll(keepCapacity: false)
    return self
  }
  var repeatedNestedMessage:Array<TestAllTypes.NestedMessage> {
       get {
           return builderResult.repeatedNestedMessage
       }
       set (value) {
           builderResult.repeatedNestedMessage = value
       }
  }
  func clearRepeatedNestedMessage() -> TestAllTypesBuilder {
    builderResult.repeatedNestedMessage.removeAll(keepCapacity: false)
    return self
  }
  var repeatedForeignMessage:Array<ForeignMessage> {
       get {
           return builderResult.repeatedForeignMessage
       }
       set (value) {
           builderResult.repeatedForeignMessage = value
       }
  }
  func clearRepeatedForeignMessage() -> TestAllTypesBuilder {
    builderResult.repeatedForeignMessage.removeAll(keepCapacity: false)
    return self
  }
  var repeatedImportMessage:Array<ImportMessage> {
       get {
           return builderResult.repeatedImportMessage
       }
       set (value) {
           builderResult.repeatedImportMessage = value
       }
  }
  func clearRepeatedImportMessage() -> TestAllTypesBuilder {
    builderResult.repeatedImportMessage.removeAll(keepCapacity: false)
    return self
  }
  var repeatedNestedEnum:Array<TestAllTypes.NestedEnum> {
      get {
          return builderResult.repeatedNestedEnum
      }
      set (value) {
          builderResult.repeatedNestedEnum += value
      }
  }
  func clearRepeatedNestedEnum() -> TestAllTypesBuilder {
    builderResult.repeatedNestedEnum.removeAll(keepCapacity: false)
    return self
  }
  var repeatedForeignEnum:Array<ForeignEnum> {
      get {
          return builderResult.repeatedForeignEnum
      }
      set (value) {
          builderResult.repeatedForeignEnum += value
      }
  }
  func clearRepeatedForeignEnum() -> TestAllTypesBuilder {
    builderResult.repeatedForeignEnum.removeAll(keepCapacity: false)
    return self
  }
  var repeatedImportEnum:Array<ImportEnum> {
      get {
          return builderResult.repeatedImportEnum
      }
      set (value) {
          builderResult.repeatedImportEnum += value
      }
  }
  func clearRepeatedImportEnum() -> TestAllTypesBuilder {
    builderResult.repeatedImportEnum.removeAll(keepCapacity: false)
    return self
  }
  var repeatedStringPiece:Array<String> {
       get {
           return builderResult.repeatedStringPiece
       }
       set (array) {
           builderResult.repeatedStringPiece = array
       }
  }
  func clearRepeatedStringPiece() -> TestAllTypesBuilder {
     builderResult.repeatedStringPiece.removeAll(keepCapacity: false)
     return self
  }
  var repeatedCord:Array<String> {
       get {
           return builderResult.repeatedCord
       }
       set (array) {
           builderResult.repeatedCord = array
       }
  }
  func clearRepeatedCord() -> TestAllTypesBuilder {
     builderResult.repeatedCord.removeAll(keepCapacity: false)
     return self
  }
  var repeatedLazyMessage:Array<TestAllTypes.NestedMessage> {
       get {
           return builderResult.repeatedLazyMessage
       }
       set (value) {
           builderResult.repeatedLazyMessage = value
       }
  }
  func clearRepeatedLazyMessage() -> TestAllTypesBuilder {
    builderResult.repeatedLazyMessage.removeAll(keepCapacity: false)
    return self
  }
  var hasDefaultInt32:Bool {
       get {
            return builderResult.hasDefaultInt32
       }
  }
  var defaultInt32:Int32 {
       get {
            return builderResult.defaultInt32
       }
       set (value) {
           builderResult.hasDefaultInt32 = true
           builderResult.defaultInt32 = value
       }
  }
  func clearDefaultInt32() -> TestAllTypesBuilder{
       builderResult.hasDefaultInt32 = false
       builderResult.defaultInt32 = Int32(41)
       return self
  }
  var hasDefaultInt64:Bool {
       get {
            return builderResult.hasDefaultInt64
       }
  }
  var defaultInt64:Int64 {
       get {
            return builderResult.defaultInt64
       }
       set (value) {
           builderResult.hasDefaultInt64 = true
           builderResult.defaultInt64 = value
       }
  }
  func clearDefaultInt64() -> TestAllTypesBuilder{
       builderResult.hasDefaultInt64 = false
       builderResult.defaultInt64 = Int64(42)
       return self
  }
  var hasDefaultUint32:Bool {
       get {
            return builderResult.hasDefaultUint32
       }
  }
  var defaultUint32:UInt32 {
       get {
            return builderResult.defaultUint32
       }
       set (value) {
           builderResult.hasDefaultUint32 = true
           builderResult.defaultUint32 = value
       }
  }
  func clearDefaultUint32() -> TestAllTypesBuilder{
       builderResult.hasDefaultUint32 = false
       builderResult.defaultUint32 = UInt32(43)
       return self
  }
  var hasDefaultUint64:Bool {
       get {
            return builderResult.hasDefaultUint64
       }
  }
  var defaultUint64:UInt64 {
       get {
            return builderResult.defaultUint64
       }
       set (value) {
           builderResult.hasDefaultUint64 = true
           builderResult.defaultUint64 = value
       }
  }
  func clearDefaultUint64() -> TestAllTypesBuilder{
       builderResult.hasDefaultUint64 = false
       builderResult.defaultUint64 = UInt64(44)
       return self
  }
  var hasDefaultSint32:Bool {
       get {
            return builderResult.hasDefaultSint32
       }
  }
  var defaultSint32:Int32 {
       get {
            return builderResult.defaultSint32
       }
       set (value) {
           builderResult.hasDefaultSint32 = true
           builderResult.defaultSint32 = value
       }
  }
  func clearDefaultSint32() -> TestAllTypesBuilder{
       builderResult.hasDefaultSint32 = false
       builderResult.defaultSint32 = Int32(-45)
       return self
  }
  var hasDefaultSint64:Bool {
       get {
            return builderResult.hasDefaultSint64
       }
  }
  var defaultSint64:Int64 {
       get {
            return builderResult.defaultSint64
       }
       set (value) {
           builderResult.hasDefaultSint64 = true
           builderResult.defaultSint64 = value
       }
  }
  func clearDefaultSint64() -> TestAllTypesBuilder{
       builderResult.hasDefaultSint64 = false
       builderResult.defaultSint64 = Int64(46)
       return self
  }
  var hasDefaultFixed32:Bool {
       get {
            return builderResult.hasDefaultFixed32
       }
  }
  var defaultFixed32:UInt32 {
       get {
            return builderResult.defaultFixed32
       }
       set (value) {
           builderResult.hasDefaultFixed32 = true
           builderResult.defaultFixed32 = value
       }
  }
  func clearDefaultFixed32() -> TestAllTypesBuilder{
       builderResult.hasDefaultFixed32 = false
       builderResult.defaultFixed32 = UInt32(47)
       return self
  }
  var hasDefaultFixed64:Bool {
       get {
            return builderResult.hasDefaultFixed64
       }
  }
  var defaultFixed64:UInt64 {
       get {
            return builderResult.defaultFixed64
       }
       set (value) {
           builderResult.hasDefaultFixed64 = true
           builderResult.defaultFixed64 = value
       }
  }
  func clearDefaultFixed64() -> TestAllTypesBuilder{
       builderResult.hasDefaultFixed64 = false
       builderResult.defaultFixed64 = UInt64(48)
       return self
  }
  var hasDefaultSfixed32:Bool {
       get {
            return builderResult.hasDefaultSfixed32
       }
  }
  var defaultSfixed32:Int32 {
       get {
            return builderResult.defaultSfixed32
       }
       set (value) {
           builderResult.hasDefaultSfixed32 = true
           builderResult.defaultSfixed32 = value
       }
  }
  func clearDefaultSfixed32() -> TestAllTypesBuilder{
       builderResult.hasDefaultSfixed32 = false
       builderResult.defaultSfixed32 = Int32(49)
       return self
  }
  var hasDefaultSfixed64:Bool {
       get {
            return builderResult.hasDefaultSfixed64
       }
  }
  var defaultSfixed64:Int64 {
       get {
            return builderResult.defaultSfixed64
       }
       set (value) {
           builderResult.hasDefaultSfixed64 = true
           builderResult.defaultSfixed64 = value
       }
  }
  func clearDefaultSfixed64() -> TestAllTypesBuilder{
       builderResult.hasDefaultSfixed64 = false
       builderResult.defaultSfixed64 = Int64(-50)
       return self
  }
  var hasDefaultFloat:Bool {
       get {
            return builderResult.hasDefaultFloat
       }
  }
  var defaultFloat:Float {
       get {
            return builderResult.defaultFloat
       }
       set (value) {
           builderResult.hasDefaultFloat = true
           builderResult.defaultFloat = value
       }
  }
  func clearDefaultFloat() -> TestAllTypesBuilder{
       builderResult.hasDefaultFloat = false
       builderResult.defaultFloat = Float(51.5)
       return self
  }
  var hasDefaultDouble:Bool {
       get {
            return builderResult.hasDefaultDouble
       }
  }
  var defaultDouble:Double {
       get {
            return builderResult.defaultDouble
       }
       set (value) {
           builderResult.hasDefaultDouble = true
           builderResult.defaultDouble = value
       }
  }
  func clearDefaultDouble() -> TestAllTypesBuilder{
       builderResult.hasDefaultDouble = false
       builderResult.defaultDouble = Double(52000)
       return self
  }
  var hasDefaultBool:Bool {
       get {
            return builderResult.hasDefaultBool
       }
  }
  var defaultBool:Bool {
       get {
            return builderResult.defaultBool
       }
       set (value) {
           builderResult.hasDefaultBool = true
           builderResult.defaultBool = value
       }
  }
  func clearDefaultBool() -> TestAllTypesBuilder{
       builderResult.hasDefaultBool = false
       builderResult.defaultBool = true
       return self
  }
  var hasDefaultString:Bool {
       get {
            return builderResult.hasDefaultString
       }
  }
  var defaultString:String {
       get {
            return builderResult.defaultString
       }
       set (value) {
           builderResult.hasDefaultString = true
           builderResult.defaultString = value
       }
  }
  func clearDefaultString() -> TestAllTypesBuilder{
       builderResult.hasDefaultString = false
       builderResult.defaultString = "hello"
       return self
  }
  var hasDefaultBytes:Bool {
       get {
            return builderResult.hasDefaultBytes
       }
  }
  var defaultBytes:Array<Byte> {
       get {
            return builderResult.defaultBytes
       }
       set (value) {
           builderResult.hasDefaultBytes = true
           builderResult.defaultBytes = value
       }
  }
  func clearDefaultBytes() -> TestAllTypesBuilder{
       builderResult.hasDefaultBytes = false
       builderResult.defaultBytes = ([Byte]() + "world".utf8)
       return self
  }
    var hasDefaultNestedEnum:Bool{
        get {
            return builderResult.hasDefaultNestedEnum
        }
    }
    var defaultNestedEnum:TestAllTypes.NestedEnum {
        get {
            return builderResult.defaultNestedEnum
        }
        set (value) {
            builderResult.hasDefaultNestedEnum = true
            builderResult.defaultNestedEnum = value
        }
    }
    func clearDefaultNestedEnum() -> TestAllTypesBuilder {
       builderResult.hasDefaultNestedEnum = false
       builderResult.defaultNestedEnum = .Bar
       return self
    }
    var hasDefaultForeignEnum:Bool{
        get {
            return builderResult.hasDefaultForeignEnum
        }
    }
    var defaultForeignEnum:ForeignEnum {
        get {
            return builderResult.defaultForeignEnum
        }
        set (value) {
            builderResult.hasDefaultForeignEnum = true
            builderResult.defaultForeignEnum = value
        }
    }
    func clearDefaultForeignEnum() -> TestAllTypesBuilder {
       builderResult.hasDefaultForeignEnum = false
       builderResult.defaultForeignEnum = .ForeignBar
       return self
    }
    var hasDefaultImportEnum:Bool{
        get {
            return builderResult.hasDefaultImportEnum
        }
    }
    var defaultImportEnum:ImportEnum {
        get {
            return builderResult.defaultImportEnum
        }
        set (value) {
            builderResult.hasDefaultImportEnum = true
            builderResult.defaultImportEnum = value
        }
    }
    func clearDefaultImportEnum() -> TestAllTypesBuilder {
       builderResult.hasDefaultImportEnum = false
       builderResult.defaultImportEnum = .ImportBar
       return self
    }
  var hasDefaultStringPiece:Bool {
       get {
            return builderResult.hasDefaultStringPiece
       }
  }
  var defaultStringPiece:String {
       get {
            return builderResult.defaultStringPiece
       }
       set (value) {
           builderResult.hasDefaultStringPiece = true
           builderResult.defaultStringPiece = value
       }
  }
  func clearDefaultStringPiece() -> TestAllTypesBuilder{
       builderResult.hasDefaultStringPiece = false
       builderResult.defaultStringPiece = "abc"
       return self
  }
  var hasDefaultCord:Bool {
       get {
            return builderResult.hasDefaultCord
       }
  }
  var defaultCord:String {
       get {
            return builderResult.defaultCord
       }
       set (value) {
           builderResult.hasDefaultCord = true
           builderResult.defaultCord = value
       }
  }
  func clearDefaultCord() -> TestAllTypesBuilder{
       builderResult.hasDefaultCord = false
       builderResult.defaultCord = "123"
       return self
  }
  var hasOneofUint32:Bool {
       get {
            return builderResult.hasOneofUint32
       }
  }
  var oneofUint32:UInt32 {
       get {
            return builderResult.oneofUint32
       }
       set (value) {
           builderResult.hasOneofUint32 = true
           builderResult.oneofUint32 = value
       }
  }
  func clearOneofUint32() -> TestAllTypesBuilder{
       builderResult.hasOneofUint32 = false
       builderResult.oneofUint32 = UInt32(0)
       return self
  }
  var hasOneofNestedMessage:Bool {
       get {
           return builderResult.hasOneofNestedMessage
       }
  }
  var oneofNestedMessage:TestAllTypes.NestedMessage {
       get {
           return builderResult.oneofNestedMessage
       }
       set (value) {
           builderResult.hasOneofNestedMessage = true
           builderResult.oneofNestedMessage = value
       }
  }
  func setOneofNestedMessageBuilder(builderForValue:TestAllTypes.NestedMessageBuilder) -> TestAllTypesBuilder {
    oneofNestedMessage = builderForValue.build()
    return self
  }
  func mergeOneofNestedMessage(value:TestAllTypes.NestedMessage) -> TestAllTypesBuilder {
    if (builderResult.hasOneofNestedMessage && builderResult.oneofNestedMessage != TestAllTypes.NestedMessage()) {
      builderResult.oneofNestedMessage = TestAllTypes.NestedMessage.builderWithPrototype(builderResult.oneofNestedMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.oneofNestedMessage = value
    }
    builderResult.hasOneofNestedMessage = true
    return self
  }
  func clearOneofNestedMessage() -> TestAllTypesBuilder {
    builderResult.hasOneofNestedMessage = false
    builderResult.oneofNestedMessage = TestAllTypes.NestedMessage()
    return self
  }
  var hasOneofString:Bool {
       get {
            return builderResult.hasOneofString
       }
  }
  var oneofString:String {
       get {
            return builderResult.oneofString
       }
       set (value) {
           builderResult.hasOneofString = true
           builderResult.oneofString = value
       }
  }
  func clearOneofString() -> TestAllTypesBuilder{
       builderResult.hasOneofString = false
       builderResult.oneofString = ""
       return self
  }
  var hasOneofBytes:Bool {
       get {
            return builderResult.hasOneofBytes
       }
  }
  var oneofBytes:Array<Byte> {
       get {
            return builderResult.oneofBytes
       }
       set (value) {
           builderResult.hasOneofBytes = true
           builderResult.oneofBytes = value
       }
  }
  func clearOneofBytes() -> TestAllTypesBuilder{
       builderResult.hasOneofBytes = false
       builderResult.oneofBytes = [Byte]()
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestAllTypesBuilder {
    builderResult = TestAllTypes()
    return self
  }
  override func clone() -> TestAllTypesBuilder {
    return TestAllTypes.builderWithPrototype(builderResult)
  }
  override func build() -> TestAllTypes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestAllTypes {
    var returnMe:TestAllTypes = builderResult
    return returnMe
  }
  func mergeFrom(other:TestAllTypes) -> TestAllTypesBuilder {
    if (other == TestAllTypes()) {
     return self
    }
    if other.hasOptionalInt32 {
         optionalInt32 = other.optionalInt32
    }
    if other.hasOptionalInt64 {
         optionalInt64 = other.optionalInt64
    }
    if other.hasOptionalUint32 {
         optionalUint32 = other.optionalUint32
    }
    if other.hasOptionalUint64 {
         optionalUint64 = other.optionalUint64
    }
    if other.hasOptionalSint32 {
         optionalSint32 = other.optionalSint32
    }
    if other.hasOptionalSint64 {
         optionalSint64 = other.optionalSint64
    }
    if other.hasOptionalFixed32 {
         optionalFixed32 = other.optionalFixed32
    }
    if other.hasOptionalFixed64 {
         optionalFixed64 = other.optionalFixed64
    }
    if other.hasOptionalSfixed32 {
         optionalSfixed32 = other.optionalSfixed32
    }
    if other.hasOptionalSfixed64 {
         optionalSfixed64 = other.optionalSfixed64
    }
    if other.hasOptionalFloat {
         optionalFloat = other.optionalFloat
    }
    if other.hasOptionalDouble {
         optionalDouble = other.optionalDouble
    }
    if other.hasOptionalBool {
         optionalBool = other.optionalBool
    }
    if other.hasOptionalString {
         optionalString = other.optionalString
    }
    if other.hasOptionalBytes {
         optionalBytes = other.optionalBytes
    }
    if (other.hasOptionalGroup) {
        mergeOptionalGroup(other.optionalGroup)
    }
    if (other.hasOptionalNestedMessage) {
        mergeOptionalNestedMessage(other.optionalNestedMessage)
    }
    if (other.hasOptionalForeignMessage) {
        mergeOptionalForeignMessage(other.optionalForeignMessage)
    }
    if (other.hasOptionalImportMessage) {
        mergeOptionalImportMessage(other.optionalImportMessage)
    }
    if other.hasOptionalNestedEnum {
         optionalNestedEnum = other.optionalNestedEnum
    }
    if other.hasOptionalForeignEnum {
         optionalForeignEnum = other.optionalForeignEnum
    }
    if other.hasOptionalImportEnum {
         optionalImportEnum = other.optionalImportEnum
    }
    if other.hasOptionalStringPiece {
         optionalStringPiece = other.optionalStringPiece
    }
    if other.hasOptionalCord {
         optionalCord = other.optionalCord
    }
    if (other.hasOptionalPublicImportMessage) {
        mergeOptionalPublicImportMessage(other.optionalPublicImportMessage)
    }
    if (other.hasOptionalLazyMessage) {
        mergeOptionalLazyMessage(other.optionalLazyMessage)
    }
    if !other.repeatedInt32.isEmpty {
        builderResult.repeatedInt32 += other.repeatedInt32
    }
    if !other.repeatedInt64.isEmpty {
        builderResult.repeatedInt64 += other.repeatedInt64
    }
    if !other.repeatedUint32.isEmpty {
        builderResult.repeatedUint32 += other.repeatedUint32
    }
    if !other.repeatedUint64.isEmpty {
        builderResult.repeatedUint64 += other.repeatedUint64
    }
    if !other.repeatedSint32.isEmpty {
        builderResult.repeatedSint32 += other.repeatedSint32
    }
    if !other.repeatedSint64.isEmpty {
        builderResult.repeatedSint64 += other.repeatedSint64
    }
    if !other.repeatedFixed32.isEmpty {
        builderResult.repeatedFixed32 += other.repeatedFixed32
    }
    if !other.repeatedFixed64.isEmpty {
        builderResult.repeatedFixed64 += other.repeatedFixed64
    }
    if !other.repeatedSfixed32.isEmpty {
        builderResult.repeatedSfixed32 += other.repeatedSfixed32
    }
    if !other.repeatedSfixed64.isEmpty {
        builderResult.repeatedSfixed64 += other.repeatedSfixed64
    }
    if !other.repeatedFloat.isEmpty {
        builderResult.repeatedFloat += other.repeatedFloat
    }
    if !other.repeatedDouble.isEmpty {
        builderResult.repeatedDouble += other.repeatedDouble
    }
    if !other.repeatedBool.isEmpty {
        builderResult.repeatedBool += other.repeatedBool
    }
    if !other.repeatedString.isEmpty {
        builderResult.repeatedString += other.repeatedString
    }
    if !other.repeatedBytes.isEmpty {
        builderResult.repeatedBytes += other.repeatedBytes
    }
    if !other.repeatedGroup.isEmpty  {
       builderResult.repeatedGroup += other.repeatedGroup
    }
    if !other.repeatedNestedMessage.isEmpty  {
       builderResult.repeatedNestedMessage += other.repeatedNestedMessage
    }
    if !other.repeatedForeignMessage.isEmpty  {
       builderResult.repeatedForeignMessage += other.repeatedForeignMessage
    }
    if !other.repeatedImportMessage.isEmpty  {
       builderResult.repeatedImportMessage += other.repeatedImportMessage
    }
    if !other.repeatedNestedEnum.isEmpty {
       builderResult.repeatedNestedEnum += other.repeatedNestedEnum
    }
    if !other.repeatedForeignEnum.isEmpty {
       builderResult.repeatedForeignEnum += other.repeatedForeignEnum
    }
    if !other.repeatedImportEnum.isEmpty {
       builderResult.repeatedImportEnum += other.repeatedImportEnum
    }
    if !other.repeatedStringPiece.isEmpty {
        builderResult.repeatedStringPiece += other.repeatedStringPiece
    }
    if !other.repeatedCord.isEmpty {
        builderResult.repeatedCord += other.repeatedCord
    }
    if !other.repeatedLazyMessage.isEmpty  {
       builderResult.repeatedLazyMessage += other.repeatedLazyMessage
    }
    if other.hasDefaultInt32 {
         defaultInt32 = other.defaultInt32
    }
    if other.hasDefaultInt64 {
         defaultInt64 = other.defaultInt64
    }
    if other.hasDefaultUint32 {
         defaultUint32 = other.defaultUint32
    }
    if other.hasDefaultUint64 {
         defaultUint64 = other.defaultUint64
    }
    if other.hasDefaultSint32 {
         defaultSint32 = other.defaultSint32
    }
    if other.hasDefaultSint64 {
         defaultSint64 = other.defaultSint64
    }
    if other.hasDefaultFixed32 {
         defaultFixed32 = other.defaultFixed32
    }
    if other.hasDefaultFixed64 {
         defaultFixed64 = other.defaultFixed64
    }
    if other.hasDefaultSfixed32 {
         defaultSfixed32 = other.defaultSfixed32
    }
    if other.hasDefaultSfixed64 {
         defaultSfixed64 = other.defaultSfixed64
    }
    if other.hasDefaultFloat {
         defaultFloat = other.defaultFloat
    }
    if other.hasDefaultDouble {
         defaultDouble = other.defaultDouble
    }
    if other.hasDefaultBool {
         defaultBool = other.defaultBool
    }
    if other.hasDefaultString {
         defaultString = other.defaultString
    }
    if other.hasDefaultBytes {
         defaultBytes = other.defaultBytes
    }
    if other.hasDefaultNestedEnum {
         defaultNestedEnum = other.defaultNestedEnum
    }
    if other.hasDefaultForeignEnum {
         defaultForeignEnum = other.defaultForeignEnum
    }
    if other.hasDefaultImportEnum {
         defaultImportEnum = other.defaultImportEnum
    }
    if other.hasDefaultStringPiece {
         defaultStringPiece = other.defaultStringPiece
    }
    if other.hasDefaultCord {
         defaultCord = other.defaultCord
    }
    if other.hasOneofUint32 {
         oneofUint32 = other.oneofUint32
    }
    if (other.hasOneofNestedMessage) {
        mergeOneofNestedMessage(other.oneofNestedMessage)
    }
    if other.hasOneofString {
         oneofString = other.oneofString
    }
    if other.hasOneofBytes {
         oneofBytes = other.oneofBytes
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestAllTypesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllTypesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        optionalInt32 = input.readInt32()

      case 16 :
        optionalInt64 = input.readInt64()

      case 24 :
        optionalUint32 = input.readUInt32()

      case 32 :
        optionalUint64 = input.readUInt64()

      case 40 :
        optionalSint32 = input.readSInt32()

      case 48 :
        optionalSint64 = input.readSInt64()

      case 61 :
        optionalFixed32 = input.readFixed32()

      case 65 :
        optionalFixed64 = input.readFixed64()

      case 77 :
        optionalSfixed32 = input.readSFixed32()

      case 81 :
        optionalSfixed64 = input.readSFixed64()

      case 93 :
        optionalFloat = input.readFloat()

      case 97 :
        optionalDouble = input.readDouble()

      case 104 :
        optionalBool = input.readBool()

      case 114 :
        optionalString = input.readString()

      case 122 :
        optionalBytes = input.readData()

      case 131 :
        var subBuilder:TestAllTypes.OptionalGroupBuilder = TestAllTypes.OptionalGroup.builder()
        if hasOptionalGroup {
          subBuilder.mergeFrom(optionalGroup)
        }
        input.readGroup(16, builder:subBuilder, extensionRegistry:extensionRegistry)
        optionalGroup = subBuilder.buildPartial()

      case 146 :
        var subBuilder:TestAllTypes.NestedMessageBuilder = TestAllTypes.NestedMessage.builder()
        if hasOptionalNestedMessage {
          subBuilder.mergeFrom(optionalNestedMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalNestedMessage = subBuilder.buildPartial()

      case 154 :
        var subBuilder:ForeignMessageBuilder = ForeignMessage.builder()
        if hasOptionalForeignMessage {
          subBuilder.mergeFrom(optionalForeignMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalForeignMessage = subBuilder.buildPartial()

      case 162 :
        var subBuilder:ImportMessageBuilder = ImportMessage.builder()
        if hasOptionalImportMessage {
          subBuilder.mergeFrom(optionalImportMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalImportMessage = subBuilder.buildPartial()

      case 168 :
        var value = input.readEnum()
        var enumMergResult:TestAllTypes.NestedEnum = TestAllTypes.NestedEnum(rawValue:value)!
        if (TestAllTypes.NestedEnum.IsValidValue(enumMergResult)) {
             optionalNestedEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(21, value:Int64(value))
        }

      case 176 :
        var value = input.readEnum()
        var enumMergResult:ForeignEnum = ForeignEnum(rawValue:value)!
        if (ForeignEnum.IsValidValue(enumMergResult)) {
             optionalForeignEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(22, value:Int64(value))
        }

      case 184 :
        var value = input.readEnum()
        var enumMergResult:ImportEnum = ImportEnum(rawValue:value)!
        if (ImportEnum.IsValidValue(enumMergResult)) {
             optionalImportEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(23, value:Int64(value))
        }

      case 194 :
        optionalStringPiece = input.readString()

      case 202 :
        optionalCord = input.readString()

      case 210 :
        var subBuilder:PublicImportMessageBuilder = PublicImportMessage.builder()
        if hasOptionalPublicImportMessage {
          subBuilder.mergeFrom(optionalPublicImportMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalPublicImportMessage = subBuilder.buildPartial()

      case 218 :
        var subBuilder:TestAllTypes.NestedMessageBuilder = TestAllTypes.NestedMessage.builder()
        if hasOptionalLazyMessage {
          subBuilder.mergeFrom(optionalLazyMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalLazyMessage = subBuilder.buildPartial()

      case 248 :
        repeatedInt32 += [input.readInt32()]

      case 256 :
        repeatedInt64 += [input.readInt64()]

      case 264 :
        repeatedUint32 += [input.readUInt32()]

      case 272 :
        repeatedUint64 += [input.readUInt64()]

      case 280 :
        repeatedSint32 += [input.readSInt32()]

      case 288 :
        repeatedSint64 += [input.readSInt64()]

      case 301 :
        repeatedFixed32 += [input.readFixed32()]

      case 305 :
        repeatedFixed64 += [input.readFixed64()]

      case 317 :
        repeatedSfixed32 += [input.readSFixed32()]

      case 321 :
        repeatedSfixed64 += [input.readSFixed64()]

      case 333 :
        repeatedFloat += [input.readFloat()]

      case 337 :
        repeatedDouble += [input.readDouble()]

      case 344 :
        repeatedBool += [input.readBool()]

      case 354 :
        repeatedString += [input.readString()]

      case 362 :
        repeatedBytes += [input.readData()]

      case 371 :
        var subBuilder = TestAllTypes.RepeatedGroup.builder()
        input.readGroup(46,builder:subBuilder,extensionRegistry:extensionRegistry)
        repeatedGroup += [subBuilder.buildPartial()]

      case 386 :
        var subBuilder = TestAllTypes.NestedMessage.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedNestedMessage += [subBuilder.buildPartial()]

      case 394 :
        var subBuilder = ForeignMessage.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedForeignMessage += [subBuilder.buildPartial()]

      case 402 :
        var subBuilder = ImportMessage.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedImportMessage += [subBuilder.buildPartial()]

      case 408 :
        var value:TestAllTypes.NestedEnum = TestAllTypes.NestedEnum(rawValue:input.readEnum())!
        if TestAllTypes.NestedEnum.IsValidValue(value) {
             builderResult.repeatedNestedEnum += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(51, value:Int64(value.rawValue))
        }

      case 416 :
        var value:ForeignEnum = ForeignEnum(rawValue:input.readEnum())!
        if ForeignEnum.IsValidValue(value) {
             builderResult.repeatedForeignEnum += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(52, value:Int64(value.rawValue))
        }

      case 424 :
        var value:ImportEnum = ImportEnum(rawValue:input.readEnum())!
        if ImportEnum.IsValidValue(value) {
             builderResult.repeatedImportEnum += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(53, value:Int64(value.rawValue))
        }

      case 434 :
        repeatedStringPiece += [input.readString()]

      case 442 :
        repeatedCord += [input.readString()]

      case 458 :
        var subBuilder = TestAllTypes.NestedMessage.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedLazyMessage += [subBuilder.buildPartial()]

      case 488 :
        defaultInt32 = input.readInt32()

      case 496 :
        defaultInt64 = input.readInt64()

      case 504 :
        defaultUint32 = input.readUInt32()

      case 512 :
        defaultUint64 = input.readUInt64()

      case 520 :
        defaultSint32 = input.readSInt32()

      case 528 :
        defaultSint64 = input.readSInt64()

      case 541 :
        defaultFixed32 = input.readFixed32()

      case 545 :
        defaultFixed64 = input.readFixed64()

      case 557 :
        defaultSfixed32 = input.readSFixed32()

      case 561 :
        defaultSfixed64 = input.readSFixed64()

      case 573 :
        defaultFloat = input.readFloat()

      case 577 :
        defaultDouble = input.readDouble()

      case 584 :
        defaultBool = input.readBool()

      case 594 :
        defaultString = input.readString()

      case 602 :
        defaultBytes = input.readData()

      case 648 :
        var value = input.readEnum()
        var enumMergResult:TestAllTypes.NestedEnum = TestAllTypes.NestedEnum(rawValue:value)!
        if (TestAllTypes.NestedEnum.IsValidValue(enumMergResult)) {
             defaultNestedEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(81, value:Int64(value))
        }

      case 656 :
        var value = input.readEnum()
        var enumMergResult:ForeignEnum = ForeignEnum(rawValue:value)!
        if (ForeignEnum.IsValidValue(enumMergResult)) {
             defaultForeignEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(82, value:Int64(value))
        }

      case 664 :
        var value = input.readEnum()
        var enumMergResult:ImportEnum = ImportEnum(rawValue:value)!
        if (ImportEnum.IsValidValue(enumMergResult)) {
             defaultImportEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(83, value:Int64(value))
        }

      case 674 :
        defaultStringPiece = input.readString()

      case 682 :
        defaultCord = input.readString()

      case 888 :
        oneofUint32 = input.readUInt32()

      case 898 :
        var subBuilder:TestAllTypes.NestedMessageBuilder = TestAllTypes.NestedMessage.builder()
        if hasOneofNestedMessage {
          subBuilder.mergeFrom(oneofNestedMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        oneofNestedMessage = subBuilder.buildPartial()

      case 906 :
        oneofString = input.readString()

      case 914 :
        oneofBytes = input.readData()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class NestedTestAllTypes : GeneratedMessage {
  private(set) var hasChild:Bool = false
  private(set) var child:NestedTestAllTypes = NestedTestAllTypes()
  private(set) var hasPayload:Bool = false
  private(set) var payload:TestAllTypes = TestAllTypes()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasChild {
      output.writeMessage(1, value:child)
    }
    if hasPayload {
      output.writeMessage(2, value:payload)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasChild {
      size += WireFormat.computeMessageSize(1, value:child)
    }
    if hasPayload {
      size += WireFormat.computeMessageSize(2, value:payload)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> NestedTestAllTypes {
    return NestedTestAllTypes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> NestedTestAllTypesBuilder {
    return NestedTestAllTypesBuilder()
  }
  class func builderWithPrototype(prototype:NestedTestAllTypes) -> NestedTestAllTypesBuilder {
    return NestedTestAllTypes.builder().mergeFrom(prototype)
  }
  func builder() -> NestedTestAllTypesBuilder {
    return NestedTestAllTypes.builder()
  }
  func toBuilder() -> NestedTestAllTypesBuilder {
    return NestedTestAllTypes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasChild {
      output += "\(indent) child {\n"
      child.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasPayload {
      output += "\(indent) payload {\n"
      payload.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasChild {
            hashCode = (hashCode &* 31) &+ child.hashValue
          }
          if hasPayload {
            hashCode = (hashCode &* 31) &+ payload.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NestedTestAllTypes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return NestedTestAllTypes.self
  }


  //Meta information declaration end

}

final class NestedTestAllTypesBuilder : GeneratedMessageBuilder {
  private var builderResult:NestedTestAllTypes

  required override init () {
     builderResult = NestedTestAllTypes()
     super.init()
  }
  var hasChild:Bool {
       get {
           return builderResult.hasChild
       }
  }
  var child:NestedTestAllTypes {
       get {
           return builderResult.child
       }
       set (value) {
           builderResult.hasChild = true
           builderResult.child = value
       }
  }
  func setChildBuilder(builderForValue:NestedTestAllTypesBuilder) -> NestedTestAllTypesBuilder {
    child = builderForValue.build()
    return self
  }
  func mergeChild(value:NestedTestAllTypes) -> NestedTestAllTypesBuilder {
    if (builderResult.hasChild && builderResult.child != NestedTestAllTypes()) {
      builderResult.child = NestedTestAllTypes.builderWithPrototype(builderResult.child).mergeFrom(value).buildPartial()
    } else {
      builderResult.child = value
    }
    builderResult.hasChild = true
    return self
  }
  func clearChild() -> NestedTestAllTypesBuilder {
    builderResult.hasChild = false
    builderResult.child = NestedTestAllTypes()
    return self
  }
  var hasPayload:Bool {
       get {
           return builderResult.hasPayload
       }
  }
  var payload:TestAllTypes {
       get {
           return builderResult.payload
       }
       set (value) {
           builderResult.hasPayload = true
           builderResult.payload = value
       }
  }
  func setPayloadBuilder(builderForValue:TestAllTypesBuilder) -> NestedTestAllTypesBuilder {
    payload = builderForValue.build()
    return self
  }
  func mergePayload(value:TestAllTypes) -> NestedTestAllTypesBuilder {
    if (builderResult.hasPayload && builderResult.payload != TestAllTypes()) {
      builderResult.payload = TestAllTypes.builderWithPrototype(builderResult.payload).mergeFrom(value).buildPartial()
    } else {
      builderResult.payload = value
    }
    builderResult.hasPayload = true
    return self
  }
  func clearPayload() -> NestedTestAllTypesBuilder {
    builderResult.hasPayload = false
    builderResult.payload = TestAllTypes()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> NestedTestAllTypesBuilder {
    builderResult = NestedTestAllTypes()
    return self
  }
  override func clone() -> NestedTestAllTypesBuilder {
    return NestedTestAllTypes.builderWithPrototype(builderResult)
  }
  override func build() -> NestedTestAllTypes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> NestedTestAllTypes {
    var returnMe:NestedTestAllTypes = builderResult
    return returnMe
  }
  func mergeFrom(other:NestedTestAllTypes) -> NestedTestAllTypesBuilder {
    if (other == NestedTestAllTypes()) {
     return self
    }
    if (other.hasChild) {
        mergeChild(other.child)
    }
    if (other.hasPayload) {
        mergePayload(other.payload)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->NestedTestAllTypesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> NestedTestAllTypesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:NestedTestAllTypesBuilder = NestedTestAllTypes.builder()
        if hasChild {
          subBuilder.mergeFrom(child)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        child = subBuilder.buildPartial()

      case 18 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasPayload {
          subBuilder.mergeFrom(payload)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        payload = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestDeprecatedFields : GeneratedMessage {
  private(set) var hasDeprecatedInt32:Bool = false
  private(set) var deprecatedInt32:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasDeprecatedInt32 {
      output.writeInt32(1, value:deprecatedInt32)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasDeprecatedInt32 {
      size += WireFormat.computeInt32Size(1, value:deprecatedInt32)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDeprecatedFields {
    return TestDeprecatedFields.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestDeprecatedFieldsBuilder {
    return TestDeprecatedFieldsBuilder()
  }
  class func builderWithPrototype(prototype:TestDeprecatedFields) -> TestDeprecatedFieldsBuilder {
    return TestDeprecatedFields.builder().mergeFrom(prototype)
  }
  func builder() -> TestDeprecatedFieldsBuilder {
    return TestDeprecatedFields.builder()
  }
  func toBuilder() -> TestDeprecatedFieldsBuilder {
    return TestDeprecatedFields.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasDeprecatedInt32 {
      output += "\(indent) deprecatedInt32: \(deprecatedInt32) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasDeprecatedInt32 {
             hashCode = (hashCode &* 31) &+ deprecatedInt32.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestDeprecatedFields"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestDeprecatedFields.self
  }


  //Meta information declaration end

}

final class TestDeprecatedFieldsBuilder : GeneratedMessageBuilder {
  private var builderResult:TestDeprecatedFields

  required override init () {
     builderResult = TestDeprecatedFields()
     super.init()
  }
  var hasDeprecatedInt32:Bool {
       get {
            return builderResult.hasDeprecatedInt32
       }
  }
  var deprecatedInt32:Int32 {
       get {
            return builderResult.deprecatedInt32
       }
       set (value) {
           builderResult.hasDeprecatedInt32 = true
           builderResult.deprecatedInt32 = value
       }
  }
  func clearDeprecatedInt32() -> TestDeprecatedFieldsBuilder{
       builderResult.hasDeprecatedInt32 = false
       builderResult.deprecatedInt32 = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestDeprecatedFieldsBuilder {
    builderResult = TestDeprecatedFields()
    return self
  }
  override func clone() -> TestDeprecatedFieldsBuilder {
    return TestDeprecatedFields.builderWithPrototype(builderResult)
  }
  override func build() -> TestDeprecatedFields {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestDeprecatedFields {
    var returnMe:TestDeprecatedFields = builderResult
    return returnMe
  }
  func mergeFrom(other:TestDeprecatedFields) -> TestDeprecatedFieldsBuilder {
    if (other == TestDeprecatedFields()) {
     return self
    }
    if other.hasDeprecatedInt32 {
         deprecatedInt32 = other.deprecatedInt32
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDeprecatedFieldsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDeprecatedFieldsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        deprecatedInt32 = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ForeignMessage : GeneratedMessage {
  private(set) var hasC:Bool = false
  private(set) var c:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasC {
      output.writeInt32(1, value:c)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasC {
      size += WireFormat.computeInt32Size(1, value:c)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> ForeignMessage {
    return ForeignMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ForeignMessage {
    return ForeignMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> ForeignMessage {
    return ForeignMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ForeignMessage {
    return ForeignMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> ForeignMessage {
    return ForeignMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ForeignMessage {
    return ForeignMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> ForeignMessageBuilder {
    return ForeignMessageBuilder()
  }
  class func builderWithPrototype(prototype:ForeignMessage) -> ForeignMessageBuilder {
    return ForeignMessage.builder().mergeFrom(prototype)
  }
  func builder() -> ForeignMessageBuilder {
    return ForeignMessage.builder()
  }
  func toBuilder() -> ForeignMessageBuilder {
    return ForeignMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasC {
      output += "\(indent) c: \(c) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasC {
             hashCode = (hashCode &* 31) &+ c.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ForeignMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ForeignMessage.self
  }


  //Meta information declaration end

}

final class ForeignMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:ForeignMessage

  required override init () {
     builderResult = ForeignMessage()
     super.init()
  }
  var hasC:Bool {
       get {
            return builderResult.hasC
       }
  }
  var c:Int32 {
       get {
            return builderResult.c
       }
       set (value) {
           builderResult.hasC = true
           builderResult.c = value
       }
  }
  func clearC() -> ForeignMessageBuilder{
       builderResult.hasC = false
       builderResult.c = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> ForeignMessageBuilder {
    builderResult = ForeignMessage()
    return self
  }
  override func clone() -> ForeignMessageBuilder {
    return ForeignMessage.builderWithPrototype(builderResult)
  }
  override func build() -> ForeignMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> ForeignMessage {
    var returnMe:ForeignMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:ForeignMessage) -> ForeignMessageBuilder {
    if (other == ForeignMessage()) {
     return self
    }
    if other.hasC {
         c = other.c
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->ForeignMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ForeignMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        c = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestAllExtensions : ExtendableMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestAllExtensions {
    return TestAllExtensions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestAllExtensions {
    return TestAllExtensions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestAllExtensions {
    return TestAllExtensions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestAllExtensions {
    return TestAllExtensions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestAllExtensions {
    return TestAllExtensions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllExtensions {
    return TestAllExtensions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestAllExtensionsBuilder {
    return TestAllExtensionsBuilder()
  }
  class func builderWithPrototype(prototype:TestAllExtensions) -> TestAllExtensionsBuilder {
    return TestAllExtensions.builder().mergeFrom(prototype)
  }
  func builder() -> TestAllExtensionsBuilder {
    return TestAllExtensions.builder()
  }
  func toBuilder() -> TestAllExtensionsBuilder {
    return TestAllExtensions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(1), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestAllExtensions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestAllExtensions.self
  }


  //Meta information declaration end

}

final class TestAllExtensionsBuilder : ExtendableMessageBuilder {
  private var builderResult:TestAllExtensions

  required override init () {
     builderResult = TestAllExtensions()
     super.init()
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestAllExtensionsBuilder {
    builderResult = TestAllExtensions()
    return self
  }
  override func clone() -> TestAllExtensionsBuilder {
    return TestAllExtensions.builderWithPrototype(builderResult)
  }
  override func build() -> TestAllExtensions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestAllExtensions {
    var returnMe:TestAllExtensions = builderResult
    return returnMe
  }
  func mergeFrom(other:TestAllExtensions) -> TestAllExtensionsBuilder {
    if (other == TestAllExtensions()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestAllExtensionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestAllExtensionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class OptionalGroup_extension : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(17, value:a)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(17, value:a)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OptionalGroup_extension {
    return OptionalGroup_extension.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> OptionalGroup_extensionBuilder {
    return OptionalGroup_extensionBuilder()
  }
  class func builderWithPrototype(prototype:OptionalGroup_extension) -> OptionalGroup_extensionBuilder {
    return OptionalGroup_extension.builder().mergeFrom(prototype)
  }
  func builder() -> OptionalGroup_extensionBuilder {
    return OptionalGroup_extension.builder()
  }
  func toBuilder() -> OptionalGroup_extensionBuilder {
    return OptionalGroup_extension.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "OptionalGroup_extension"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return OptionalGroup_extension.self
  }


  //Meta information declaration end

}

final class OptionalGroup_extensionBuilder : GeneratedMessageBuilder {
  private var builderResult:OptionalGroup_extension

  required override init () {
     builderResult = OptionalGroup_extension()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> OptionalGroup_extensionBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> OptionalGroup_extensionBuilder {
    builderResult = OptionalGroup_extension()
    return self
  }
  override func clone() -> OptionalGroup_extensionBuilder {
    return OptionalGroup_extension.builderWithPrototype(builderResult)
  }
  override func build() -> OptionalGroup_extension {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> OptionalGroup_extension {
    var returnMe:OptionalGroup_extension = builderResult
    return returnMe
  }
  func mergeFrom(other:OptionalGroup_extension) -> OptionalGroup_extensionBuilder {
    if (other == OptionalGroup_extension()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->OptionalGroup_extensionBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OptionalGroup_extensionBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 136 :
        a = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class RepeatedGroup_extension : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(47, value:a)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(47, value:a)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> RepeatedGroup_extension {
    return RepeatedGroup_extension.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> RepeatedGroup_extensionBuilder {
    return RepeatedGroup_extensionBuilder()
  }
  class func builderWithPrototype(prototype:RepeatedGroup_extension) -> RepeatedGroup_extensionBuilder {
    return RepeatedGroup_extension.builder().mergeFrom(prototype)
  }
  func builder() -> RepeatedGroup_extensionBuilder {
    return RepeatedGroup_extension.builder()
  }
  func toBuilder() -> RepeatedGroup_extensionBuilder {
    return RepeatedGroup_extension.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RepeatedGroup_extension"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RepeatedGroup_extension.self
  }


  //Meta information declaration end

}

final class RepeatedGroup_extensionBuilder : GeneratedMessageBuilder {
  private var builderResult:RepeatedGroup_extension

  required override init () {
     builderResult = RepeatedGroup_extension()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> RepeatedGroup_extensionBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> RepeatedGroup_extensionBuilder {
    builderResult = RepeatedGroup_extension()
    return self
  }
  override func clone() -> RepeatedGroup_extensionBuilder {
    return RepeatedGroup_extension.builderWithPrototype(builderResult)
  }
  override func build() -> RepeatedGroup_extension {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> RepeatedGroup_extension {
    var returnMe:RepeatedGroup_extension = builderResult
    return returnMe
  }
  func mergeFrom(other:RepeatedGroup_extension) -> RepeatedGroup_extensionBuilder {
    if (other == RepeatedGroup_extension()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->RepeatedGroup_extensionBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> RepeatedGroup_extensionBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 376 :
        a = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestNestedExtension : GeneratedMessage {
  class func test() -> ConcreateExtensionField {
       return TestNestedExtensiontest
  }
  class func nestedStringExtension() -> ConcreateExtensionField {
       return TestNestedExtensionnestedStringExtension
  }
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestNestedExtension {
    return TestNestedExtension.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestNestedExtension {
    return TestNestedExtension.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestNestedExtension {
    return TestNestedExtension.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestNestedExtension {
    return TestNestedExtension.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestNestedExtension {
    return TestNestedExtension.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedExtension {
    return TestNestedExtension.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestNestedExtensionBuilder {
    return TestNestedExtensionBuilder()
  }
  class func builderWithPrototype(prototype:TestNestedExtension) -> TestNestedExtensionBuilder {
    return TestNestedExtension.builder().mergeFrom(prototype)
  }
  func builder() -> TestNestedExtensionBuilder {
    return TestNestedExtension.builder()
  }
  func toBuilder() -> TestNestedExtensionBuilder {
    return TestNestedExtension.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestNestedExtension"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestNestedExtension.self
  }


  //Meta information declaration end

}

final class TestNestedExtensionBuilder : GeneratedMessageBuilder {
  private var builderResult:TestNestedExtension

  required override init () {
     builderResult = TestNestedExtension()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestNestedExtensionBuilder {
    builderResult = TestNestedExtension()
    return self
  }
  override func clone() -> TestNestedExtensionBuilder {
    return TestNestedExtension.builderWithPrototype(builderResult)
  }
  override func build() -> TestNestedExtension {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestNestedExtension {
    var returnMe:TestNestedExtension = builderResult
    return returnMe
  }
  func mergeFrom(other:TestNestedExtension) -> TestNestedExtensionBuilder {
    if (other == TestNestedExtension()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestNestedExtensionBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedExtensionBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestRequired : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  private(set) var hasDummy2:Bool = false
  private(set) var dummy2:Int32 = Int32(0)

  private(set) var hasB:Bool = false
  private(set) var b:Int32 = Int32(0)

  private(set) var hasDummy4:Bool = false
  private(set) var dummy4:Int32 = Int32(0)

  private(set) var hasDummy5:Bool = false
  private(set) var dummy5:Int32 = Int32(0)

  private(set) var hasDummy6:Bool = false
  private(set) var dummy6:Int32 = Int32(0)

  private(set) var hasDummy7:Bool = false
  private(set) var dummy7:Int32 = Int32(0)

  private(set) var hasDummy8:Bool = false
  private(set) var dummy8:Int32 = Int32(0)

  private(set) var hasDummy9:Bool = false
  private(set) var dummy9:Int32 = Int32(0)

  private(set) var hasDummy10:Bool = false
  private(set) var dummy10:Int32 = Int32(0)

  private(set) var hasDummy11:Bool = false
  private(set) var dummy11:Int32 = Int32(0)

  private(set) var hasDummy12:Bool = false
  private(set) var dummy12:Int32 = Int32(0)

  private(set) var hasDummy13:Bool = false
  private(set) var dummy13:Int32 = Int32(0)

  private(set) var hasDummy14:Bool = false
  private(set) var dummy14:Int32 = Int32(0)

  private(set) var hasDummy15:Bool = false
  private(set) var dummy15:Int32 = Int32(0)

  private(set) var hasDummy16:Bool = false
  private(set) var dummy16:Int32 = Int32(0)

  private(set) var hasDummy17:Bool = false
  private(set) var dummy17:Int32 = Int32(0)

  private(set) var hasDummy18:Bool = false
  private(set) var dummy18:Int32 = Int32(0)

  private(set) var hasDummy19:Bool = false
  private(set) var dummy19:Int32 = Int32(0)

  private(set) var hasDummy20:Bool = false
  private(set) var dummy20:Int32 = Int32(0)

  private(set) var hasDummy21:Bool = false
  private(set) var dummy21:Int32 = Int32(0)

  private(set) var hasDummy22:Bool = false
  private(set) var dummy22:Int32 = Int32(0)

  private(set) var hasDummy23:Bool = false
  private(set) var dummy23:Int32 = Int32(0)

  private(set) var hasDummy24:Bool = false
  private(set) var dummy24:Int32 = Int32(0)

  private(set) var hasDummy25:Bool = false
  private(set) var dummy25:Int32 = Int32(0)

  private(set) var hasDummy26:Bool = false
  private(set) var dummy26:Int32 = Int32(0)

  private(set) var hasDummy27:Bool = false
  private(set) var dummy27:Int32 = Int32(0)

  private(set) var hasDummy28:Bool = false
  private(set) var dummy28:Int32 = Int32(0)

  private(set) var hasDummy29:Bool = false
  private(set) var dummy29:Int32 = Int32(0)

  private(set) var hasDummy30:Bool = false
  private(set) var dummy30:Int32 = Int32(0)

  private(set) var hasDummy31:Bool = false
  private(set) var dummy31:Int32 = Int32(0)

  private(set) var hasDummy32:Bool = false
  private(set) var dummy32:Int32 = Int32(0)

  private(set) var hasC:Bool = false
  private(set) var c:Int32 = Int32(0)

  class func single() -> ConcreateExtensionField {
       return TestRequiredsingle
  }
  class func multi() -> ConcreateExtensionField {
       return TestRequiredmulti
  }
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasA {
      return false
    }
    if !hasB {
      return false
    }
    if !hasC {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(1, value:a)
    }
    if hasDummy2 {
      output.writeInt32(2, value:dummy2)
    }
    if hasB {
      output.writeInt32(3, value:b)
    }
    if hasDummy4 {
      output.writeInt32(4, value:dummy4)
    }
    if hasDummy5 {
      output.writeInt32(5, value:dummy5)
    }
    if hasDummy6 {
      output.writeInt32(6, value:dummy6)
    }
    if hasDummy7 {
      output.writeInt32(7, value:dummy7)
    }
    if hasDummy8 {
      output.writeInt32(8, value:dummy8)
    }
    if hasDummy9 {
      output.writeInt32(9, value:dummy9)
    }
    if hasDummy10 {
      output.writeInt32(10, value:dummy10)
    }
    if hasDummy11 {
      output.writeInt32(11, value:dummy11)
    }
    if hasDummy12 {
      output.writeInt32(12, value:dummy12)
    }
    if hasDummy13 {
      output.writeInt32(13, value:dummy13)
    }
    if hasDummy14 {
      output.writeInt32(14, value:dummy14)
    }
    if hasDummy15 {
      output.writeInt32(15, value:dummy15)
    }
    if hasDummy16 {
      output.writeInt32(16, value:dummy16)
    }
    if hasDummy17 {
      output.writeInt32(17, value:dummy17)
    }
    if hasDummy18 {
      output.writeInt32(18, value:dummy18)
    }
    if hasDummy19 {
      output.writeInt32(19, value:dummy19)
    }
    if hasDummy20 {
      output.writeInt32(20, value:dummy20)
    }
    if hasDummy21 {
      output.writeInt32(21, value:dummy21)
    }
    if hasDummy22 {
      output.writeInt32(22, value:dummy22)
    }
    if hasDummy23 {
      output.writeInt32(23, value:dummy23)
    }
    if hasDummy24 {
      output.writeInt32(24, value:dummy24)
    }
    if hasDummy25 {
      output.writeInt32(25, value:dummy25)
    }
    if hasDummy26 {
      output.writeInt32(26, value:dummy26)
    }
    if hasDummy27 {
      output.writeInt32(27, value:dummy27)
    }
    if hasDummy28 {
      output.writeInt32(28, value:dummy28)
    }
    if hasDummy29 {
      output.writeInt32(29, value:dummy29)
    }
    if hasDummy30 {
      output.writeInt32(30, value:dummy30)
    }
    if hasDummy31 {
      output.writeInt32(31, value:dummy31)
    }
    if hasDummy32 {
      output.writeInt32(32, value:dummy32)
    }
    if hasC {
      output.writeInt32(33, value:c)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(1, value:a)
    }
    if hasDummy2 {
      size += WireFormat.computeInt32Size(2, value:dummy2)
    }
    if hasB {
      size += WireFormat.computeInt32Size(3, value:b)
    }
    if hasDummy4 {
      size += WireFormat.computeInt32Size(4, value:dummy4)
    }
    if hasDummy5 {
      size += WireFormat.computeInt32Size(5, value:dummy5)
    }
    if hasDummy6 {
      size += WireFormat.computeInt32Size(6, value:dummy6)
    }
    if hasDummy7 {
      size += WireFormat.computeInt32Size(7, value:dummy7)
    }
    if hasDummy8 {
      size += WireFormat.computeInt32Size(8, value:dummy8)
    }
    if hasDummy9 {
      size += WireFormat.computeInt32Size(9, value:dummy9)
    }
    if hasDummy10 {
      size += WireFormat.computeInt32Size(10, value:dummy10)
    }
    if hasDummy11 {
      size += WireFormat.computeInt32Size(11, value:dummy11)
    }
    if hasDummy12 {
      size += WireFormat.computeInt32Size(12, value:dummy12)
    }
    if hasDummy13 {
      size += WireFormat.computeInt32Size(13, value:dummy13)
    }
    if hasDummy14 {
      size += WireFormat.computeInt32Size(14, value:dummy14)
    }
    if hasDummy15 {
      size += WireFormat.computeInt32Size(15, value:dummy15)
    }
    if hasDummy16 {
      size += WireFormat.computeInt32Size(16, value:dummy16)
    }
    if hasDummy17 {
      size += WireFormat.computeInt32Size(17, value:dummy17)
    }
    if hasDummy18 {
      size += WireFormat.computeInt32Size(18, value:dummy18)
    }
    if hasDummy19 {
      size += WireFormat.computeInt32Size(19, value:dummy19)
    }
    if hasDummy20 {
      size += WireFormat.computeInt32Size(20, value:dummy20)
    }
    if hasDummy21 {
      size += WireFormat.computeInt32Size(21, value:dummy21)
    }
    if hasDummy22 {
      size += WireFormat.computeInt32Size(22, value:dummy22)
    }
    if hasDummy23 {
      size += WireFormat.computeInt32Size(23, value:dummy23)
    }
    if hasDummy24 {
      size += WireFormat.computeInt32Size(24, value:dummy24)
    }
    if hasDummy25 {
      size += WireFormat.computeInt32Size(25, value:dummy25)
    }
    if hasDummy26 {
      size += WireFormat.computeInt32Size(26, value:dummy26)
    }
    if hasDummy27 {
      size += WireFormat.computeInt32Size(27, value:dummy27)
    }
    if hasDummy28 {
      size += WireFormat.computeInt32Size(28, value:dummy28)
    }
    if hasDummy29 {
      size += WireFormat.computeInt32Size(29, value:dummy29)
    }
    if hasDummy30 {
      size += WireFormat.computeInt32Size(30, value:dummy30)
    }
    if hasDummy31 {
      size += WireFormat.computeInt32Size(31, value:dummy31)
    }
    if hasDummy32 {
      size += WireFormat.computeInt32Size(32, value:dummy32)
    }
    if hasC {
      size += WireFormat.computeInt32Size(33, value:c)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestRequired {
    return TestRequired.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRequired {
    return TestRequired.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestRequired {
    return TestRequired.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRequired {
    return TestRequired.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestRequired {
    return TestRequired.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequired {
    return TestRequired.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestRequiredBuilder {
    return TestRequiredBuilder()
  }
  class func builderWithPrototype(prototype:TestRequired) -> TestRequiredBuilder {
    return TestRequired.builder().mergeFrom(prototype)
  }
  func builder() -> TestRequiredBuilder {
    return TestRequired.builder()
  }
  func toBuilder() -> TestRequiredBuilder {
    return TestRequired.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    if hasDummy2 {
      output += "\(indent) dummy2: \(dummy2) \n"
    }
    if hasB {
      output += "\(indent) b: \(b) \n"
    }
    if hasDummy4 {
      output += "\(indent) dummy4: \(dummy4) \n"
    }
    if hasDummy5 {
      output += "\(indent) dummy5: \(dummy5) \n"
    }
    if hasDummy6 {
      output += "\(indent) dummy6: \(dummy6) \n"
    }
    if hasDummy7 {
      output += "\(indent) dummy7: \(dummy7) \n"
    }
    if hasDummy8 {
      output += "\(indent) dummy8: \(dummy8) \n"
    }
    if hasDummy9 {
      output += "\(indent) dummy9: \(dummy9) \n"
    }
    if hasDummy10 {
      output += "\(indent) dummy10: \(dummy10) \n"
    }
    if hasDummy11 {
      output += "\(indent) dummy11: \(dummy11) \n"
    }
    if hasDummy12 {
      output += "\(indent) dummy12: \(dummy12) \n"
    }
    if hasDummy13 {
      output += "\(indent) dummy13: \(dummy13) \n"
    }
    if hasDummy14 {
      output += "\(indent) dummy14: \(dummy14) \n"
    }
    if hasDummy15 {
      output += "\(indent) dummy15: \(dummy15) \n"
    }
    if hasDummy16 {
      output += "\(indent) dummy16: \(dummy16) \n"
    }
    if hasDummy17 {
      output += "\(indent) dummy17: \(dummy17) \n"
    }
    if hasDummy18 {
      output += "\(indent) dummy18: \(dummy18) \n"
    }
    if hasDummy19 {
      output += "\(indent) dummy19: \(dummy19) \n"
    }
    if hasDummy20 {
      output += "\(indent) dummy20: \(dummy20) \n"
    }
    if hasDummy21 {
      output += "\(indent) dummy21: \(dummy21) \n"
    }
    if hasDummy22 {
      output += "\(indent) dummy22: \(dummy22) \n"
    }
    if hasDummy23 {
      output += "\(indent) dummy23: \(dummy23) \n"
    }
    if hasDummy24 {
      output += "\(indent) dummy24: \(dummy24) \n"
    }
    if hasDummy25 {
      output += "\(indent) dummy25: \(dummy25) \n"
    }
    if hasDummy26 {
      output += "\(indent) dummy26: \(dummy26) \n"
    }
    if hasDummy27 {
      output += "\(indent) dummy27: \(dummy27) \n"
    }
    if hasDummy28 {
      output += "\(indent) dummy28: \(dummy28) \n"
    }
    if hasDummy29 {
      output += "\(indent) dummy29: \(dummy29) \n"
    }
    if hasDummy30 {
      output += "\(indent) dummy30: \(dummy30) \n"
    }
    if hasDummy31 {
      output += "\(indent) dummy31: \(dummy31) \n"
    }
    if hasDummy32 {
      output += "\(indent) dummy32: \(dummy32) \n"
    }
    if hasC {
      output += "\(indent) c: \(c) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          if hasDummy2 {
             hashCode = (hashCode &* 31) &+ dummy2.hashValue
          }
          if hasB {
             hashCode = (hashCode &* 31) &+ b.hashValue
          }
          if hasDummy4 {
             hashCode = (hashCode &* 31) &+ dummy4.hashValue
          }
          if hasDummy5 {
             hashCode = (hashCode &* 31) &+ dummy5.hashValue
          }
          if hasDummy6 {
             hashCode = (hashCode &* 31) &+ dummy6.hashValue
          }
          if hasDummy7 {
             hashCode = (hashCode &* 31) &+ dummy7.hashValue
          }
          if hasDummy8 {
             hashCode = (hashCode &* 31) &+ dummy8.hashValue
          }
          if hasDummy9 {
             hashCode = (hashCode &* 31) &+ dummy9.hashValue
          }
          if hasDummy10 {
             hashCode = (hashCode &* 31) &+ dummy10.hashValue
          }
          if hasDummy11 {
             hashCode = (hashCode &* 31) &+ dummy11.hashValue
          }
          if hasDummy12 {
             hashCode = (hashCode &* 31) &+ dummy12.hashValue
          }
          if hasDummy13 {
             hashCode = (hashCode &* 31) &+ dummy13.hashValue
          }
          if hasDummy14 {
             hashCode = (hashCode &* 31) &+ dummy14.hashValue
          }
          if hasDummy15 {
             hashCode = (hashCode &* 31) &+ dummy15.hashValue
          }
          if hasDummy16 {
             hashCode = (hashCode &* 31) &+ dummy16.hashValue
          }
          if hasDummy17 {
             hashCode = (hashCode &* 31) &+ dummy17.hashValue
          }
          if hasDummy18 {
             hashCode = (hashCode &* 31) &+ dummy18.hashValue
          }
          if hasDummy19 {
             hashCode = (hashCode &* 31) &+ dummy19.hashValue
          }
          if hasDummy20 {
             hashCode = (hashCode &* 31) &+ dummy20.hashValue
          }
          if hasDummy21 {
             hashCode = (hashCode &* 31) &+ dummy21.hashValue
          }
          if hasDummy22 {
             hashCode = (hashCode &* 31) &+ dummy22.hashValue
          }
          if hasDummy23 {
             hashCode = (hashCode &* 31) &+ dummy23.hashValue
          }
          if hasDummy24 {
             hashCode = (hashCode &* 31) &+ dummy24.hashValue
          }
          if hasDummy25 {
             hashCode = (hashCode &* 31) &+ dummy25.hashValue
          }
          if hasDummy26 {
             hashCode = (hashCode &* 31) &+ dummy26.hashValue
          }
          if hasDummy27 {
             hashCode = (hashCode &* 31) &+ dummy27.hashValue
          }
          if hasDummy28 {
             hashCode = (hashCode &* 31) &+ dummy28.hashValue
          }
          if hasDummy29 {
             hashCode = (hashCode &* 31) &+ dummy29.hashValue
          }
          if hasDummy30 {
             hashCode = (hashCode &* 31) &+ dummy30.hashValue
          }
          if hasDummy31 {
             hashCode = (hashCode &* 31) &+ dummy31.hashValue
          }
          if hasDummy32 {
             hashCode = (hashCode &* 31) &+ dummy32.hashValue
          }
          if hasC {
             hashCode = (hashCode &* 31) &+ c.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestRequired"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestRequired.self
  }


  //Meta information declaration end

}

final class TestRequiredBuilder : GeneratedMessageBuilder {
  private var builderResult:TestRequired

  required override init () {
     builderResult = TestRequired()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> TestRequiredBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  var hasDummy2:Bool {
       get {
            return builderResult.hasDummy2
       }
  }
  var dummy2:Int32 {
       get {
            return builderResult.dummy2
       }
       set (value) {
           builderResult.hasDummy2 = true
           builderResult.dummy2 = value
       }
  }
  func clearDummy2() -> TestRequiredBuilder{
       builderResult.hasDummy2 = false
       builderResult.dummy2 = Int32(0)
       return self
  }
  var hasB:Bool {
       get {
            return builderResult.hasB
       }
  }
  var b:Int32 {
       get {
            return builderResult.b
       }
       set (value) {
           builderResult.hasB = true
           builderResult.b = value
       }
  }
  func clearB() -> TestRequiredBuilder{
       builderResult.hasB = false
       builderResult.b = Int32(0)
       return self
  }
  var hasDummy4:Bool {
       get {
            return builderResult.hasDummy4
       }
  }
  var dummy4:Int32 {
       get {
            return builderResult.dummy4
       }
       set (value) {
           builderResult.hasDummy4 = true
           builderResult.dummy4 = value
       }
  }
  func clearDummy4() -> TestRequiredBuilder{
       builderResult.hasDummy4 = false
       builderResult.dummy4 = Int32(0)
       return self
  }
  var hasDummy5:Bool {
       get {
            return builderResult.hasDummy5
       }
  }
  var dummy5:Int32 {
       get {
            return builderResult.dummy5
       }
       set (value) {
           builderResult.hasDummy5 = true
           builderResult.dummy5 = value
       }
  }
  func clearDummy5() -> TestRequiredBuilder{
       builderResult.hasDummy5 = false
       builderResult.dummy5 = Int32(0)
       return self
  }
  var hasDummy6:Bool {
       get {
            return builderResult.hasDummy6
       }
  }
  var dummy6:Int32 {
       get {
            return builderResult.dummy6
       }
       set (value) {
           builderResult.hasDummy6 = true
           builderResult.dummy6 = value
       }
  }
  func clearDummy6() -> TestRequiredBuilder{
       builderResult.hasDummy6 = false
       builderResult.dummy6 = Int32(0)
       return self
  }
  var hasDummy7:Bool {
       get {
            return builderResult.hasDummy7
       }
  }
  var dummy7:Int32 {
       get {
            return builderResult.dummy7
       }
       set (value) {
           builderResult.hasDummy7 = true
           builderResult.dummy7 = value
       }
  }
  func clearDummy7() -> TestRequiredBuilder{
       builderResult.hasDummy7 = false
       builderResult.dummy7 = Int32(0)
       return self
  }
  var hasDummy8:Bool {
       get {
            return builderResult.hasDummy8
       }
  }
  var dummy8:Int32 {
       get {
            return builderResult.dummy8
       }
       set (value) {
           builderResult.hasDummy8 = true
           builderResult.dummy8 = value
       }
  }
  func clearDummy8() -> TestRequiredBuilder{
       builderResult.hasDummy8 = false
       builderResult.dummy8 = Int32(0)
       return self
  }
  var hasDummy9:Bool {
       get {
            return builderResult.hasDummy9
       }
  }
  var dummy9:Int32 {
       get {
            return builderResult.dummy9
       }
       set (value) {
           builderResult.hasDummy9 = true
           builderResult.dummy9 = value
       }
  }
  func clearDummy9() -> TestRequiredBuilder{
       builderResult.hasDummy9 = false
       builderResult.dummy9 = Int32(0)
       return self
  }
  var hasDummy10:Bool {
       get {
            return builderResult.hasDummy10
       }
  }
  var dummy10:Int32 {
       get {
            return builderResult.dummy10
       }
       set (value) {
           builderResult.hasDummy10 = true
           builderResult.dummy10 = value
       }
  }
  func clearDummy10() -> TestRequiredBuilder{
       builderResult.hasDummy10 = false
       builderResult.dummy10 = Int32(0)
       return self
  }
  var hasDummy11:Bool {
       get {
            return builderResult.hasDummy11
       }
  }
  var dummy11:Int32 {
       get {
            return builderResult.dummy11
       }
       set (value) {
           builderResult.hasDummy11 = true
           builderResult.dummy11 = value
       }
  }
  func clearDummy11() -> TestRequiredBuilder{
       builderResult.hasDummy11 = false
       builderResult.dummy11 = Int32(0)
       return self
  }
  var hasDummy12:Bool {
       get {
            return builderResult.hasDummy12
       }
  }
  var dummy12:Int32 {
       get {
            return builderResult.dummy12
       }
       set (value) {
           builderResult.hasDummy12 = true
           builderResult.dummy12 = value
       }
  }
  func clearDummy12() -> TestRequiredBuilder{
       builderResult.hasDummy12 = false
       builderResult.dummy12 = Int32(0)
       return self
  }
  var hasDummy13:Bool {
       get {
            return builderResult.hasDummy13
       }
  }
  var dummy13:Int32 {
       get {
            return builderResult.dummy13
       }
       set (value) {
           builderResult.hasDummy13 = true
           builderResult.dummy13 = value
       }
  }
  func clearDummy13() -> TestRequiredBuilder{
       builderResult.hasDummy13 = false
       builderResult.dummy13 = Int32(0)
       return self
  }
  var hasDummy14:Bool {
       get {
            return builderResult.hasDummy14
       }
  }
  var dummy14:Int32 {
       get {
            return builderResult.dummy14
       }
       set (value) {
           builderResult.hasDummy14 = true
           builderResult.dummy14 = value
       }
  }
  func clearDummy14() -> TestRequiredBuilder{
       builderResult.hasDummy14 = false
       builderResult.dummy14 = Int32(0)
       return self
  }
  var hasDummy15:Bool {
       get {
            return builderResult.hasDummy15
       }
  }
  var dummy15:Int32 {
       get {
            return builderResult.dummy15
       }
       set (value) {
           builderResult.hasDummy15 = true
           builderResult.dummy15 = value
       }
  }
  func clearDummy15() -> TestRequiredBuilder{
       builderResult.hasDummy15 = false
       builderResult.dummy15 = Int32(0)
       return self
  }
  var hasDummy16:Bool {
       get {
            return builderResult.hasDummy16
       }
  }
  var dummy16:Int32 {
       get {
            return builderResult.dummy16
       }
       set (value) {
           builderResult.hasDummy16 = true
           builderResult.dummy16 = value
       }
  }
  func clearDummy16() -> TestRequiredBuilder{
       builderResult.hasDummy16 = false
       builderResult.dummy16 = Int32(0)
       return self
  }
  var hasDummy17:Bool {
       get {
            return builderResult.hasDummy17
       }
  }
  var dummy17:Int32 {
       get {
            return builderResult.dummy17
       }
       set (value) {
           builderResult.hasDummy17 = true
           builderResult.dummy17 = value
       }
  }
  func clearDummy17() -> TestRequiredBuilder{
       builderResult.hasDummy17 = false
       builderResult.dummy17 = Int32(0)
       return self
  }
  var hasDummy18:Bool {
       get {
            return builderResult.hasDummy18
       }
  }
  var dummy18:Int32 {
       get {
            return builderResult.dummy18
       }
       set (value) {
           builderResult.hasDummy18 = true
           builderResult.dummy18 = value
       }
  }
  func clearDummy18() -> TestRequiredBuilder{
       builderResult.hasDummy18 = false
       builderResult.dummy18 = Int32(0)
       return self
  }
  var hasDummy19:Bool {
       get {
            return builderResult.hasDummy19
       }
  }
  var dummy19:Int32 {
       get {
            return builderResult.dummy19
       }
       set (value) {
           builderResult.hasDummy19 = true
           builderResult.dummy19 = value
       }
  }
  func clearDummy19() -> TestRequiredBuilder{
       builderResult.hasDummy19 = false
       builderResult.dummy19 = Int32(0)
       return self
  }
  var hasDummy20:Bool {
       get {
            return builderResult.hasDummy20
       }
  }
  var dummy20:Int32 {
       get {
            return builderResult.dummy20
       }
       set (value) {
           builderResult.hasDummy20 = true
           builderResult.dummy20 = value
       }
  }
  func clearDummy20() -> TestRequiredBuilder{
       builderResult.hasDummy20 = false
       builderResult.dummy20 = Int32(0)
       return self
  }
  var hasDummy21:Bool {
       get {
            return builderResult.hasDummy21
       }
  }
  var dummy21:Int32 {
       get {
            return builderResult.dummy21
       }
       set (value) {
           builderResult.hasDummy21 = true
           builderResult.dummy21 = value
       }
  }
  func clearDummy21() -> TestRequiredBuilder{
       builderResult.hasDummy21 = false
       builderResult.dummy21 = Int32(0)
       return self
  }
  var hasDummy22:Bool {
       get {
            return builderResult.hasDummy22
       }
  }
  var dummy22:Int32 {
       get {
            return builderResult.dummy22
       }
       set (value) {
           builderResult.hasDummy22 = true
           builderResult.dummy22 = value
       }
  }
  func clearDummy22() -> TestRequiredBuilder{
       builderResult.hasDummy22 = false
       builderResult.dummy22 = Int32(0)
       return self
  }
  var hasDummy23:Bool {
       get {
            return builderResult.hasDummy23
       }
  }
  var dummy23:Int32 {
       get {
            return builderResult.dummy23
       }
       set (value) {
           builderResult.hasDummy23 = true
           builderResult.dummy23 = value
       }
  }
  func clearDummy23() -> TestRequiredBuilder{
       builderResult.hasDummy23 = false
       builderResult.dummy23 = Int32(0)
       return self
  }
  var hasDummy24:Bool {
       get {
            return builderResult.hasDummy24
       }
  }
  var dummy24:Int32 {
       get {
            return builderResult.dummy24
       }
       set (value) {
           builderResult.hasDummy24 = true
           builderResult.dummy24 = value
       }
  }
  func clearDummy24() -> TestRequiredBuilder{
       builderResult.hasDummy24 = false
       builderResult.dummy24 = Int32(0)
       return self
  }
  var hasDummy25:Bool {
       get {
            return builderResult.hasDummy25
       }
  }
  var dummy25:Int32 {
       get {
            return builderResult.dummy25
       }
       set (value) {
           builderResult.hasDummy25 = true
           builderResult.dummy25 = value
       }
  }
  func clearDummy25() -> TestRequiredBuilder{
       builderResult.hasDummy25 = false
       builderResult.dummy25 = Int32(0)
       return self
  }
  var hasDummy26:Bool {
       get {
            return builderResult.hasDummy26
       }
  }
  var dummy26:Int32 {
       get {
            return builderResult.dummy26
       }
       set (value) {
           builderResult.hasDummy26 = true
           builderResult.dummy26 = value
       }
  }
  func clearDummy26() -> TestRequiredBuilder{
       builderResult.hasDummy26 = false
       builderResult.dummy26 = Int32(0)
       return self
  }
  var hasDummy27:Bool {
       get {
            return builderResult.hasDummy27
       }
  }
  var dummy27:Int32 {
       get {
            return builderResult.dummy27
       }
       set (value) {
           builderResult.hasDummy27 = true
           builderResult.dummy27 = value
       }
  }
  func clearDummy27() -> TestRequiredBuilder{
       builderResult.hasDummy27 = false
       builderResult.dummy27 = Int32(0)
       return self
  }
  var hasDummy28:Bool {
       get {
            return builderResult.hasDummy28
       }
  }
  var dummy28:Int32 {
       get {
            return builderResult.dummy28
       }
       set (value) {
           builderResult.hasDummy28 = true
           builderResult.dummy28 = value
       }
  }
  func clearDummy28() -> TestRequiredBuilder{
       builderResult.hasDummy28 = false
       builderResult.dummy28 = Int32(0)
       return self
  }
  var hasDummy29:Bool {
       get {
            return builderResult.hasDummy29
       }
  }
  var dummy29:Int32 {
       get {
            return builderResult.dummy29
       }
       set (value) {
           builderResult.hasDummy29 = true
           builderResult.dummy29 = value
       }
  }
  func clearDummy29() -> TestRequiredBuilder{
       builderResult.hasDummy29 = false
       builderResult.dummy29 = Int32(0)
       return self
  }
  var hasDummy30:Bool {
       get {
            return builderResult.hasDummy30
       }
  }
  var dummy30:Int32 {
       get {
            return builderResult.dummy30
       }
       set (value) {
           builderResult.hasDummy30 = true
           builderResult.dummy30 = value
       }
  }
  func clearDummy30() -> TestRequiredBuilder{
       builderResult.hasDummy30 = false
       builderResult.dummy30 = Int32(0)
       return self
  }
  var hasDummy31:Bool {
       get {
            return builderResult.hasDummy31
       }
  }
  var dummy31:Int32 {
       get {
            return builderResult.dummy31
       }
       set (value) {
           builderResult.hasDummy31 = true
           builderResult.dummy31 = value
       }
  }
  func clearDummy31() -> TestRequiredBuilder{
       builderResult.hasDummy31 = false
       builderResult.dummy31 = Int32(0)
       return self
  }
  var hasDummy32:Bool {
       get {
            return builderResult.hasDummy32
       }
  }
  var dummy32:Int32 {
       get {
            return builderResult.dummy32
       }
       set (value) {
           builderResult.hasDummy32 = true
           builderResult.dummy32 = value
       }
  }
  func clearDummy32() -> TestRequiredBuilder{
       builderResult.hasDummy32 = false
       builderResult.dummy32 = Int32(0)
       return self
  }
  var hasC:Bool {
       get {
            return builderResult.hasC
       }
  }
  var c:Int32 {
       get {
            return builderResult.c
       }
       set (value) {
           builderResult.hasC = true
           builderResult.c = value
       }
  }
  func clearC() -> TestRequiredBuilder{
       builderResult.hasC = false
       builderResult.c = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestRequiredBuilder {
    builderResult = TestRequired()
    return self
  }
  override func clone() -> TestRequiredBuilder {
    return TestRequired.builderWithPrototype(builderResult)
  }
  override func build() -> TestRequired {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestRequired {
    var returnMe:TestRequired = builderResult
    return returnMe
  }
  func mergeFrom(other:TestRequired) -> TestRequiredBuilder {
    if (other == TestRequired()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    if other.hasDummy2 {
         dummy2 = other.dummy2
    }
    if other.hasB {
         b = other.b
    }
    if other.hasDummy4 {
         dummy4 = other.dummy4
    }
    if other.hasDummy5 {
         dummy5 = other.dummy5
    }
    if other.hasDummy6 {
         dummy6 = other.dummy6
    }
    if other.hasDummy7 {
         dummy7 = other.dummy7
    }
    if other.hasDummy8 {
         dummy8 = other.dummy8
    }
    if other.hasDummy9 {
         dummy9 = other.dummy9
    }
    if other.hasDummy10 {
         dummy10 = other.dummy10
    }
    if other.hasDummy11 {
         dummy11 = other.dummy11
    }
    if other.hasDummy12 {
         dummy12 = other.dummy12
    }
    if other.hasDummy13 {
         dummy13 = other.dummy13
    }
    if other.hasDummy14 {
         dummy14 = other.dummy14
    }
    if other.hasDummy15 {
         dummy15 = other.dummy15
    }
    if other.hasDummy16 {
         dummy16 = other.dummy16
    }
    if other.hasDummy17 {
         dummy17 = other.dummy17
    }
    if other.hasDummy18 {
         dummy18 = other.dummy18
    }
    if other.hasDummy19 {
         dummy19 = other.dummy19
    }
    if other.hasDummy20 {
         dummy20 = other.dummy20
    }
    if other.hasDummy21 {
         dummy21 = other.dummy21
    }
    if other.hasDummy22 {
         dummy22 = other.dummy22
    }
    if other.hasDummy23 {
         dummy23 = other.dummy23
    }
    if other.hasDummy24 {
         dummy24 = other.dummy24
    }
    if other.hasDummy25 {
         dummy25 = other.dummy25
    }
    if other.hasDummy26 {
         dummy26 = other.dummy26
    }
    if other.hasDummy27 {
         dummy27 = other.dummy27
    }
    if other.hasDummy28 {
         dummy28 = other.dummy28
    }
    if other.hasDummy29 {
         dummy29 = other.dummy29
    }
    if other.hasDummy30 {
         dummy30 = other.dummy30
    }
    if other.hasDummy31 {
         dummy31 = other.dummy31
    }
    if other.hasDummy32 {
         dummy32 = other.dummy32
    }
    if other.hasC {
         c = other.c
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRequiredBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        a = input.readInt32()

      case 16 :
        dummy2 = input.readInt32()

      case 24 :
        b = input.readInt32()

      case 32 :
        dummy4 = input.readInt32()

      case 40 :
        dummy5 = input.readInt32()

      case 48 :
        dummy6 = input.readInt32()

      case 56 :
        dummy7 = input.readInt32()

      case 64 :
        dummy8 = input.readInt32()

      case 72 :
        dummy9 = input.readInt32()

      case 80 :
        dummy10 = input.readInt32()

      case 88 :
        dummy11 = input.readInt32()

      case 96 :
        dummy12 = input.readInt32()

      case 104 :
        dummy13 = input.readInt32()

      case 112 :
        dummy14 = input.readInt32()

      case 120 :
        dummy15 = input.readInt32()

      case 128 :
        dummy16 = input.readInt32()

      case 136 :
        dummy17 = input.readInt32()

      case 144 :
        dummy18 = input.readInt32()

      case 152 :
        dummy19 = input.readInt32()

      case 160 :
        dummy20 = input.readInt32()

      case 168 :
        dummy21 = input.readInt32()

      case 176 :
        dummy22 = input.readInt32()

      case 184 :
        dummy23 = input.readInt32()

      case 192 :
        dummy24 = input.readInt32()

      case 200 :
        dummy25 = input.readInt32()

      case 208 :
        dummy26 = input.readInt32()

      case 216 :
        dummy27 = input.readInt32()

      case 224 :
        dummy28 = input.readInt32()

      case 232 :
        dummy29 = input.readInt32()

      case 240 :
        dummy30 = input.readInt32()

      case 248 :
        dummy31 = input.readInt32()

      case 256 :
        dummy32 = input.readInt32()

      case 264 :
        c = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestRequiredForeign : GeneratedMessage {
  private(set) var hasOptionalMessage:Bool = false
  private(set) var optionalMessage:TestRequired = TestRequired()
  private(set) var hasDummy:Bool = false
  private(set) var dummy:Int32 = Int32(0)

  private(set) var repeatedMessage:Array<TestRequired>  = Array<TestRequired>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasOptionalMessage {
     if !optionalMessage.isInitialized() {
       return false
     }
    }
    var isInitrepeatedMessage:Bool = true
    for element in repeatedMessage {
        if (!element.isInitialized()) {
            isInitrepeatedMessage = false
            break 
        }
    }
    if !isInitrepeatedMessage {
     return isInitrepeatedMessage
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasOptionalMessage {
      output.writeMessage(1, value:optionalMessage)
    }
    for element in repeatedMessage {
        output.writeMessage(2, value:element)
    }
    if hasDummy {
      output.writeInt32(3, value:dummy)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasOptionalMessage {
      size += WireFormat.computeMessageSize(1, value:optionalMessage)
    }
    for element in repeatedMessage {
        size += WireFormat.computeMessageSize(2, value:element)
    }
    if hasDummy {
      size += WireFormat.computeInt32Size(3, value:dummy)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredForeign {
    return TestRequiredForeign.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestRequiredForeignBuilder {
    return TestRequiredForeignBuilder()
  }
  class func builderWithPrototype(prototype:TestRequiredForeign) -> TestRequiredForeignBuilder {
    return TestRequiredForeign.builder().mergeFrom(prototype)
  }
  func builder() -> TestRequiredForeignBuilder {
    return TestRequiredForeign.builder()
  }
  func toBuilder() -> TestRequiredForeignBuilder {
    return TestRequiredForeign.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasOptionalMessage {
      output += "\(indent) optionalMessage {\n"
      optionalMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var repeatedMessageElementIndex:Int = 0
    for element in repeatedMessage {
        output += "\(indent) repeatedMessage[\(repeatedMessageElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedMessageElementIndex++
    }
    if hasDummy {
      output += "\(indent) dummy: \(dummy) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOptionalMessage {
            hashCode = (hashCode &* 31) &+ optionalMessage.hashValue
          }
          for element in repeatedMessage {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasDummy {
             hashCode = (hashCode &* 31) &+ dummy.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestRequiredForeign"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestRequiredForeign.self
  }


  //Meta information declaration end

}

final class TestRequiredForeignBuilder : GeneratedMessageBuilder {
  private var builderResult:TestRequiredForeign

  required override init () {
     builderResult = TestRequiredForeign()
     super.init()
  }
  var hasOptionalMessage:Bool {
       get {
           return builderResult.hasOptionalMessage
       }
  }
  var optionalMessage:TestRequired {
       get {
           return builderResult.optionalMessage
       }
       set (value) {
           builderResult.hasOptionalMessage = true
           builderResult.optionalMessage = value
       }
  }
  func setOptionalMessageBuilder(builderForValue:TestRequiredBuilder) -> TestRequiredForeignBuilder {
    optionalMessage = builderForValue.build()
    return self
  }
  func mergeOptionalMessage(value:TestRequired) -> TestRequiredForeignBuilder {
    if (builderResult.hasOptionalMessage && builderResult.optionalMessage != TestRequired()) {
      builderResult.optionalMessage = TestRequired.builderWithPrototype(builderResult.optionalMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalMessage = value
    }
    builderResult.hasOptionalMessage = true
    return self
  }
  func clearOptionalMessage() -> TestRequiredForeignBuilder {
    builderResult.hasOptionalMessage = false
    builderResult.optionalMessage = TestRequired()
    return self
  }
  var repeatedMessage:Array<TestRequired> {
       get {
           return builderResult.repeatedMessage
       }
       set (value) {
           builderResult.repeatedMessage = value
       }
  }
  func clearRepeatedMessage() -> TestRequiredForeignBuilder {
    builderResult.repeatedMessage.removeAll(keepCapacity: false)
    return self
  }
  var hasDummy:Bool {
       get {
            return builderResult.hasDummy
       }
  }
  var dummy:Int32 {
       get {
            return builderResult.dummy
       }
       set (value) {
           builderResult.hasDummy = true
           builderResult.dummy = value
       }
  }
  func clearDummy() -> TestRequiredForeignBuilder{
       builderResult.hasDummy = false
       builderResult.dummy = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestRequiredForeignBuilder {
    builderResult = TestRequiredForeign()
    return self
  }
  override func clone() -> TestRequiredForeignBuilder {
    return TestRequiredForeign.builderWithPrototype(builderResult)
  }
  override func build() -> TestRequiredForeign {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestRequiredForeign {
    var returnMe:TestRequiredForeign = builderResult
    return returnMe
  }
  func mergeFrom(other:TestRequiredForeign) -> TestRequiredForeignBuilder {
    if (other == TestRequiredForeign()) {
     return self
    }
    if (other.hasOptionalMessage) {
        mergeOptionalMessage(other.optionalMessage)
    }
    if !other.repeatedMessage.isEmpty  {
       builderResult.repeatedMessage += other.repeatedMessage
    }
    if other.hasDummy {
         dummy = other.dummy
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRequiredForeignBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredForeignBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestRequiredBuilder = TestRequired.builder()
        if hasOptionalMessage {
          subBuilder.mergeFrom(optionalMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalMessage = subBuilder.buildPartial()

      case 18 :
        var subBuilder = TestRequired.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedMessage += [subBuilder.buildPartial()]

      case 24 :
        dummy = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestForeignNested : GeneratedMessage {
  private(set) var hasForeignNested:Bool = false
  private(set) var foreignNested:TestAllTypes.NestedMessage = TestAllTypes.NestedMessage()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasForeignNested {
      output.writeMessage(1, value:foreignNested)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasForeignNested {
      size += WireFormat.computeMessageSize(1, value:foreignNested)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestForeignNested {
    return TestForeignNested.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestForeignNested {
    return TestForeignNested.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestForeignNested {
    return TestForeignNested.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestForeignNested {
    return TestForeignNested.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestForeignNested {
    return TestForeignNested.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestForeignNested {
    return TestForeignNested.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestForeignNestedBuilder {
    return TestForeignNestedBuilder()
  }
  class func builderWithPrototype(prototype:TestForeignNested) -> TestForeignNestedBuilder {
    return TestForeignNested.builder().mergeFrom(prototype)
  }
  func builder() -> TestForeignNestedBuilder {
    return TestForeignNested.builder()
  }
  func toBuilder() -> TestForeignNestedBuilder {
    return TestForeignNested.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasForeignNested {
      output += "\(indent) foreignNested {\n"
      foreignNested.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasForeignNested {
            hashCode = (hashCode &* 31) &+ foreignNested.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestForeignNested"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestForeignNested.self
  }


  //Meta information declaration end

}

final class TestForeignNestedBuilder : GeneratedMessageBuilder {
  private var builderResult:TestForeignNested

  required override init () {
     builderResult = TestForeignNested()
     super.init()
  }
  var hasForeignNested:Bool {
       get {
           return builderResult.hasForeignNested
       }
  }
  var foreignNested:TestAllTypes.NestedMessage {
       get {
           return builderResult.foreignNested
       }
       set (value) {
           builderResult.hasForeignNested = true
           builderResult.foreignNested = value
       }
  }
  func setForeignNestedBuilder(builderForValue:TestAllTypes.NestedMessageBuilder) -> TestForeignNestedBuilder {
    foreignNested = builderForValue.build()
    return self
  }
  func mergeForeignNested(value:TestAllTypes.NestedMessage) -> TestForeignNestedBuilder {
    if (builderResult.hasForeignNested && builderResult.foreignNested != TestAllTypes.NestedMessage()) {
      builderResult.foreignNested = TestAllTypes.NestedMessage.builderWithPrototype(builderResult.foreignNested).mergeFrom(value).buildPartial()
    } else {
      builderResult.foreignNested = value
    }
    builderResult.hasForeignNested = true
    return self
  }
  func clearForeignNested() -> TestForeignNestedBuilder {
    builderResult.hasForeignNested = false
    builderResult.foreignNested = TestAllTypes.NestedMessage()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestForeignNestedBuilder {
    builderResult = TestForeignNested()
    return self
  }
  override func clone() -> TestForeignNestedBuilder {
    return TestForeignNested.builderWithPrototype(builderResult)
  }
  override func build() -> TestForeignNested {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestForeignNested {
    var returnMe:TestForeignNested = builderResult
    return returnMe
  }
  func mergeFrom(other:TestForeignNested) -> TestForeignNestedBuilder {
    if (other == TestForeignNested()) {
     return self
    }
    if (other.hasForeignNested) {
        mergeForeignNested(other.foreignNested)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestForeignNestedBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestForeignNestedBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestAllTypes.NestedMessageBuilder = TestAllTypes.NestedMessage.builder()
        if hasForeignNested {
          subBuilder.mergeFrom(foreignNested)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        foreignNested = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestEmptyMessage : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEmptyMessage {
    return TestEmptyMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestEmptyMessageBuilder {
    return TestEmptyMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestEmptyMessage) -> TestEmptyMessageBuilder {
    return TestEmptyMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestEmptyMessageBuilder {
    return TestEmptyMessage.builder()
  }
  func toBuilder() -> TestEmptyMessageBuilder {
    return TestEmptyMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestEmptyMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestEmptyMessage.self
  }


  //Meta information declaration end

}

final class TestEmptyMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:TestEmptyMessage

  required override init () {
     builderResult = TestEmptyMessage()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestEmptyMessageBuilder {
    builderResult = TestEmptyMessage()
    return self
  }
  override func clone() -> TestEmptyMessageBuilder {
    return TestEmptyMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestEmptyMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestEmptyMessage {
    var returnMe:TestEmptyMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestEmptyMessage) -> TestEmptyMessageBuilder {
    if (other == TestEmptyMessage()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestEmptyMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEmptyMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestEmptyMessageWithExtensions : ExtendableMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEmptyMessageWithExtensions {
    return TestEmptyMessageWithExtensions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestEmptyMessageWithExtensionsBuilder {
    return TestEmptyMessageWithExtensionsBuilder()
  }
  class func builderWithPrototype(prototype:TestEmptyMessageWithExtensions) -> TestEmptyMessageWithExtensionsBuilder {
    return TestEmptyMessageWithExtensions.builder().mergeFrom(prototype)
  }
  func builder() -> TestEmptyMessageWithExtensionsBuilder {
    return TestEmptyMessageWithExtensions.builder()
  }
  func toBuilder() -> TestEmptyMessageWithExtensionsBuilder {
    return TestEmptyMessageWithExtensions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(1), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestEmptyMessageWithExtensions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestEmptyMessageWithExtensions.self
  }


  //Meta information declaration end

}

final class TestEmptyMessageWithExtensionsBuilder : ExtendableMessageBuilder {
  private var builderResult:TestEmptyMessageWithExtensions

  required override init () {
     builderResult = TestEmptyMessageWithExtensions()
     super.init()
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestEmptyMessageWithExtensionsBuilder {
    builderResult = TestEmptyMessageWithExtensions()
    return self
  }
  override func clone() -> TestEmptyMessageWithExtensionsBuilder {
    return TestEmptyMessageWithExtensions.builderWithPrototype(builderResult)
  }
  override func build() -> TestEmptyMessageWithExtensions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestEmptyMessageWithExtensions {
    var returnMe:TestEmptyMessageWithExtensions = builderResult
    return returnMe
  }
  func mergeFrom(other:TestEmptyMessageWithExtensions) -> TestEmptyMessageWithExtensionsBuilder {
    if (other == TestEmptyMessageWithExtensions()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestEmptyMessageWithExtensionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEmptyMessageWithExtensionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestMultipleExtensionRanges : ExtendableMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(42), endExclusive:Int32(43))
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(4143), endExclusive:Int32(4244))
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(65536), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMultipleExtensionRanges {
    return TestMultipleExtensionRanges.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestMultipleExtensionRangesBuilder {
    return TestMultipleExtensionRangesBuilder()
  }
  class func builderWithPrototype(prototype:TestMultipleExtensionRanges) -> TestMultipleExtensionRangesBuilder {
    return TestMultipleExtensionRanges.builder().mergeFrom(prototype)
  }
  func builder() -> TestMultipleExtensionRangesBuilder {
    return TestMultipleExtensionRanges.builder()
  }
  func toBuilder() -> TestMultipleExtensionRangesBuilder {
    return TestMultipleExtensionRanges.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(42), endExclusive:Int32(43), indent:indent)
    writeExtensionDescription(&output, startInclusive:Int32(4143), endExclusive:Int32(4244), indent:indent)
    writeExtensionDescription(&output, startInclusive:Int32(65536), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(42), endExclusive:Int32(43)))
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(4143), endExclusive:Int32(4244)))
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(65536), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestMultipleExtensionRanges"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestMultipleExtensionRanges.self
  }


  //Meta information declaration end

}

final class TestMultipleExtensionRangesBuilder : ExtendableMessageBuilder {
  private var builderResult:TestMultipleExtensionRanges

  required override init () {
     builderResult = TestMultipleExtensionRanges()
     super.init()
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestMultipleExtensionRangesBuilder {
    builderResult = TestMultipleExtensionRanges()
    return self
  }
  override func clone() -> TestMultipleExtensionRangesBuilder {
    return TestMultipleExtensionRanges.builderWithPrototype(builderResult)
  }
  override func build() -> TestMultipleExtensionRanges {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestMultipleExtensionRanges {
    var returnMe:TestMultipleExtensionRanges = builderResult
    return returnMe
  }
  func mergeFrom(other:TestMultipleExtensionRanges) -> TestMultipleExtensionRangesBuilder {
    if (other == TestMultipleExtensionRanges()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestMultipleExtensionRangesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMultipleExtensionRangesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestReallyLargeTagNumber : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  private(set) var hasBb:Bool = false
  private(set) var bb:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(1, value:a)
    }
    if hasBb {
      output.writeInt32(268435455, value:bb)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(1, value:a)
    }
    if hasBb {
      size += WireFormat.computeInt32Size(268435455, value:bb)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestReallyLargeTagNumberBuilder {
    return TestReallyLargeTagNumberBuilder()
  }
  class func builderWithPrototype(prototype:TestReallyLargeTagNumber) -> TestReallyLargeTagNumberBuilder {
    return TestReallyLargeTagNumber.builder().mergeFrom(prototype)
  }
  func builder() -> TestReallyLargeTagNumberBuilder {
    return TestReallyLargeTagNumber.builder()
  }
  func toBuilder() -> TestReallyLargeTagNumberBuilder {
    return TestReallyLargeTagNumber.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    if hasBb {
      output += "\(indent) bb: \(bb) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          if hasBb {
             hashCode = (hashCode &* 31) &+ bb.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestReallyLargeTagNumber"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestReallyLargeTagNumber.self
  }


  //Meta information declaration end

}

final class TestReallyLargeTagNumberBuilder : GeneratedMessageBuilder {
  private var builderResult:TestReallyLargeTagNumber

  required override init () {
     builderResult = TestReallyLargeTagNumber()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> TestReallyLargeTagNumberBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  var hasBb:Bool {
       get {
            return builderResult.hasBb
       }
  }
  var bb:Int32 {
       get {
            return builderResult.bb
       }
       set (value) {
           builderResult.hasBb = true
           builderResult.bb = value
       }
  }
  func clearBb() -> TestReallyLargeTagNumberBuilder{
       builderResult.hasBb = false
       builderResult.bb = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestReallyLargeTagNumberBuilder {
    builderResult = TestReallyLargeTagNumber()
    return self
  }
  override func clone() -> TestReallyLargeTagNumberBuilder {
    return TestReallyLargeTagNumber.builderWithPrototype(builderResult)
  }
  override func build() -> TestReallyLargeTagNumber {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestReallyLargeTagNumber {
    var returnMe:TestReallyLargeTagNumber = builderResult
    return returnMe
  }
  func mergeFrom(other:TestReallyLargeTagNumber) -> TestReallyLargeTagNumberBuilder {
    if (other == TestReallyLargeTagNumber()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    if other.hasBb {
         bb = other.bb
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestReallyLargeTagNumberBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestReallyLargeTagNumberBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        a = input.readInt32()

      case 2147483640 :
        bb = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestRecursiveMessage : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:TestRecursiveMessage = TestRecursiveMessage()
  private(set) var hasI:Bool = false
  private(set) var i:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeMessage(1, value:a)
    }
    if hasI {
      output.writeInt32(2, value:i)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeMessageSize(1, value:a)
    }
    if hasI {
      size += WireFormat.computeInt32Size(2, value:i)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRecursiveMessage {
    return TestRecursiveMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestRecursiveMessageBuilder {
    return TestRecursiveMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestRecursiveMessage) -> TestRecursiveMessageBuilder {
    return TestRecursiveMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestRecursiveMessageBuilder {
    return TestRecursiveMessage.builder()
  }
  func toBuilder() -> TestRecursiveMessageBuilder {
    return TestRecursiveMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a {\n"
      a.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasI {
      output += "\(indent) i: \(i) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
            hashCode = (hashCode &* 31) &+ a.hashValue
          }
          if hasI {
             hashCode = (hashCode &* 31) &+ i.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestRecursiveMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestRecursiveMessage.self
  }


  //Meta information declaration end

}

final class TestRecursiveMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:TestRecursiveMessage

  required override init () {
     builderResult = TestRecursiveMessage()
     super.init()
  }
  var hasA:Bool {
       get {
           return builderResult.hasA
       }
  }
  var a:TestRecursiveMessage {
       get {
           return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func setABuilder(builderForValue:TestRecursiveMessageBuilder) -> TestRecursiveMessageBuilder {
    a = builderForValue.build()
    return self
  }
  func mergeA(value:TestRecursiveMessage) -> TestRecursiveMessageBuilder {
    if (builderResult.hasA && builderResult.a != TestRecursiveMessage()) {
      builderResult.a = TestRecursiveMessage.builderWithPrototype(builderResult.a).mergeFrom(value).buildPartial()
    } else {
      builderResult.a = value
    }
    builderResult.hasA = true
    return self
  }
  func clearA() -> TestRecursiveMessageBuilder {
    builderResult.hasA = false
    builderResult.a = TestRecursiveMessage()
    return self
  }
  var hasI:Bool {
       get {
            return builderResult.hasI
       }
  }
  var i:Int32 {
       get {
            return builderResult.i
       }
       set (value) {
           builderResult.hasI = true
           builderResult.i = value
       }
  }
  func clearI() -> TestRecursiveMessageBuilder{
       builderResult.hasI = false
       builderResult.i = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestRecursiveMessageBuilder {
    builderResult = TestRecursiveMessage()
    return self
  }
  override func clone() -> TestRecursiveMessageBuilder {
    return TestRecursiveMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestRecursiveMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestRecursiveMessage {
    var returnMe:TestRecursiveMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestRecursiveMessage) -> TestRecursiveMessageBuilder {
    if (other == TestRecursiveMessage()) {
     return self
    }
    if (other.hasA) {
        mergeA(other.a)
    }
    if other.hasI {
         i = other.i
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRecursiveMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRecursiveMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestRecursiveMessageBuilder = TestRecursiveMessage.builder()
        if hasA {
          subBuilder.mergeFrom(a)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        a = subBuilder.buildPartial()

      case 16 :
        i = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestMutualRecursionA : GeneratedMessage {
  private(set) var hasBb:Bool = false
  private(set) var bb:TestMutualRecursionB = TestMutualRecursionB()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasBb {
      output.writeMessage(1, value:bb)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasBb {
      size += WireFormat.computeMessageSize(1, value:bb)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionA {
    return TestMutualRecursionA.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestMutualRecursionABuilder {
    return TestMutualRecursionABuilder()
  }
  class func builderWithPrototype(prototype:TestMutualRecursionA) -> TestMutualRecursionABuilder {
    return TestMutualRecursionA.builder().mergeFrom(prototype)
  }
  func builder() -> TestMutualRecursionABuilder {
    return TestMutualRecursionA.builder()
  }
  func toBuilder() -> TestMutualRecursionABuilder {
    return TestMutualRecursionA.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasBb {
      output += "\(indent) bb {\n"
      bb.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBb {
            hashCode = (hashCode &* 31) &+ bb.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestMutualRecursionA"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestMutualRecursionA.self
  }


  //Meta information declaration end

}

final class TestMutualRecursionABuilder : GeneratedMessageBuilder {
  private var builderResult:TestMutualRecursionA

  required override init () {
     builderResult = TestMutualRecursionA()
     super.init()
  }
  var hasBb:Bool {
       get {
           return builderResult.hasBb
       }
  }
  var bb:TestMutualRecursionB {
       get {
           return builderResult.bb
       }
       set (value) {
           builderResult.hasBb = true
           builderResult.bb = value
       }
  }
  func setBbBuilder(builderForValue:TestMutualRecursionBBuilder) -> TestMutualRecursionABuilder {
    bb = builderForValue.build()
    return self
  }
  func mergeBb(value:TestMutualRecursionB) -> TestMutualRecursionABuilder {
    if (builderResult.hasBb && builderResult.bb != TestMutualRecursionB()) {
      builderResult.bb = TestMutualRecursionB.builderWithPrototype(builderResult.bb).mergeFrom(value).buildPartial()
    } else {
      builderResult.bb = value
    }
    builderResult.hasBb = true
    return self
  }
  func clearBb() -> TestMutualRecursionABuilder {
    builderResult.hasBb = false
    builderResult.bb = TestMutualRecursionB()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestMutualRecursionABuilder {
    builderResult = TestMutualRecursionA()
    return self
  }
  override func clone() -> TestMutualRecursionABuilder {
    return TestMutualRecursionA.builderWithPrototype(builderResult)
  }
  override func build() -> TestMutualRecursionA {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestMutualRecursionA {
    var returnMe:TestMutualRecursionA = builderResult
    return returnMe
  }
  func mergeFrom(other:TestMutualRecursionA) -> TestMutualRecursionABuilder {
    if (other == TestMutualRecursionA()) {
     return self
    }
    if (other.hasBb) {
        mergeBb(other.bb)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestMutualRecursionABuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionABuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestMutualRecursionBBuilder = TestMutualRecursionB.builder()
        if hasBb {
          subBuilder.mergeFrom(bb)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        bb = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestMutualRecursionB : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:TestMutualRecursionA = TestMutualRecursionA()
  private(set) var hasOptionalInt32:Bool = false
  private(set) var optionalInt32:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeMessage(1, value:a)
    }
    if hasOptionalInt32 {
      output.writeInt32(2, value:optionalInt32)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeMessageSize(1, value:a)
    }
    if hasOptionalInt32 {
      size += WireFormat.computeInt32Size(2, value:optionalInt32)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionB {
    return TestMutualRecursionB.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestMutualRecursionBBuilder {
    return TestMutualRecursionBBuilder()
  }
  class func builderWithPrototype(prototype:TestMutualRecursionB) -> TestMutualRecursionBBuilder {
    return TestMutualRecursionB.builder().mergeFrom(prototype)
  }
  func builder() -> TestMutualRecursionBBuilder {
    return TestMutualRecursionB.builder()
  }
  func toBuilder() -> TestMutualRecursionBBuilder {
    return TestMutualRecursionB.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a {\n"
      a.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalInt32 {
      output += "\(indent) optionalInt32: \(optionalInt32) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
            hashCode = (hashCode &* 31) &+ a.hashValue
          }
          if hasOptionalInt32 {
             hashCode = (hashCode &* 31) &+ optionalInt32.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestMutualRecursionB"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestMutualRecursionB.self
  }


  //Meta information declaration end

}

final class TestMutualRecursionBBuilder : GeneratedMessageBuilder {
  private var builderResult:TestMutualRecursionB

  required override init () {
     builderResult = TestMutualRecursionB()
     super.init()
  }
  var hasA:Bool {
       get {
           return builderResult.hasA
       }
  }
  var a:TestMutualRecursionA {
       get {
           return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func setABuilder(builderForValue:TestMutualRecursionABuilder) -> TestMutualRecursionBBuilder {
    a = builderForValue.build()
    return self
  }
  func mergeA(value:TestMutualRecursionA) -> TestMutualRecursionBBuilder {
    if (builderResult.hasA && builderResult.a != TestMutualRecursionA()) {
      builderResult.a = TestMutualRecursionA.builderWithPrototype(builderResult.a).mergeFrom(value).buildPartial()
    } else {
      builderResult.a = value
    }
    builderResult.hasA = true
    return self
  }
  func clearA() -> TestMutualRecursionBBuilder {
    builderResult.hasA = false
    builderResult.a = TestMutualRecursionA()
    return self
  }
  var hasOptionalInt32:Bool {
       get {
            return builderResult.hasOptionalInt32
       }
  }
  var optionalInt32:Int32 {
       get {
            return builderResult.optionalInt32
       }
       set (value) {
           builderResult.hasOptionalInt32 = true
           builderResult.optionalInt32 = value
       }
  }
  func clearOptionalInt32() -> TestMutualRecursionBBuilder{
       builderResult.hasOptionalInt32 = false
       builderResult.optionalInt32 = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestMutualRecursionBBuilder {
    builderResult = TestMutualRecursionB()
    return self
  }
  override func clone() -> TestMutualRecursionBBuilder {
    return TestMutualRecursionB.builderWithPrototype(builderResult)
  }
  override func build() -> TestMutualRecursionB {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestMutualRecursionB {
    var returnMe:TestMutualRecursionB = builderResult
    return returnMe
  }
  func mergeFrom(other:TestMutualRecursionB) -> TestMutualRecursionBBuilder {
    if (other == TestMutualRecursionB()) {
     return self
    }
    if (other.hasA) {
        mergeA(other.a)
    }
    if other.hasOptionalInt32 {
         optionalInt32 = other.optionalInt32
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestMutualRecursionBBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionBBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestMutualRecursionABuilder = TestMutualRecursionA.builder()
        if hasA {
          subBuilder.mergeFrom(a)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        a = subBuilder.buildPartial()

      case 16 :
        optionalInt32 = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestDupFieldNumber : GeneratedMessage {


  //Nested type declaration start

    final public class Foo : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(1, value:a)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(1, value:a)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Foo {
        return TestDupFieldNumber.Foo.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestDupFieldNumber.FooBuilder {
        return TestDupFieldNumber.FooBuilder()
      }
      class func builderWithPrototype(prototype:TestDupFieldNumber.Foo) -> TestDupFieldNumber.FooBuilder {
        return TestDupFieldNumber.Foo.builder().mergeFrom(prototype)
      }
      func builder() -> TestDupFieldNumber.FooBuilder {
        return TestDupFieldNumber.Foo.builder()
      }
      func toBuilder() -> TestDupFieldNumber.FooBuilder {
        return TestDupFieldNumber.Foo.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestDupFieldNumber.Foo"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestDupFieldNumber.Foo.self
      }


      //Meta information declaration end

    }

    final class FooBuilder : GeneratedMessageBuilder {
      private var builderResult:TestDupFieldNumber.Foo

      required override init () {
         builderResult = TestDupFieldNumber.Foo()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestDupFieldNumber.FooBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestDupFieldNumber.FooBuilder {
        builderResult = TestDupFieldNumber.Foo()
        return self
      }
      override func clone() -> TestDupFieldNumber.FooBuilder {
        return TestDupFieldNumber.Foo.builderWithPrototype(builderResult)
      }
      override func build() -> TestDupFieldNumber.Foo {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestDupFieldNumber.Foo {
        var returnMe:TestDupFieldNumber.Foo = builderResult
        return returnMe
      }
      func mergeFrom(other:TestDupFieldNumber.Foo) -> TestDupFieldNumber.FooBuilder {
        if (other == TestDupFieldNumber.Foo()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDupFieldNumber.FooBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.FooBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            a = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class Bar : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(1, value:a)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(1, value:a)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Bar {
        return TestDupFieldNumber.Bar.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestDupFieldNumber.BarBuilder {
        return TestDupFieldNumber.BarBuilder()
      }
      class func builderWithPrototype(prototype:TestDupFieldNumber.Bar) -> TestDupFieldNumber.BarBuilder {
        return TestDupFieldNumber.Bar.builder().mergeFrom(prototype)
      }
      func builder() -> TestDupFieldNumber.BarBuilder {
        return TestDupFieldNumber.Bar.builder()
      }
      func toBuilder() -> TestDupFieldNumber.BarBuilder {
        return TestDupFieldNumber.Bar.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestDupFieldNumber.Bar"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestDupFieldNumber.Bar.self
      }


      //Meta information declaration end

    }

    final class BarBuilder : GeneratedMessageBuilder {
      private var builderResult:TestDupFieldNumber.Bar

      required override init () {
         builderResult = TestDupFieldNumber.Bar()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestDupFieldNumber.BarBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestDupFieldNumber.BarBuilder {
        builderResult = TestDupFieldNumber.Bar()
        return self
      }
      override func clone() -> TestDupFieldNumber.BarBuilder {
        return TestDupFieldNumber.Bar.builderWithPrototype(builderResult)
      }
      override func build() -> TestDupFieldNumber.Bar {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestDupFieldNumber.Bar {
        var returnMe:TestDupFieldNumber.Bar = builderResult
        return returnMe
      }
      func mergeFrom(other:TestDupFieldNumber.Bar) -> TestDupFieldNumber.BarBuilder {
        if (other == TestDupFieldNumber.Bar()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDupFieldNumber.BarBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.BarBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            a = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasA:Bool = false
  private(set) var a:Int32 = Int32(0)

  private(set) var hasFoo:Bool = false
  private(set) var foo:TestDupFieldNumber.Foo = TestDupFieldNumber.Foo()
  private(set) var hasBar:Bool = false
  private(set) var bar:TestDupFieldNumber.Bar = TestDupFieldNumber.Bar()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeInt32(1, value:a)
    }
    if hasFoo {
      output.writeGroup(2, value:foo)
    }
    if hasBar {
      output.writeGroup(3, value:bar)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeInt32Size(1, value:a)
    }
    if hasFoo {
      size += WireFormat.computeGroupSize(2, value:foo)
    }
    if hasBar {
      size += WireFormat.computeGroupSize(3, value:bar)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber {
    return TestDupFieldNumber.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestDupFieldNumberBuilder {
    return TestDupFieldNumberBuilder()
  }
  class func builderWithPrototype(prototype:TestDupFieldNumber) -> TestDupFieldNumberBuilder {
    return TestDupFieldNumber.builder().mergeFrom(prototype)
  }
  func builder() -> TestDupFieldNumberBuilder {
    return TestDupFieldNumber.builder()
  }
  func toBuilder() -> TestDupFieldNumberBuilder {
    return TestDupFieldNumber.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    if hasFoo {
      output += "\(indent) foo {\n"
      foo.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasBar {
      output += "\(indent) bar {\n"
      bar.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          if hasFoo {
            hashCode = (hashCode &* 31) &+ foo.hashValue
          }
          if hasBar {
            hashCode = (hashCode &* 31) &+ bar.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestDupFieldNumber"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestDupFieldNumber.self
  }


  //Meta information declaration end

}

final class TestDupFieldNumberBuilder : GeneratedMessageBuilder {
  private var builderResult:TestDupFieldNumber

  required override init () {
     builderResult = TestDupFieldNumber()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:Int32 {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> TestDupFieldNumberBuilder{
       builderResult.hasA = false
       builderResult.a = Int32(0)
       return self
  }
  var hasFoo:Bool {
       get {
           return builderResult.hasFoo
       }
  }
  var foo:TestDupFieldNumber.Foo {
       get {
           return builderResult.foo
       }
       set (value) {
           builderResult.hasFoo = true
           builderResult.foo = value
       }
  }
  func setFooBuilder(builderForValue:TestDupFieldNumber.FooBuilder) -> TestDupFieldNumberBuilder {
    foo = builderForValue.build()
    return self
  }
  func mergeFoo(value:TestDupFieldNumber.Foo) -> TestDupFieldNumberBuilder {
    if (builderResult.hasFoo && builderResult.foo != TestDupFieldNumber.Foo()) {
      builderResult.foo = TestDupFieldNumber.Foo.builderWithPrototype(builderResult.foo).mergeFrom(value).buildPartial()
    } else {
      builderResult.foo = value
    }
    builderResult.hasFoo = true
    return self
  }
  func clearFoo() -> TestDupFieldNumberBuilder {
    builderResult.hasFoo = false
    builderResult.foo = TestDupFieldNumber.Foo()
    return self
  }
  var hasBar:Bool {
       get {
           return builderResult.hasBar
       }
  }
  var bar:TestDupFieldNumber.Bar {
       get {
           return builderResult.bar
       }
       set (value) {
           builderResult.hasBar = true
           builderResult.bar = value
       }
  }
  func setBarBuilder(builderForValue:TestDupFieldNumber.BarBuilder) -> TestDupFieldNumberBuilder {
    bar = builderForValue.build()
    return self
  }
  func mergeBar(value:TestDupFieldNumber.Bar) -> TestDupFieldNumberBuilder {
    if (builderResult.hasBar && builderResult.bar != TestDupFieldNumber.Bar()) {
      builderResult.bar = TestDupFieldNumber.Bar.builderWithPrototype(builderResult.bar).mergeFrom(value).buildPartial()
    } else {
      builderResult.bar = value
    }
    builderResult.hasBar = true
    return self
  }
  func clearBar() -> TestDupFieldNumberBuilder {
    builderResult.hasBar = false
    builderResult.bar = TestDupFieldNumber.Bar()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestDupFieldNumberBuilder {
    builderResult = TestDupFieldNumber()
    return self
  }
  override func clone() -> TestDupFieldNumberBuilder {
    return TestDupFieldNumber.builderWithPrototype(builderResult)
  }
  override func build() -> TestDupFieldNumber {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestDupFieldNumber {
    var returnMe:TestDupFieldNumber = builderResult
    return returnMe
  }
  func mergeFrom(other:TestDupFieldNumber) -> TestDupFieldNumberBuilder {
    if (other == TestDupFieldNumber()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    if (other.hasFoo) {
        mergeFoo(other.foo)
    }
    if (other.hasBar) {
        mergeBar(other.bar)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDupFieldNumberBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumberBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        a = input.readInt32()

      case 19 :
        var subBuilder:TestDupFieldNumber.FooBuilder = TestDupFieldNumber.Foo.builder()
        if hasFoo {
          subBuilder.mergeFrom(foo)
        }
        input.readGroup(2, builder:subBuilder, extensionRegistry:extensionRegistry)
        foo = subBuilder.buildPartial()

      case 27 :
        var subBuilder:TestDupFieldNumber.BarBuilder = TestDupFieldNumber.Bar.builder()
        if hasBar {
          subBuilder.mergeFrom(bar)
        }
        input.readGroup(3, builder:subBuilder, extensionRegistry:extensionRegistry)
        bar = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestEagerMessage : GeneratedMessage {
  private(set) var hasSubMessage:Bool = false
  private(set) var subMessage:TestAllTypes = TestAllTypes()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasSubMessage {
      output.writeMessage(1, value:subMessage)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasSubMessage {
      size += WireFormat.computeMessageSize(1, value:subMessage)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestEagerMessage {
    return TestEagerMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestEagerMessage {
    return TestEagerMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestEagerMessage {
    return TestEagerMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestEagerMessage {
    return TestEagerMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestEagerMessage {
    return TestEagerMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEagerMessage {
    return TestEagerMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestEagerMessageBuilder {
    return TestEagerMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestEagerMessage) -> TestEagerMessageBuilder {
    return TestEagerMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestEagerMessageBuilder {
    return TestEagerMessage.builder()
  }
  func toBuilder() -> TestEagerMessageBuilder {
    return TestEagerMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasSubMessage {
      output += "\(indent) subMessage {\n"
      subMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSubMessage {
            hashCode = (hashCode &* 31) &+ subMessage.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestEagerMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestEagerMessage.self
  }


  //Meta information declaration end

}

final class TestEagerMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:TestEagerMessage

  required override init () {
     builderResult = TestEagerMessage()
     super.init()
  }
  var hasSubMessage:Bool {
       get {
           return builderResult.hasSubMessage
       }
  }
  var subMessage:TestAllTypes {
       get {
           return builderResult.subMessage
       }
       set (value) {
           builderResult.hasSubMessage = true
           builderResult.subMessage = value
       }
  }
  func setSubMessageBuilder(builderForValue:TestAllTypesBuilder) -> TestEagerMessageBuilder {
    subMessage = builderForValue.build()
    return self
  }
  func mergeSubMessage(value:TestAllTypes) -> TestEagerMessageBuilder {
    if (builderResult.hasSubMessage && builderResult.subMessage != TestAllTypes()) {
      builderResult.subMessage = TestAllTypes.builderWithPrototype(builderResult.subMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.subMessage = value
    }
    builderResult.hasSubMessage = true
    return self
  }
  func clearSubMessage() -> TestEagerMessageBuilder {
    builderResult.hasSubMessage = false
    builderResult.subMessage = TestAllTypes()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestEagerMessageBuilder {
    builderResult = TestEagerMessage()
    return self
  }
  override func clone() -> TestEagerMessageBuilder {
    return TestEagerMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestEagerMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestEagerMessage {
    var returnMe:TestEagerMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestEagerMessage) -> TestEagerMessageBuilder {
    if (other == TestEagerMessage()) {
     return self
    }
    if (other.hasSubMessage) {
        mergeSubMessage(other.subMessage)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestEagerMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestEagerMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasSubMessage {
          subBuilder.mergeFrom(subMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        subMessage = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestLazyMessage : GeneratedMessage {
  private(set) var hasSubMessage:Bool = false
  private(set) var subMessage:TestAllTypes = TestAllTypes()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasSubMessage {
      output.writeMessage(1, value:subMessage)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasSubMessage {
      size += WireFormat.computeMessageSize(1, value:subMessage)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestLazyMessage {
    return TestLazyMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestLazyMessage {
    return TestLazyMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestLazyMessage {
    return TestLazyMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestLazyMessage {
    return TestLazyMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestLazyMessage {
    return TestLazyMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestLazyMessage {
    return TestLazyMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestLazyMessageBuilder {
    return TestLazyMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestLazyMessage) -> TestLazyMessageBuilder {
    return TestLazyMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestLazyMessageBuilder {
    return TestLazyMessage.builder()
  }
  func toBuilder() -> TestLazyMessageBuilder {
    return TestLazyMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasSubMessage {
      output += "\(indent) subMessage {\n"
      subMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSubMessage {
            hashCode = (hashCode &* 31) &+ subMessage.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestLazyMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestLazyMessage.self
  }


  //Meta information declaration end

}

final class TestLazyMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:TestLazyMessage

  required override init () {
     builderResult = TestLazyMessage()
     super.init()
  }
  var hasSubMessage:Bool {
       get {
           return builderResult.hasSubMessage
       }
  }
  var subMessage:TestAllTypes {
       get {
           return builderResult.subMessage
       }
       set (value) {
           builderResult.hasSubMessage = true
           builderResult.subMessage = value
       }
  }
  func setSubMessageBuilder(builderForValue:TestAllTypesBuilder) -> TestLazyMessageBuilder {
    subMessage = builderForValue.build()
    return self
  }
  func mergeSubMessage(value:TestAllTypes) -> TestLazyMessageBuilder {
    if (builderResult.hasSubMessage && builderResult.subMessage != TestAllTypes()) {
      builderResult.subMessage = TestAllTypes.builderWithPrototype(builderResult.subMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.subMessage = value
    }
    builderResult.hasSubMessage = true
    return self
  }
  func clearSubMessage() -> TestLazyMessageBuilder {
    builderResult.hasSubMessage = false
    builderResult.subMessage = TestAllTypes()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestLazyMessageBuilder {
    builderResult = TestLazyMessage()
    return self
  }
  override func clone() -> TestLazyMessageBuilder {
    return TestLazyMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestLazyMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestLazyMessage {
    var returnMe:TestLazyMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestLazyMessage) -> TestLazyMessageBuilder {
    if (other == TestLazyMessage()) {
     return self
    }
    if (other.hasSubMessage) {
        mergeSubMessage(other.subMessage)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestLazyMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestLazyMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasSubMessage {
          subBuilder.mergeFrom(subMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        subMessage = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestNestedMessageHasBits : GeneratedMessage {


  //Nested type declaration start

    final public class NestedMessage : GeneratedMessage {
      private(set) var nestedmessageRepeatedInt32:Array<Int32> = Array<Int32>()
      private(set) var nestedmessageRepeatedForeignmessage:Array<ForeignMessage>  = Array<ForeignMessage>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if !nestedmessageRepeatedInt32.isEmpty {
          for value in nestedmessageRepeatedInt32 {
            output.writeInt32(1, value:value)
          }
        }
        for element in nestedmessageRepeatedForeignmessage {
            output.writeMessage(2, value:element)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        var dataSizeNestedmessageRepeatedInt32:Int32 = 0
        for element in nestedmessageRepeatedInt32 {
            dataSizeNestedmessageRepeatedInt32 += WireFormat.computeInt32SizeNoTag(element)
        }
        size += dataSizeNestedmessageRepeatedInt32
        size += 1 * Int32(nestedmessageRepeatedInt32.count)
        for element in nestedmessageRepeatedForeignmessage {
            size += WireFormat.computeMessageSize(2, value:element)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits.NestedMessage {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestNestedMessageHasBits.NestedMessageBuilder {
        return TestNestedMessageHasBits.NestedMessageBuilder()
      }
      class func builderWithPrototype(prototype:TestNestedMessageHasBits.NestedMessage) -> TestNestedMessageHasBits.NestedMessageBuilder {
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFrom(prototype)
      }
      func builder() -> TestNestedMessageHasBits.NestedMessageBuilder {
        return TestNestedMessageHasBits.NestedMessage.builder()
      }
      func toBuilder() -> TestNestedMessageHasBits.NestedMessageBuilder {
        return TestNestedMessageHasBits.NestedMessage.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        var nestedmessageRepeatedInt32ElementIndex:Int = 0
        for element in nestedmessageRepeatedInt32  {
            output += "\(indent) nestedmessageRepeatedInt32[\(nestedmessageRepeatedInt32ElementIndex)]: \(element)\n"
            nestedmessageRepeatedInt32ElementIndex++
        }
        var nestedmessageRepeatedForeignmessageElementIndex:Int = 0
        for element in nestedmessageRepeatedForeignmessage {
            output += "\(indent) nestedmessageRepeatedForeignmessage[\(nestedmessageRepeatedForeignmessageElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            nestedmessageRepeatedForeignmessageElementIndex++
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for element in nestedmessageRepeatedInt32 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in nestedmessageRepeatedForeignmessage {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestNestedMessageHasBits.NestedMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestNestedMessageHasBits.NestedMessage.self
      }


      //Meta information declaration end

    }

    final class NestedMessageBuilder : GeneratedMessageBuilder {
      private var builderResult:TestNestedMessageHasBits.NestedMessage

      required override init () {
         builderResult = TestNestedMessageHasBits.NestedMessage()
         super.init()
      }
      var nestedmessageRepeatedInt32:Array<Int32> {
           get {
               return builderResult.nestedmessageRepeatedInt32
           }
           set (array) {
               builderResult.nestedmessageRepeatedInt32 = array
           }
      }
      func clearNestedmessageRepeatedInt32() -> TestNestedMessageHasBits.NestedMessageBuilder {
         builderResult.nestedmessageRepeatedInt32.removeAll(keepCapacity: false)
         return self
      }
      var nestedmessageRepeatedForeignmessage:Array<ForeignMessage> {
           get {
               return builderResult.nestedmessageRepeatedForeignmessage
           }
           set (value) {
               builderResult.nestedmessageRepeatedForeignmessage = value
           }
      }
      func clearNestedmessageRepeatedForeignmessage() -> TestNestedMessageHasBits.NestedMessageBuilder {
        builderResult.nestedmessageRepeatedForeignmessage.removeAll(keepCapacity: false)
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestNestedMessageHasBits.NestedMessageBuilder {
        builderResult = TestNestedMessageHasBits.NestedMessage()
        return self
      }
      override func clone() -> TestNestedMessageHasBits.NestedMessageBuilder {
        return TestNestedMessageHasBits.NestedMessage.builderWithPrototype(builderResult)
      }
      override func build() -> TestNestedMessageHasBits.NestedMessage {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestNestedMessageHasBits.NestedMessage {
        var returnMe:TestNestedMessageHasBits.NestedMessage = builderResult
        return returnMe
      }
      func mergeFrom(other:TestNestedMessageHasBits.NestedMessage) -> TestNestedMessageHasBits.NestedMessageBuilder {
        if (other == TestNestedMessageHasBits.NestedMessage()) {
         return self
        }
        if !other.nestedmessageRepeatedInt32.isEmpty {
            builderResult.nestedmessageRepeatedInt32 += other.nestedmessageRepeatedInt32
        }
        if !other.nestedmessageRepeatedForeignmessage.isEmpty  {
           builderResult.nestedmessageRepeatedForeignmessage += other.nestedmessageRepeatedForeignmessage
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestNestedMessageHasBits.NestedMessageBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits.NestedMessageBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            nestedmessageRepeatedInt32 += [input.readInt32()]

          case 18 :
            var subBuilder = ForeignMessage.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            nestedmessageRepeatedForeignmessage += [subBuilder.buildPartial()]

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasOptionalNestedMessage:Bool = false
  private(set) var optionalNestedMessage:TestNestedMessageHasBits.NestedMessage = TestNestedMessageHasBits.NestedMessage()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasOptionalNestedMessage {
      output.writeMessage(1, value:optionalNestedMessage)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasOptionalNestedMessage {
      size += WireFormat.computeMessageSize(1, value:optionalNestedMessage)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits {
    return TestNestedMessageHasBits.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestNestedMessageHasBitsBuilder {
    return TestNestedMessageHasBitsBuilder()
  }
  class func builderWithPrototype(prototype:TestNestedMessageHasBits) -> TestNestedMessageHasBitsBuilder {
    return TestNestedMessageHasBits.builder().mergeFrom(prototype)
  }
  func builder() -> TestNestedMessageHasBitsBuilder {
    return TestNestedMessageHasBits.builder()
  }
  func toBuilder() -> TestNestedMessageHasBitsBuilder {
    return TestNestedMessageHasBits.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasOptionalNestedMessage {
      output += "\(indent) optionalNestedMessage {\n"
      optionalNestedMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasOptionalNestedMessage {
            hashCode = (hashCode &* 31) &+ optionalNestedMessage.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestNestedMessageHasBits"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestNestedMessageHasBits.self
  }


  //Meta information declaration end

}

final class TestNestedMessageHasBitsBuilder : GeneratedMessageBuilder {
  private var builderResult:TestNestedMessageHasBits

  required override init () {
     builderResult = TestNestedMessageHasBits()
     super.init()
  }
  var hasOptionalNestedMessage:Bool {
       get {
           return builderResult.hasOptionalNestedMessage
       }
  }
  var optionalNestedMessage:TestNestedMessageHasBits.NestedMessage {
       get {
           return builderResult.optionalNestedMessage
       }
       set (value) {
           builderResult.hasOptionalNestedMessage = true
           builderResult.optionalNestedMessage = value
       }
  }
  func setOptionalNestedMessageBuilder(builderForValue:TestNestedMessageHasBits.NestedMessageBuilder) -> TestNestedMessageHasBitsBuilder {
    optionalNestedMessage = builderForValue.build()
    return self
  }
  func mergeOptionalNestedMessage(value:TestNestedMessageHasBits.NestedMessage) -> TestNestedMessageHasBitsBuilder {
    if (builderResult.hasOptionalNestedMessage && builderResult.optionalNestedMessage != TestNestedMessageHasBits.NestedMessage()) {
      builderResult.optionalNestedMessage = TestNestedMessageHasBits.NestedMessage.builderWithPrototype(builderResult.optionalNestedMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalNestedMessage = value
    }
    builderResult.hasOptionalNestedMessage = true
    return self
  }
  func clearOptionalNestedMessage() -> TestNestedMessageHasBitsBuilder {
    builderResult.hasOptionalNestedMessage = false
    builderResult.optionalNestedMessage = TestNestedMessageHasBits.NestedMessage()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestNestedMessageHasBitsBuilder {
    builderResult = TestNestedMessageHasBits()
    return self
  }
  override func clone() -> TestNestedMessageHasBitsBuilder {
    return TestNestedMessageHasBits.builderWithPrototype(builderResult)
  }
  override func build() -> TestNestedMessageHasBits {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestNestedMessageHasBits {
    var returnMe:TestNestedMessageHasBits = builderResult
    return returnMe
  }
  func mergeFrom(other:TestNestedMessageHasBits) -> TestNestedMessageHasBitsBuilder {
    if (other == TestNestedMessageHasBits()) {
     return self
    }
    if (other.hasOptionalNestedMessage) {
        mergeOptionalNestedMessage(other.optionalNestedMessage)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestNestedMessageHasBitsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBitsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestNestedMessageHasBits.NestedMessageBuilder = TestNestedMessageHasBits.NestedMessage.builder()
        if hasOptionalNestedMessage {
          subBuilder.mergeFrom(optionalNestedMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalNestedMessage = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestCamelCaseFieldNames : GeneratedMessage {
  private(set) var hasPrimitiveField:Bool = false
  private(set) var primitiveField:Int32 = Int32(0)

  private(set) var hasStringField:Bool = false
  private(set) var stringField:String = ""

  private(set) var enumField:ForeignEnum = ForeignEnum.ForeignFoo
  private(set) var hasEnumField:Bool = false
  private(set) var hasMessageField:Bool = false
  private(set) var messageField:ForeignMessage = ForeignMessage()
  private(set) var hasStringPieceField:Bool = false
  private(set) var stringPieceField:String = ""

  private(set) var hasCordField:Bool = false
  private(set) var cordField:String = ""

  private(set) var repeatedPrimitiveField:Array<Int32> = Array<Int32>()
  private(set) var repeatedStringField:Array<String> = Array<String>()
  private var repeatedEnumFieldMemoizedSerializedSize:Int32 = 0
  private(set) var repeatedEnumField:Array<ForeignEnum> = Array<ForeignEnum>()
  private(set) var repeatedMessageField:Array<ForeignMessage>  = Array<ForeignMessage>()
  private(set) var repeatedStringPieceField:Array<String> = Array<String>()
  private(set) var repeatedCordField:Array<String> = Array<String>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasPrimitiveField {
      output.writeInt32(1, value:primitiveField)
    }
    if hasStringField {
      output.writeString(2, value:stringField)
    }
    if hasEnumField {
      output.writeEnum(3, value:enumField.rawValue)
    }
    if hasMessageField {
      output.writeMessage(4, value:messageField)
    }
    if hasStringPieceField {
      output.writeString(5, value:stringPieceField)
    }
    if hasCordField {
      output.writeString(6, value:cordField)
    }
    if !repeatedPrimitiveField.isEmpty {
      for value in repeatedPrimitiveField {
        output.writeInt32(7, value:value)
      }
    }
    if !repeatedStringField.isEmpty {
      for value in repeatedStringField {
        output.writeString(8, value:value)
      }
    }
    for value in repeatedEnumField {
        output.writeEnum(9, value:value.rawValue)
    }
    for element in repeatedMessageField {
        output.writeMessage(10, value:element)
    }
    if !repeatedStringPieceField.isEmpty {
      for value in repeatedStringPieceField {
        output.writeString(11, value:value)
      }
    }
    if !repeatedCordField.isEmpty {
      for value in repeatedCordField {
        output.writeString(12, value:value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasPrimitiveField {
      size += WireFormat.computeInt32Size(1, value:primitiveField)
    }
    if hasStringField {
      size += WireFormat.computeStringSize(2, value:stringField)
    }
    if (hasEnumField) {
      size += WireFormat.computeEnumSize(3, value:enumField.rawValue)
    }
    if hasMessageField {
      size += WireFormat.computeMessageSize(4, value:messageField)
    }
    if hasStringPieceField {
      size += WireFormat.computeStringSize(5, value:stringPieceField)
    }
    if hasCordField {
      size += WireFormat.computeStringSize(6, value:cordField)
    }
    var dataSizeRepeatedPrimitiveField:Int32 = 0
    for element in repeatedPrimitiveField {
        dataSizeRepeatedPrimitiveField += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizeRepeatedPrimitiveField
    size += 1 * Int32(repeatedPrimitiveField.count)
    var dataSizeRepeatedStringField:Int32 = 0
    for element in repeatedStringField {
        dataSizeRepeatedStringField += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedStringField
    size += 1 * Int32(repeatedStringField.count)
    var dataSizerepeatedEnumField:Int32 = 0
    for value in repeatedEnumField {
        dataSizerepeatedEnumField += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizerepeatedEnumField
    size += (1 * Int32(repeatedEnumField.count))
    for element in repeatedMessageField {
        size += WireFormat.computeMessageSize(10, value:element)
    }
    var dataSizeRepeatedStringPieceField:Int32 = 0
    for element in repeatedStringPieceField {
        dataSizeRepeatedStringPieceField += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedStringPieceField
    size += 1 * Int32(repeatedStringPieceField.count)
    var dataSizeRepeatedCordField:Int32 = 0
    for element in repeatedCordField {
        dataSizeRepeatedCordField += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedCordField
    size += 1 * Int32(repeatedCordField.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestCamelCaseFieldNamesBuilder {
    return TestCamelCaseFieldNamesBuilder()
  }
  class func builderWithPrototype(prototype:TestCamelCaseFieldNames) -> TestCamelCaseFieldNamesBuilder {
    return TestCamelCaseFieldNames.builder().mergeFrom(prototype)
  }
  func builder() -> TestCamelCaseFieldNamesBuilder {
    return TestCamelCaseFieldNames.builder()
  }
  func toBuilder() -> TestCamelCaseFieldNamesBuilder {
    return TestCamelCaseFieldNames.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasPrimitiveField {
      output += "\(indent) primitiveField: \(primitiveField) \n"
    }
    if hasStringField {
      output += "\(indent) stringField: \(stringField) \n"
    }
    if (hasEnumField) {
      output += "\(indent) enumField: \(enumField.rawValue)\n"
    }
    if hasMessageField {
      output += "\(indent) messageField {\n"
      messageField.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasStringPieceField {
      output += "\(indent) stringPieceField: \(stringPieceField) \n"
    }
    if hasCordField {
      output += "\(indent) cordField: \(cordField) \n"
    }
    var repeatedPrimitiveFieldElementIndex:Int = 0
    for element in repeatedPrimitiveField  {
        output += "\(indent) repeatedPrimitiveField[\(repeatedPrimitiveFieldElementIndex)]: \(element)\n"
        repeatedPrimitiveFieldElementIndex++
    }
    var repeatedStringFieldElementIndex:Int = 0
    for element in repeatedStringField  {
        output += "\(indent) repeatedStringField[\(repeatedStringFieldElementIndex)]: \(element)\n"
        repeatedStringFieldElementIndex++
    }
    var repeatedEnumFieldElementIndex:Int = 0
    for element in repeatedEnumField {
        output += "\(indent) repeatedEnumField[\(repeatedEnumFieldElementIndex)]: \(element.rawValue)"
        repeatedEnumFieldElementIndex++
    }
    var repeatedMessageFieldElementIndex:Int = 0
    for element in repeatedMessageField {
        output += "\(indent) repeatedMessageField[\(repeatedMessageFieldElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedMessageFieldElementIndex++
    }
    var repeatedStringPieceFieldElementIndex:Int = 0
    for element in repeatedStringPieceField  {
        output += "\(indent) repeatedStringPieceField[\(repeatedStringPieceFieldElementIndex)]: \(element)\n"
        repeatedStringPieceFieldElementIndex++
    }
    var repeatedCordFieldElementIndex:Int = 0
    for element in repeatedCordField  {
        output += "\(indent) repeatedCordField[\(repeatedCordFieldElementIndex)]: \(element)\n"
        repeatedCordFieldElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasPrimitiveField {
             hashCode = (hashCode &* 31) &+ primitiveField.hashValue
          }
          if hasStringField {
             hashCode = (hashCode &* 31) &+ stringField.hashValue
          }
          if hasEnumField {
             hashCode = (hashCode &* 31) &+ Int(enumField.rawValue)
          }
          if hasMessageField {
            hashCode = (hashCode &* 31) &+ messageField.hashValue
          }
          if hasStringPieceField {
             hashCode = (hashCode &* 31) &+ stringPieceField.hashValue
          }
          if hasCordField {
             hashCode = (hashCode &* 31) &+ cordField.hashValue
          }
          for element in repeatedPrimitiveField {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedStringField {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedEnumField {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          for element in repeatedMessageField {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedStringPieceField {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedCordField {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestCamelCaseFieldNames"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestCamelCaseFieldNames.self
  }


  //Meta information declaration end

}

final class TestCamelCaseFieldNamesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestCamelCaseFieldNames

  required override init () {
     builderResult = TestCamelCaseFieldNames()
     super.init()
  }
  var hasPrimitiveField:Bool {
       get {
            return builderResult.hasPrimitiveField
       }
  }
  var primitiveField:Int32 {
       get {
            return builderResult.primitiveField
       }
       set (value) {
           builderResult.hasPrimitiveField = true
           builderResult.primitiveField = value
       }
  }
  func clearPrimitiveField() -> TestCamelCaseFieldNamesBuilder{
       builderResult.hasPrimitiveField = false
       builderResult.primitiveField = Int32(0)
       return self
  }
  var hasStringField:Bool {
       get {
            return builderResult.hasStringField
       }
  }
  var stringField:String {
       get {
            return builderResult.stringField
       }
       set (value) {
           builderResult.hasStringField = true
           builderResult.stringField = value
       }
  }
  func clearStringField() -> TestCamelCaseFieldNamesBuilder{
       builderResult.hasStringField = false
       builderResult.stringField = ""
       return self
  }
    var hasEnumField:Bool{
        get {
            return builderResult.hasEnumField
        }
    }
    var enumField:ForeignEnum {
        get {
            return builderResult.enumField
        }
        set (value) {
            builderResult.hasEnumField = true
            builderResult.enumField = value
        }
    }
    func clearEnumField() -> TestCamelCaseFieldNamesBuilder {
       builderResult.hasEnumField = false
       builderResult.enumField = .ForeignFoo
       return self
    }
  var hasMessageField:Bool {
       get {
           return builderResult.hasMessageField
       }
  }
  var messageField:ForeignMessage {
       get {
           return builderResult.messageField
       }
       set (value) {
           builderResult.hasMessageField = true
           builderResult.messageField = value
       }
  }
  func setMessageFieldBuilder(builderForValue:ForeignMessageBuilder) -> TestCamelCaseFieldNamesBuilder {
    messageField = builderForValue.build()
    return self
  }
  func mergeMessageField(value:ForeignMessage) -> TestCamelCaseFieldNamesBuilder {
    if (builderResult.hasMessageField && builderResult.messageField != ForeignMessage()) {
      builderResult.messageField = ForeignMessage.builderWithPrototype(builderResult.messageField).mergeFrom(value).buildPartial()
    } else {
      builderResult.messageField = value
    }
    builderResult.hasMessageField = true
    return self
  }
  func clearMessageField() -> TestCamelCaseFieldNamesBuilder {
    builderResult.hasMessageField = false
    builderResult.messageField = ForeignMessage()
    return self
  }
  var hasStringPieceField:Bool {
       get {
            return builderResult.hasStringPieceField
       }
  }
  var stringPieceField:String {
       get {
            return builderResult.stringPieceField
       }
       set (value) {
           builderResult.hasStringPieceField = true
           builderResult.stringPieceField = value
       }
  }
  func clearStringPieceField() -> TestCamelCaseFieldNamesBuilder{
       builderResult.hasStringPieceField = false
       builderResult.stringPieceField = ""
       return self
  }
  var hasCordField:Bool {
       get {
            return builderResult.hasCordField
       }
  }
  var cordField:String {
       get {
            return builderResult.cordField
       }
       set (value) {
           builderResult.hasCordField = true
           builderResult.cordField = value
       }
  }
  func clearCordField() -> TestCamelCaseFieldNamesBuilder{
       builderResult.hasCordField = false
       builderResult.cordField = ""
       return self
  }
  var repeatedPrimitiveField:Array<Int32> {
       get {
           return builderResult.repeatedPrimitiveField
       }
       set (array) {
           builderResult.repeatedPrimitiveField = array
       }
  }
  func clearRepeatedPrimitiveField() -> TestCamelCaseFieldNamesBuilder {
     builderResult.repeatedPrimitiveField.removeAll(keepCapacity: false)
     return self
  }
  var repeatedStringField:Array<String> {
       get {
           return builderResult.repeatedStringField
       }
       set (array) {
           builderResult.repeatedStringField = array
       }
  }
  func clearRepeatedStringField() -> TestCamelCaseFieldNamesBuilder {
     builderResult.repeatedStringField.removeAll(keepCapacity: false)
     return self
  }
  var repeatedEnumField:Array<ForeignEnum> {
      get {
          return builderResult.repeatedEnumField
      }
      set (value) {
          builderResult.repeatedEnumField += value
      }
  }
  func clearRepeatedEnumField() -> TestCamelCaseFieldNamesBuilder {
    builderResult.repeatedEnumField.removeAll(keepCapacity: false)
    return self
  }
  var repeatedMessageField:Array<ForeignMessage> {
       get {
           return builderResult.repeatedMessageField
       }
       set (value) {
           builderResult.repeatedMessageField = value
       }
  }
  func clearRepeatedMessageField() -> TestCamelCaseFieldNamesBuilder {
    builderResult.repeatedMessageField.removeAll(keepCapacity: false)
    return self
  }
  var repeatedStringPieceField:Array<String> {
       get {
           return builderResult.repeatedStringPieceField
       }
       set (array) {
           builderResult.repeatedStringPieceField = array
       }
  }
  func clearRepeatedStringPieceField() -> TestCamelCaseFieldNamesBuilder {
     builderResult.repeatedStringPieceField.removeAll(keepCapacity: false)
     return self
  }
  var repeatedCordField:Array<String> {
       get {
           return builderResult.repeatedCordField
       }
       set (array) {
           builderResult.repeatedCordField = array
       }
  }
  func clearRepeatedCordField() -> TestCamelCaseFieldNamesBuilder {
     builderResult.repeatedCordField.removeAll(keepCapacity: false)
     return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestCamelCaseFieldNamesBuilder {
    builderResult = TestCamelCaseFieldNames()
    return self
  }
  override func clone() -> TestCamelCaseFieldNamesBuilder {
    return TestCamelCaseFieldNames.builderWithPrototype(builderResult)
  }
  override func build() -> TestCamelCaseFieldNames {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestCamelCaseFieldNames {
    var returnMe:TestCamelCaseFieldNames = builderResult
    return returnMe
  }
  func mergeFrom(other:TestCamelCaseFieldNames) -> TestCamelCaseFieldNamesBuilder {
    if (other == TestCamelCaseFieldNames()) {
     return self
    }
    if other.hasPrimitiveField {
         primitiveField = other.primitiveField
    }
    if other.hasStringField {
         stringField = other.stringField
    }
    if other.hasEnumField {
         enumField = other.enumField
    }
    if (other.hasMessageField) {
        mergeMessageField(other.messageField)
    }
    if other.hasStringPieceField {
         stringPieceField = other.stringPieceField
    }
    if other.hasCordField {
         cordField = other.cordField
    }
    if !other.repeatedPrimitiveField.isEmpty {
        builderResult.repeatedPrimitiveField += other.repeatedPrimitiveField
    }
    if !other.repeatedStringField.isEmpty {
        builderResult.repeatedStringField += other.repeatedStringField
    }
    if !other.repeatedEnumField.isEmpty {
       builderResult.repeatedEnumField += other.repeatedEnumField
    }
    if !other.repeatedMessageField.isEmpty  {
       builderResult.repeatedMessageField += other.repeatedMessageField
    }
    if !other.repeatedStringPieceField.isEmpty {
        builderResult.repeatedStringPieceField += other.repeatedStringPieceField
    }
    if !other.repeatedCordField.isEmpty {
        builderResult.repeatedCordField += other.repeatedCordField
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestCamelCaseFieldNamesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestCamelCaseFieldNamesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        primitiveField = input.readInt32()

      case 18 :
        stringField = input.readString()

      case 24 :
        var value = input.readEnum()
        var enumMergResult:ForeignEnum = ForeignEnum(rawValue:value)!
        if (ForeignEnum.IsValidValue(enumMergResult)) {
             enumField = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(3, value:Int64(value))
        }

      case 34 :
        var subBuilder:ForeignMessageBuilder = ForeignMessage.builder()
        if hasMessageField {
          subBuilder.mergeFrom(messageField)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        messageField = subBuilder.buildPartial()

      case 42 :
        stringPieceField = input.readString()

      case 50 :
        cordField = input.readString()

      case 56 :
        repeatedPrimitiveField += [input.readInt32()]

      case 66 :
        repeatedStringField += [input.readString()]

      case 72 :
        var value:ForeignEnum = ForeignEnum(rawValue:input.readEnum())!
        if ForeignEnum.IsValidValue(value) {
             builderResult.repeatedEnumField += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(9, value:Int64(value.rawValue))
        }

      case 82 :
        var subBuilder = ForeignMessage.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedMessageField += [subBuilder.buildPartial()]

      case 90 :
        repeatedStringPieceField += [input.readString()]

      case 98 :
        repeatedCordField += [input.readString()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestFieldOrderings : ExtendableMessage {
  private(set) var hasMyString:Bool = false
  private(set) var myString:String = ""

  private(set) var hasMyInt:Bool = false
  private(set) var myInt:Int64 = Int64(0)

  private(set) var hasMyFloat:Bool = false
  private(set) var myFloat:Float = Float(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMyInt {
      output.writeInt64(1, value:myInt)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(2), endExclusive:Int32(11))
    if hasMyString {
      output.writeString(11, value:myString)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(12), endExclusive:Int32(101))
    if hasMyFloat {
      output.writeFloat(101, value:myFloat)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasMyInt {
      size += WireFormat.computeInt64Size(1, value:myInt)
    }
    if hasMyString {
      size += WireFormat.computeStringSize(11, value:myString)
    }
    if hasMyFloat {
      size += WireFormat.computeFloatSize(101, value:myFloat)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestFieldOrderings {
    return TestFieldOrderings.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestFieldOrderingsBuilder {
    return TestFieldOrderingsBuilder()
  }
  class func builderWithPrototype(prototype:TestFieldOrderings) -> TestFieldOrderingsBuilder {
    return TestFieldOrderings.builder().mergeFrom(prototype)
  }
  func builder() -> TestFieldOrderingsBuilder {
    return TestFieldOrderings.builder()
  }
  func toBuilder() -> TestFieldOrderingsBuilder {
    return TestFieldOrderings.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasMyInt {
      output += "\(indent) myInt: \(myInt) \n"
    }
    writeExtensionDescription(&output, startInclusive:Int32(2), endExclusive:Int32(11), indent:indent)
    if hasMyString {
      output += "\(indent) myString: \(myString) \n"
    }
    writeExtensionDescription(&output, startInclusive:Int32(12), endExclusive:Int32(101), indent:indent)
    if hasMyFloat {
      output += "\(indent) myFloat: \(myFloat) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMyInt {
             hashCode = (hashCode &* 31) &+ myInt.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(2), endExclusive:Int32(11)))
          if hasMyString {
             hashCode = (hashCode &* 31) &+ myString.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(12), endExclusive:Int32(101)))
          if hasMyFloat {
             hashCode = (hashCode &* 31) &+ myFloat.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestFieldOrderings"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestFieldOrderings.self
  }


  //Meta information declaration end

}

final class TestFieldOrderingsBuilder : ExtendableMessageBuilder {
  private var builderResult:TestFieldOrderings

  required override init () {
     builderResult = TestFieldOrderings()
     super.init()
  }
  var hasMyString:Bool {
       get {
            return builderResult.hasMyString
       }
  }
  var myString:String {
       get {
            return builderResult.myString
       }
       set (value) {
           builderResult.hasMyString = true
           builderResult.myString = value
       }
  }
  func clearMyString() -> TestFieldOrderingsBuilder{
       builderResult.hasMyString = false
       builderResult.myString = ""
       return self
  }
  var hasMyInt:Bool {
       get {
            return builderResult.hasMyInt
       }
  }
  var myInt:Int64 {
       get {
            return builderResult.myInt
       }
       set (value) {
           builderResult.hasMyInt = true
           builderResult.myInt = value
       }
  }
  func clearMyInt() -> TestFieldOrderingsBuilder{
       builderResult.hasMyInt = false
       builderResult.myInt = Int64(0)
       return self
  }
  var hasMyFloat:Bool {
       get {
            return builderResult.hasMyFloat
       }
  }
  var myFloat:Float {
       get {
            return builderResult.myFloat
       }
       set (value) {
           builderResult.hasMyFloat = true
           builderResult.myFloat = value
       }
  }
  func clearMyFloat() -> TestFieldOrderingsBuilder{
       builderResult.hasMyFloat = false
       builderResult.myFloat = Float(0)
       return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestFieldOrderingsBuilder {
    builderResult = TestFieldOrderings()
    return self
  }
  override func clone() -> TestFieldOrderingsBuilder {
    return TestFieldOrderings.builderWithPrototype(builderResult)
  }
  override func build() -> TestFieldOrderings {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestFieldOrderings {
    var returnMe:TestFieldOrderings = builderResult
    return returnMe
  }
  func mergeFrom(other:TestFieldOrderings) -> TestFieldOrderingsBuilder {
    if (other == TestFieldOrderings()) {
     return self
    }
    if other.hasMyString {
         myString = other.myString
    }
    if other.hasMyInt {
         myInt = other.myInt
    }
    if other.hasMyFloat {
         myFloat = other.myFloat
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestFieldOrderingsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestFieldOrderingsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        myInt = input.readInt64()

      case 90 :
        myString = input.readString()

      case 813 :
        myFloat = input.readFloat()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestExtremeDefaultValues : GeneratedMessage {
  private(set) var hasEscapedBytes:Bool = false
  private(set) var escapedBytes:Array<Byte> = ([Byte]() + "testsr".utf8)

  private(set) var hasLargeUint32:Bool = false
  private(set) var largeUint32:UInt32 = UInt32(65535)

  private(set) var hasLargeUint64:Bool = false
  private(set) var largeUint64:UInt64 = UInt64(16777215)

  private(set) var hasSmallInt32:Bool = false
  private(set) var smallInt32:Int32 = Int32(-2147483647)

  private(set) var hasSmallInt64:Bool = false
  private(set) var smallInt64:Int64 = Int64(-9223372036854775807)

  private(set) var hasReallySmallInt32:Bool = false
  private(set) var reallySmallInt32:Int32 = Int32(-2147483648)

  private(set) var hasReallySmallInt64:Bool = false
  private(set) var reallySmallInt64:Int64 = Int64(-576460752303423488)

  private(set) var hasUtf8String:Bool = false
  private(set) var utf8String:String = "tests"

  private(set) var hasZeroFloat:Bool = false
  private(set) var zeroFloat:Float = Float(0)

  private(set) var hasOneFloat:Bool = false
  private(set) var oneFloat:Float = Float(1)

  private(set) var hasSmallFloat:Bool = false
  private(set) var smallFloat:Float = Float(1.5)

  private(set) var hasNegativeOneFloat:Bool = false
  private(set) var negativeOneFloat:Float = Float(-1)

  private(set) var hasNegativeFloat:Bool = false
  private(set) var negativeFloat:Float = Float(-1.5)

  private(set) var hasLargeFloat:Bool = false
  private(set) var largeFloat:Float = Float(2e+08)

  private(set) var hasSmallNegativeFloat:Bool = false
  private(set) var smallNegativeFloat:Float = Float(-8e-28)

  private(set) var hasInfDouble:Bool = false
  private(set) var infDouble:Double = Double(HUGE)

  private(set) var hasNegInfDouble:Bool = false
  private(set) var negInfDouble:Double = Double(-HUGE)

  private(set) var hasNanDouble:Bool = false
  private(set) var nanDouble:Double = 0.0

  private(set) var hasInfFloat:Bool = false
  private(set) var infFloat:Float = HUGE

  private(set) var hasNegInfFloat:Bool = false
  private(set) var negInfFloat:Float = -HUGE

  private(set) var hasNanFloat:Bool = false
  private(set) var nanFloat:Float = 0.0

  private(set) var hasCppTrigraph:Bool = false
  private(set) var cppTrigraph:String = "teststsrs"

  private(set) var hasStringWithZero:Bool = false
  private(set) var stringWithZero:String = "hel\000lo"

  private(set) var hasBytesWithZero:Bool = false
  private(set) var bytesWithZero:Array<Byte> = ([Byte]() + "wor\000ld".utf8)

  private(set) var hasStringPieceWithZero:Bool = false
  private(set) var stringPieceWithZero:String = "ab\000c"

  private(set) var hasCordWithZero:Bool = false
  private(set) var cordWithZero:String = "12\0003"

  private(set) var hasReplacementString:Bool = false
  private(set) var replacementString:String = "${unknown}"

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasEscapedBytes {
      output.writeData(1, value:escapedBytes)
    }
    if hasLargeUint32 {
      output.writeUInt32(2, value:largeUint32)
    }
    if hasLargeUint64 {
      output.writeUInt64(3, value:largeUint64)
    }
    if hasSmallInt32 {
      output.writeInt32(4, value:smallInt32)
    }
    if hasSmallInt64 {
      output.writeInt64(5, value:smallInt64)
    }
    if hasUtf8String {
      output.writeString(6, value:utf8String)
    }
    if hasZeroFloat {
      output.writeFloat(7, value:zeroFloat)
    }
    if hasOneFloat {
      output.writeFloat(8, value:oneFloat)
    }
    if hasSmallFloat {
      output.writeFloat(9, value:smallFloat)
    }
    if hasNegativeOneFloat {
      output.writeFloat(10, value:negativeOneFloat)
    }
    if hasNegativeFloat {
      output.writeFloat(11, value:negativeFloat)
    }
    if hasLargeFloat {
      output.writeFloat(12, value:largeFloat)
    }
    if hasSmallNegativeFloat {
      output.writeFloat(13, value:smallNegativeFloat)
    }
    if hasInfDouble {
      output.writeDouble(14, value:infDouble)
    }
    if hasNegInfDouble {
      output.writeDouble(15, value:negInfDouble)
    }
    if hasNanDouble {
      output.writeDouble(16, value:nanDouble)
    }
    if hasInfFloat {
      output.writeFloat(17, value:infFloat)
    }
    if hasNegInfFloat {
      output.writeFloat(18, value:negInfFloat)
    }
    if hasNanFloat {
      output.writeFloat(19, value:nanFloat)
    }
    if hasCppTrigraph {
      output.writeString(20, value:cppTrigraph)
    }
    if hasReallySmallInt32 {
      output.writeInt32(21, value:reallySmallInt32)
    }
    if hasReallySmallInt64 {
      output.writeInt64(22, value:reallySmallInt64)
    }
    if hasStringWithZero {
      output.writeString(23, value:stringWithZero)
    }
    if hasBytesWithZero {
      output.writeData(24, value:bytesWithZero)
    }
    if hasStringPieceWithZero {
      output.writeString(25, value:stringPieceWithZero)
    }
    if hasCordWithZero {
      output.writeString(26, value:cordWithZero)
    }
    if hasReplacementString {
      output.writeString(27, value:replacementString)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasEscapedBytes {
      size += WireFormat.computeDataSize(1, value:escapedBytes)
    }
    if hasLargeUint32 {
      size += WireFormat.computeUInt32Size(2, value:largeUint32)
    }
    if hasLargeUint64 {
      size += WireFormat.computeUInt64Size(3, value:largeUint64)
    }
    if hasSmallInt32 {
      size += WireFormat.computeInt32Size(4, value:smallInt32)
    }
    if hasSmallInt64 {
      size += WireFormat.computeInt64Size(5, value:smallInt64)
    }
    if hasUtf8String {
      size += WireFormat.computeStringSize(6, value:utf8String)
    }
    if hasZeroFloat {
      size += WireFormat.computeFloatSize(7, value:zeroFloat)
    }
    if hasOneFloat {
      size += WireFormat.computeFloatSize(8, value:oneFloat)
    }
    if hasSmallFloat {
      size += WireFormat.computeFloatSize(9, value:smallFloat)
    }
    if hasNegativeOneFloat {
      size += WireFormat.computeFloatSize(10, value:negativeOneFloat)
    }
    if hasNegativeFloat {
      size += WireFormat.computeFloatSize(11, value:negativeFloat)
    }
    if hasLargeFloat {
      size += WireFormat.computeFloatSize(12, value:largeFloat)
    }
    if hasSmallNegativeFloat {
      size += WireFormat.computeFloatSize(13, value:smallNegativeFloat)
    }
    if hasInfDouble {
      size += WireFormat.computeDoubleSize(14, value:infDouble)
    }
    if hasNegInfDouble {
      size += WireFormat.computeDoubleSize(15, value:negInfDouble)
    }
    if hasNanDouble {
      size += WireFormat.computeDoubleSize(16, value:nanDouble)
    }
    if hasInfFloat {
      size += WireFormat.computeFloatSize(17, value:infFloat)
    }
    if hasNegInfFloat {
      size += WireFormat.computeFloatSize(18, value:negInfFloat)
    }
    if hasNanFloat {
      size += WireFormat.computeFloatSize(19, value:nanFloat)
    }
    if hasCppTrigraph {
      size += WireFormat.computeStringSize(20, value:cppTrigraph)
    }
    if hasReallySmallInt32 {
      size += WireFormat.computeInt32Size(21, value:reallySmallInt32)
    }
    if hasReallySmallInt64 {
      size += WireFormat.computeInt64Size(22, value:reallySmallInt64)
    }
    if hasStringWithZero {
      size += WireFormat.computeStringSize(23, value:stringWithZero)
    }
    if hasBytesWithZero {
      size += WireFormat.computeDataSize(24, value:bytesWithZero)
    }
    if hasStringPieceWithZero {
      size += WireFormat.computeStringSize(25, value:stringPieceWithZero)
    }
    if hasCordWithZero {
      size += WireFormat.computeStringSize(26, value:cordWithZero)
    }
    if hasReplacementString {
      size += WireFormat.computeStringSize(27, value:replacementString)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestExtremeDefaultValues {
    return TestExtremeDefaultValues.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestExtremeDefaultValuesBuilder {
    return TestExtremeDefaultValuesBuilder()
  }
  class func builderWithPrototype(prototype:TestExtremeDefaultValues) -> TestExtremeDefaultValuesBuilder {
    return TestExtremeDefaultValues.builder().mergeFrom(prototype)
  }
  func builder() -> TestExtremeDefaultValuesBuilder {
    return TestExtremeDefaultValues.builder()
  }
  func toBuilder() -> TestExtremeDefaultValuesBuilder {
    return TestExtremeDefaultValues.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasEscapedBytes {
      output += "\(indent) escapedBytes: \(escapedBytes) \n"
    }
    if hasLargeUint32 {
      output += "\(indent) largeUint32: \(largeUint32) \n"
    }
    if hasLargeUint64 {
      output += "\(indent) largeUint64: \(largeUint64) \n"
    }
    if hasSmallInt32 {
      output += "\(indent) smallInt32: \(smallInt32) \n"
    }
    if hasSmallInt64 {
      output += "\(indent) smallInt64: \(smallInt64) \n"
    }
    if hasUtf8String {
      output += "\(indent) utf8String: \(utf8String) \n"
    }
    if hasZeroFloat {
      output += "\(indent) zeroFloat: \(zeroFloat) \n"
    }
    if hasOneFloat {
      output += "\(indent) oneFloat: \(oneFloat) \n"
    }
    if hasSmallFloat {
      output += "\(indent) smallFloat: \(smallFloat) \n"
    }
    if hasNegativeOneFloat {
      output += "\(indent) negativeOneFloat: \(negativeOneFloat) \n"
    }
    if hasNegativeFloat {
      output += "\(indent) negativeFloat: \(negativeFloat) \n"
    }
    if hasLargeFloat {
      output += "\(indent) largeFloat: \(largeFloat) \n"
    }
    if hasSmallNegativeFloat {
      output += "\(indent) smallNegativeFloat: \(smallNegativeFloat) \n"
    }
    if hasInfDouble {
      output += "\(indent) infDouble: \(infDouble) \n"
    }
    if hasNegInfDouble {
      output += "\(indent) negInfDouble: \(negInfDouble) \n"
    }
    if hasNanDouble {
      output += "\(indent) nanDouble: \(nanDouble) \n"
    }
    if hasInfFloat {
      output += "\(indent) infFloat: \(infFloat) \n"
    }
    if hasNegInfFloat {
      output += "\(indent) negInfFloat: \(negInfFloat) \n"
    }
    if hasNanFloat {
      output += "\(indent) nanFloat: \(nanFloat) \n"
    }
    if hasCppTrigraph {
      output += "\(indent) cppTrigraph: \(cppTrigraph) \n"
    }
    if hasReallySmallInt32 {
      output += "\(indent) reallySmallInt32: \(reallySmallInt32) \n"
    }
    if hasReallySmallInt64 {
      output += "\(indent) reallySmallInt64: \(reallySmallInt64) \n"
    }
    if hasStringWithZero {
      output += "\(indent) stringWithZero: \(stringWithZero) \n"
    }
    if hasBytesWithZero {
      output += "\(indent) bytesWithZero: \(bytesWithZero) \n"
    }
    if hasStringPieceWithZero {
      output += "\(indent) stringPieceWithZero: \(stringPieceWithZero) \n"
    }
    if hasCordWithZero {
      output += "\(indent) cordWithZero: \(cordWithZero) \n"
    }
    if hasReplacementString {
      output += "\(indent) replacementString: \(replacementString) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for value in escapedBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasLargeUint32 {
             hashCode = (hashCode &* 31) &+ largeUint32.hashValue
          }
          if hasLargeUint64 {
             hashCode = (hashCode &* 31) &+ largeUint64.hashValue
          }
          if hasSmallInt32 {
             hashCode = (hashCode &* 31) &+ smallInt32.hashValue
          }
          if hasSmallInt64 {
             hashCode = (hashCode &* 31) &+ smallInt64.hashValue
          }
          if hasUtf8String {
             hashCode = (hashCode &* 31) &+ utf8String.hashValue
          }
          if hasZeroFloat {
             hashCode = (hashCode &* 31) &+ zeroFloat.hashValue
          }
          if hasOneFloat {
             hashCode = (hashCode &* 31) &+ oneFloat.hashValue
          }
          if hasSmallFloat {
             hashCode = (hashCode &* 31) &+ smallFloat.hashValue
          }
          if hasNegativeOneFloat {
             hashCode = (hashCode &* 31) &+ negativeOneFloat.hashValue
          }
          if hasNegativeFloat {
             hashCode = (hashCode &* 31) &+ negativeFloat.hashValue
          }
          if hasLargeFloat {
             hashCode = (hashCode &* 31) &+ largeFloat.hashValue
          }
          if hasSmallNegativeFloat {
             hashCode = (hashCode &* 31) &+ smallNegativeFloat.hashValue
          }
          if hasInfDouble {
             hashCode = (hashCode &* 31) &+ infDouble.hashValue
          }
          if hasNegInfDouble {
             hashCode = (hashCode &* 31) &+ negInfDouble.hashValue
          }
          if hasNanDouble {
             hashCode = (hashCode &* 31) &+ nanDouble.hashValue
          }
          if hasInfFloat {
             hashCode = (hashCode &* 31) &+ infFloat.hashValue
          }
          if hasNegInfFloat {
             hashCode = (hashCode &* 31) &+ negInfFloat.hashValue
          }
          if hasNanFloat {
             hashCode = (hashCode &* 31) &+ nanFloat.hashValue
          }
          if hasCppTrigraph {
             hashCode = (hashCode &* 31) &+ cppTrigraph.hashValue
          }
          if hasReallySmallInt32 {
             hashCode = (hashCode &* 31) &+ reallySmallInt32.hashValue
          }
          if hasReallySmallInt64 {
             hashCode = (hashCode &* 31) &+ reallySmallInt64.hashValue
          }
          if hasStringWithZero {
             hashCode = (hashCode &* 31) &+ stringWithZero.hashValue
          }
          for value in bytesWithZero {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasStringPieceWithZero {
             hashCode = (hashCode &* 31) &+ stringPieceWithZero.hashValue
          }
          if hasCordWithZero {
             hashCode = (hashCode &* 31) &+ cordWithZero.hashValue
          }
          if hasReplacementString {
             hashCode = (hashCode &* 31) &+ replacementString.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestExtremeDefaultValues"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestExtremeDefaultValues.self
  }


  //Meta information declaration end

}

final class TestExtremeDefaultValuesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestExtremeDefaultValues

  required override init () {
     builderResult = TestExtremeDefaultValues()
     super.init()
  }
  var hasEscapedBytes:Bool {
       get {
            return builderResult.hasEscapedBytes
       }
  }
  var escapedBytes:Array<Byte> {
       get {
            return builderResult.escapedBytes
       }
       set (value) {
           builderResult.hasEscapedBytes = true
           builderResult.escapedBytes = value
       }
  }
  func clearEscapedBytes() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasEscapedBytes = false
       builderResult.escapedBytes = ([Byte]() + "testsr".utf8)
       return self
  }
  var hasLargeUint32:Bool {
       get {
            return builderResult.hasLargeUint32
       }
  }
  var largeUint32:UInt32 {
       get {
            return builderResult.largeUint32
       }
       set (value) {
           builderResult.hasLargeUint32 = true
           builderResult.largeUint32 = value
       }
  }
  func clearLargeUint32() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasLargeUint32 = false
       builderResult.largeUint32 = UInt32(65535)
       return self
  }
  var hasLargeUint64:Bool {
       get {
            return builderResult.hasLargeUint64
       }
  }
  var largeUint64:UInt64 {
       get {
            return builderResult.largeUint64
       }
       set (value) {
           builderResult.hasLargeUint64 = true
           builderResult.largeUint64 = value
       }
  }
  func clearLargeUint64() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasLargeUint64 = false
       builderResult.largeUint64 = UInt64(16777215)
       return self
  }
  var hasSmallInt32:Bool {
       get {
            return builderResult.hasSmallInt32
       }
  }
  var smallInt32:Int32 {
       get {
            return builderResult.smallInt32
       }
       set (value) {
           builderResult.hasSmallInt32 = true
           builderResult.smallInt32 = value
       }
  }
  func clearSmallInt32() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasSmallInt32 = false
       builderResult.smallInt32 = Int32(-2147483647)
       return self
  }
  var hasSmallInt64:Bool {
       get {
            return builderResult.hasSmallInt64
       }
  }
  var smallInt64:Int64 {
       get {
            return builderResult.smallInt64
       }
       set (value) {
           builderResult.hasSmallInt64 = true
           builderResult.smallInt64 = value
       }
  }
  func clearSmallInt64() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasSmallInt64 = false
       builderResult.smallInt64 = Int64(-9223372036854775807)
       return self
  }
  var hasReallySmallInt32:Bool {
       get {
            return builderResult.hasReallySmallInt32
       }
  }
  var reallySmallInt32:Int32 {
       get {
            return builderResult.reallySmallInt32
       }
       set (value) {
           builderResult.hasReallySmallInt32 = true
           builderResult.reallySmallInt32 = value
       }
  }
  func clearReallySmallInt32() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasReallySmallInt32 = false
       builderResult.reallySmallInt32 = Int32(-2147483648)
       return self
  }
  var hasReallySmallInt64:Bool {
       get {
            return builderResult.hasReallySmallInt64
       }
  }
  var reallySmallInt64:Int64 {
       get {
            return builderResult.reallySmallInt64
       }
       set (value) {
           builderResult.hasReallySmallInt64 = true
           builderResult.reallySmallInt64 = value
       }
  }
  func clearReallySmallInt64() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasReallySmallInt64 = false
       builderResult.reallySmallInt64 = Int64(-576460752303423488)
       return self
  }
  var hasUtf8String:Bool {
       get {
            return builderResult.hasUtf8String
       }
  }
  var utf8String:String {
       get {
            return builderResult.utf8String
       }
       set (value) {
           builderResult.hasUtf8String = true
           builderResult.utf8String = value
       }
  }
  func clearUtf8String() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasUtf8String = false
       builderResult.utf8String = "tests"
       return self
  }
  var hasZeroFloat:Bool {
       get {
            return builderResult.hasZeroFloat
       }
  }
  var zeroFloat:Float {
       get {
            return builderResult.zeroFloat
       }
       set (value) {
           builderResult.hasZeroFloat = true
           builderResult.zeroFloat = value
       }
  }
  func clearZeroFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasZeroFloat = false
       builderResult.zeroFloat = Float(0)
       return self
  }
  var hasOneFloat:Bool {
       get {
            return builderResult.hasOneFloat
       }
  }
  var oneFloat:Float {
       get {
            return builderResult.oneFloat
       }
       set (value) {
           builderResult.hasOneFloat = true
           builderResult.oneFloat = value
       }
  }
  func clearOneFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasOneFloat = false
       builderResult.oneFloat = Float(1)
       return self
  }
  var hasSmallFloat:Bool {
       get {
            return builderResult.hasSmallFloat
       }
  }
  var smallFloat:Float {
       get {
            return builderResult.smallFloat
       }
       set (value) {
           builderResult.hasSmallFloat = true
           builderResult.smallFloat = value
       }
  }
  func clearSmallFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasSmallFloat = false
       builderResult.smallFloat = Float(1.5)
       return self
  }
  var hasNegativeOneFloat:Bool {
       get {
            return builderResult.hasNegativeOneFloat
       }
  }
  var negativeOneFloat:Float {
       get {
            return builderResult.negativeOneFloat
       }
       set (value) {
           builderResult.hasNegativeOneFloat = true
           builderResult.negativeOneFloat = value
       }
  }
  func clearNegativeOneFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNegativeOneFloat = false
       builderResult.negativeOneFloat = Float(-1)
       return self
  }
  var hasNegativeFloat:Bool {
       get {
            return builderResult.hasNegativeFloat
       }
  }
  var negativeFloat:Float {
       get {
            return builderResult.negativeFloat
       }
       set (value) {
           builderResult.hasNegativeFloat = true
           builderResult.negativeFloat = value
       }
  }
  func clearNegativeFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNegativeFloat = false
       builderResult.negativeFloat = Float(-1.5)
       return self
  }
  var hasLargeFloat:Bool {
       get {
            return builderResult.hasLargeFloat
       }
  }
  var largeFloat:Float {
       get {
            return builderResult.largeFloat
       }
       set (value) {
           builderResult.hasLargeFloat = true
           builderResult.largeFloat = value
       }
  }
  func clearLargeFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasLargeFloat = false
       builderResult.largeFloat = Float(2e+08)
       return self
  }
  var hasSmallNegativeFloat:Bool {
       get {
            return builderResult.hasSmallNegativeFloat
       }
  }
  var smallNegativeFloat:Float {
       get {
            return builderResult.smallNegativeFloat
       }
       set (value) {
           builderResult.hasSmallNegativeFloat = true
           builderResult.smallNegativeFloat = value
       }
  }
  func clearSmallNegativeFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasSmallNegativeFloat = false
       builderResult.smallNegativeFloat = Float(-8e-28)
       return self
  }
  var hasInfDouble:Bool {
       get {
            return builderResult.hasInfDouble
       }
  }
  var infDouble:Double {
       get {
            return builderResult.infDouble
       }
       set (value) {
           builderResult.hasInfDouble = true
           builderResult.infDouble = value
       }
  }
  func clearInfDouble() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasInfDouble = false
       builderResult.infDouble = Double(HUGE)
       return self
  }
  var hasNegInfDouble:Bool {
       get {
            return builderResult.hasNegInfDouble
       }
  }
  var negInfDouble:Double {
       get {
            return builderResult.negInfDouble
       }
       set (value) {
           builderResult.hasNegInfDouble = true
           builderResult.negInfDouble = value
       }
  }
  func clearNegInfDouble() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNegInfDouble = false
       builderResult.negInfDouble = Double(-HUGE)
       return self
  }
  var hasNanDouble:Bool {
       get {
            return builderResult.hasNanDouble
       }
  }
  var nanDouble:Double {
       get {
            return builderResult.nanDouble
       }
       set (value) {
           builderResult.hasNanDouble = true
           builderResult.nanDouble = value
       }
  }
  func clearNanDouble() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNanDouble = false
       builderResult.nanDouble = 0.0
       return self
  }
  var hasInfFloat:Bool {
       get {
            return builderResult.hasInfFloat
       }
  }
  var infFloat:Float {
       get {
            return builderResult.infFloat
       }
       set (value) {
           builderResult.hasInfFloat = true
           builderResult.infFloat = value
       }
  }
  func clearInfFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasInfFloat = false
       builderResult.infFloat = HUGE
       return self
  }
  var hasNegInfFloat:Bool {
       get {
            return builderResult.hasNegInfFloat
       }
  }
  var negInfFloat:Float {
       get {
            return builderResult.negInfFloat
       }
       set (value) {
           builderResult.hasNegInfFloat = true
           builderResult.negInfFloat = value
       }
  }
  func clearNegInfFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNegInfFloat = false
       builderResult.negInfFloat = -HUGE
       return self
  }
  var hasNanFloat:Bool {
       get {
            return builderResult.hasNanFloat
       }
  }
  var nanFloat:Float {
       get {
            return builderResult.nanFloat
       }
       set (value) {
           builderResult.hasNanFloat = true
           builderResult.nanFloat = value
       }
  }
  func clearNanFloat() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasNanFloat = false
       builderResult.nanFloat = 0.0
       return self
  }
  var hasCppTrigraph:Bool {
       get {
            return builderResult.hasCppTrigraph
       }
  }
  var cppTrigraph:String {
       get {
            return builderResult.cppTrigraph
       }
       set (value) {
           builderResult.hasCppTrigraph = true
           builderResult.cppTrigraph = value
       }
  }
  func clearCppTrigraph() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasCppTrigraph = false
       builderResult.cppTrigraph = "teststsrs"
       return self
  }
  var hasStringWithZero:Bool {
       get {
            return builderResult.hasStringWithZero
       }
  }
  var stringWithZero:String {
       get {
            return builderResult.stringWithZero
       }
       set (value) {
           builderResult.hasStringWithZero = true
           builderResult.stringWithZero = value
       }
  }
  func clearStringWithZero() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasStringWithZero = false
       builderResult.stringWithZero = "hel\000lo"
       return self
  }
  var hasBytesWithZero:Bool {
       get {
            return builderResult.hasBytesWithZero
       }
  }
  var bytesWithZero:Array<Byte> {
       get {
            return builderResult.bytesWithZero
       }
       set (value) {
           builderResult.hasBytesWithZero = true
           builderResult.bytesWithZero = value
       }
  }
  func clearBytesWithZero() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasBytesWithZero = false
       builderResult.bytesWithZero = ([Byte]() + "wor\000ld".utf8)
       return self
  }
  var hasStringPieceWithZero:Bool {
       get {
            return builderResult.hasStringPieceWithZero
       }
  }
  var stringPieceWithZero:String {
       get {
            return builderResult.stringPieceWithZero
       }
       set (value) {
           builderResult.hasStringPieceWithZero = true
           builderResult.stringPieceWithZero = value
       }
  }
  func clearStringPieceWithZero() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasStringPieceWithZero = false
       builderResult.stringPieceWithZero = "ab\000c"
       return self
  }
  var hasCordWithZero:Bool {
       get {
            return builderResult.hasCordWithZero
       }
  }
  var cordWithZero:String {
       get {
            return builderResult.cordWithZero
       }
       set (value) {
           builderResult.hasCordWithZero = true
           builderResult.cordWithZero = value
       }
  }
  func clearCordWithZero() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasCordWithZero = false
       builderResult.cordWithZero = "12\0003"
       return self
  }
  var hasReplacementString:Bool {
       get {
            return builderResult.hasReplacementString
       }
  }
  var replacementString:String {
       get {
            return builderResult.replacementString
       }
       set (value) {
           builderResult.hasReplacementString = true
           builderResult.replacementString = value
       }
  }
  func clearReplacementString() -> TestExtremeDefaultValuesBuilder{
       builderResult.hasReplacementString = false
       builderResult.replacementString = "${unknown}"
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestExtremeDefaultValuesBuilder {
    builderResult = TestExtremeDefaultValues()
    return self
  }
  override func clone() -> TestExtremeDefaultValuesBuilder {
    return TestExtremeDefaultValues.builderWithPrototype(builderResult)
  }
  override func build() -> TestExtremeDefaultValues {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestExtremeDefaultValues {
    var returnMe:TestExtremeDefaultValues = builderResult
    return returnMe
  }
  func mergeFrom(other:TestExtremeDefaultValues) -> TestExtremeDefaultValuesBuilder {
    if (other == TestExtremeDefaultValues()) {
     return self
    }
    if other.hasEscapedBytes {
         escapedBytes = other.escapedBytes
    }
    if other.hasLargeUint32 {
         largeUint32 = other.largeUint32
    }
    if other.hasLargeUint64 {
         largeUint64 = other.largeUint64
    }
    if other.hasSmallInt32 {
         smallInt32 = other.smallInt32
    }
    if other.hasSmallInt64 {
         smallInt64 = other.smallInt64
    }
    if other.hasReallySmallInt32 {
         reallySmallInt32 = other.reallySmallInt32
    }
    if other.hasReallySmallInt64 {
         reallySmallInt64 = other.reallySmallInt64
    }
    if other.hasUtf8String {
         utf8String = other.utf8String
    }
    if other.hasZeroFloat {
         zeroFloat = other.zeroFloat
    }
    if other.hasOneFloat {
         oneFloat = other.oneFloat
    }
    if other.hasSmallFloat {
         smallFloat = other.smallFloat
    }
    if other.hasNegativeOneFloat {
         negativeOneFloat = other.negativeOneFloat
    }
    if other.hasNegativeFloat {
         negativeFloat = other.negativeFloat
    }
    if other.hasLargeFloat {
         largeFloat = other.largeFloat
    }
    if other.hasSmallNegativeFloat {
         smallNegativeFloat = other.smallNegativeFloat
    }
    if other.hasInfDouble {
         infDouble = other.infDouble
    }
    if other.hasNegInfDouble {
         negInfDouble = other.negInfDouble
    }
    if other.hasNanDouble {
         nanDouble = other.nanDouble
    }
    if other.hasInfFloat {
         infFloat = other.infFloat
    }
    if other.hasNegInfFloat {
         negInfFloat = other.negInfFloat
    }
    if other.hasNanFloat {
         nanFloat = other.nanFloat
    }
    if other.hasCppTrigraph {
         cppTrigraph = other.cppTrigraph
    }
    if other.hasStringWithZero {
         stringWithZero = other.stringWithZero
    }
    if other.hasBytesWithZero {
         bytesWithZero = other.bytesWithZero
    }
    if other.hasStringPieceWithZero {
         stringPieceWithZero = other.stringPieceWithZero
    }
    if other.hasCordWithZero {
         cordWithZero = other.cordWithZero
    }
    if other.hasReplacementString {
         replacementString = other.replacementString
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestExtremeDefaultValuesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestExtremeDefaultValuesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        escapedBytes = input.readData()

      case 16 :
        largeUint32 = input.readUInt32()

      case 24 :
        largeUint64 = input.readUInt64()

      case 32 :
        smallInt32 = input.readInt32()

      case 40 :
        smallInt64 = input.readInt64()

      case 50 :
        utf8String = input.readString()

      case 61 :
        zeroFloat = input.readFloat()

      case 69 :
        oneFloat = input.readFloat()

      case 77 :
        smallFloat = input.readFloat()

      case 85 :
        negativeOneFloat = input.readFloat()

      case 93 :
        negativeFloat = input.readFloat()

      case 101 :
        largeFloat = input.readFloat()

      case 109 :
        smallNegativeFloat = input.readFloat()

      case 113 :
        infDouble = input.readDouble()

      case 121 :
        negInfDouble = input.readDouble()

      case 129 :
        nanDouble = input.readDouble()

      case 141 :
        infFloat = input.readFloat()

      case 149 :
        negInfFloat = input.readFloat()

      case 157 :
        nanFloat = input.readFloat()

      case 162 :
        cppTrigraph = input.readString()

      case 168 :
        reallySmallInt32 = input.readInt32()

      case 176 :
        reallySmallInt64 = input.readInt64()

      case 186 :
        stringWithZero = input.readString()

      case 194 :
        bytesWithZero = input.readData()

      case 202 :
        stringPieceWithZero = input.readString()

      case 210 :
        cordWithZero = input.readString()

      case 218 :
        replacementString = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class SparseEnumMessage : GeneratedMessage {
  private(set) var sparseEnum:TestSparseEnum = TestSparseEnum.SparseA
  private(set) var hasSparseEnum:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasSparseEnum {
      output.writeEnum(1, value:sparseEnum.rawValue)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if (hasSparseEnum) {
      size += WireFormat.computeEnumSize(1, value:sparseEnum.rawValue)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SparseEnumMessage {
    return SparseEnumMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> SparseEnumMessageBuilder {
    return SparseEnumMessageBuilder()
  }
  class func builderWithPrototype(prototype:SparseEnumMessage) -> SparseEnumMessageBuilder {
    return SparseEnumMessage.builder().mergeFrom(prototype)
  }
  func builder() -> SparseEnumMessageBuilder {
    return SparseEnumMessage.builder()
  }
  func toBuilder() -> SparseEnumMessageBuilder {
    return SparseEnumMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if (hasSparseEnum) {
      output += "\(indent) sparseEnum: \(sparseEnum.rawValue)\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSparseEnum {
             hashCode = (hashCode &* 31) &+ Int(sparseEnum.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SparseEnumMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return SparseEnumMessage.self
  }


  //Meta information declaration end

}

final class SparseEnumMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:SparseEnumMessage

  required override init () {
     builderResult = SparseEnumMessage()
     super.init()
  }
    var hasSparseEnum:Bool{
        get {
            return builderResult.hasSparseEnum
        }
    }
    var sparseEnum:TestSparseEnum {
        get {
            return builderResult.sparseEnum
        }
        set (value) {
            builderResult.hasSparseEnum = true
            builderResult.sparseEnum = value
        }
    }
    func clearSparseEnum() -> SparseEnumMessageBuilder {
       builderResult.hasSparseEnum = false
       builderResult.sparseEnum = .SparseA
       return self
    }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> SparseEnumMessageBuilder {
    builderResult = SparseEnumMessage()
    return self
  }
  override func clone() -> SparseEnumMessageBuilder {
    return SparseEnumMessage.builderWithPrototype(builderResult)
  }
  override func build() -> SparseEnumMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> SparseEnumMessage {
    var returnMe:SparseEnumMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:SparseEnumMessage) -> SparseEnumMessageBuilder {
    if (other == SparseEnumMessage()) {
     return self
    }
    if other.hasSparseEnum {
         sparseEnum = other.sparseEnum
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->SparseEnumMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SparseEnumMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        var value = input.readEnum()
        var enumMergResult:TestSparseEnum = TestSparseEnum(rawValue:value)!
        if (TestSparseEnum.IsValidValue(enumMergResult)) {
             sparseEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(1, value:Int64(value))
        }

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class OneString : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeString(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeStringSize(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> OneString {
    return OneString.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> OneString {
    return OneString.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> OneString {
    return OneString.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->OneString {
    return OneString.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> OneString {
    return OneString.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneString {
    return OneString.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> OneStringBuilder {
    return OneStringBuilder()
  }
  class func builderWithPrototype(prototype:OneString) -> OneStringBuilder {
    return OneString.builder().mergeFrom(prototype)
  }
  func builder() -> OneStringBuilder {
    return OneString.builder()
  }
  func toBuilder() -> OneStringBuilder {
    return OneString.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "OneString"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return OneString.self
  }


  //Meta information declaration end

}

final class OneStringBuilder : GeneratedMessageBuilder {
  private var builderResult:OneString

  required override init () {
     builderResult = OneString()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:String {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> OneStringBuilder{
       builderResult.hasData = false
       builderResult.data = ""
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> OneStringBuilder {
    builderResult = OneString()
    return self
  }
  override func clone() -> OneStringBuilder {
    return OneString.builderWithPrototype(builderResult)
  }
  override func build() -> OneString {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> OneString {
    var returnMe:OneString = builderResult
    return returnMe
  }
  func mergeFrom(other:OneString) -> OneStringBuilder {
    if (other == OneString()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->OneStringBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneStringBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        data = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MoreString : GeneratedMessage {
  private(set) var data:Array<String> = Array<String>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if !data.isEmpty {
      for value in data {
        output.writeString(1, value:value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    var dataSizeData:Int32 = 0
    for element in data {
        dataSizeData += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeData
    size += 1 * Int32(data.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MoreString {
    return MoreString.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MoreString {
    return MoreString.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MoreString {
    return MoreString.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MoreString {
    return MoreString.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MoreString {
    return MoreString.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MoreString {
    return MoreString.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MoreStringBuilder {
    return MoreStringBuilder()
  }
  class func builderWithPrototype(prototype:MoreString) -> MoreStringBuilder {
    return MoreString.builder().mergeFrom(prototype)
  }
  func builder() -> MoreStringBuilder {
    return MoreString.builder()
  }
  func toBuilder() -> MoreStringBuilder {
    return MoreString.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var dataElementIndex:Int = 0
    for element in data  {
        output += "\(indent) data[\(dataElementIndex)]: \(element)\n"
        dataElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in data {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoreString"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoreString.self
  }


  //Meta information declaration end

}

final class MoreStringBuilder : GeneratedMessageBuilder {
  private var builderResult:MoreString

  required override init () {
     builderResult = MoreString()
     super.init()
  }
  var data:Array<String> {
       get {
           return builderResult.data
       }
       set (array) {
           builderResult.data = array
       }
  }
  func clearData() -> MoreStringBuilder {
     builderResult.data.removeAll(keepCapacity: false)
     return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MoreStringBuilder {
    builderResult = MoreString()
    return self
  }
  override func clone() -> MoreStringBuilder {
    return MoreString.builderWithPrototype(builderResult)
  }
  override func build() -> MoreString {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MoreString {
    var returnMe:MoreString = builderResult
    return returnMe
  }
  func mergeFrom(other:MoreString) -> MoreStringBuilder {
    if (other == MoreString()) {
     return self
    }
    if !other.data.isEmpty {
        builderResult.data += other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MoreStringBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MoreStringBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        data += [input.readString()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class OneBytes : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:Array<Byte> = [Byte]()

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeData(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeDataSize(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> OneBytes {
    return OneBytes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> OneBytes {
    return OneBytes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> OneBytes {
    return OneBytes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->OneBytes {
    return OneBytes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> OneBytes {
    return OneBytes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneBytes {
    return OneBytes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> OneBytesBuilder {
    return OneBytesBuilder()
  }
  class func builderWithPrototype(prototype:OneBytes) -> OneBytesBuilder {
    return OneBytes.builder().mergeFrom(prototype)
  }
  func builder() -> OneBytesBuilder {
    return OneBytes.builder()
  }
  func toBuilder() -> OneBytesBuilder {
    return OneBytes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for value in data {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "OneBytes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return OneBytes.self
  }


  //Meta information declaration end

}

final class OneBytesBuilder : GeneratedMessageBuilder {
  private var builderResult:OneBytes

  required override init () {
     builderResult = OneBytes()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:Array<Byte> {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> OneBytesBuilder{
       builderResult.hasData = false
       builderResult.data = [Byte]()
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> OneBytesBuilder {
    builderResult = OneBytes()
    return self
  }
  override func clone() -> OneBytesBuilder {
    return OneBytes.builderWithPrototype(builderResult)
  }
  override func build() -> OneBytes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> OneBytes {
    var returnMe:OneBytes = builderResult
    return returnMe
  }
  func mergeFrom(other:OneBytes) -> OneBytesBuilder {
    if (other == OneBytes()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->OneBytesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneBytesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        data = input.readData()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class MoreBytes : GeneratedMessage {
  private(set) var data:Array<Array<Byte>> = Array<Array<Byte>>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if !data.isEmpty {
      for value in data {
        output.writeData(1, value:value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    var dataSizeData:Int32 = 0
    for element in data {
        dataSizeData += WireFormat.computeDataSizeNoTag(element)
    }
    size += dataSizeData
    size += 1 * Int32(data.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> MoreBytes {
    return MoreBytes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> MoreBytes {
    return MoreBytes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> MoreBytes {
    return MoreBytes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MoreBytes {
    return MoreBytes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> MoreBytes {
    return MoreBytes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MoreBytes {
    return MoreBytes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> MoreBytesBuilder {
    return MoreBytesBuilder()
  }
  class func builderWithPrototype(prototype:MoreBytes) -> MoreBytesBuilder {
    return MoreBytes.builder().mergeFrom(prototype)
  }
  func builder() -> MoreBytesBuilder {
    return MoreBytes.builder()
  }
  func toBuilder() -> MoreBytesBuilder {
    return MoreBytes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var dataElementIndex:Int = 0
    for element in data  {
        output += "\(indent) data[\(dataElementIndex)]: \(element)\n"
        dataElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for value in data {
            for element in value {
                hashCode = (hashCode &* 31) &+ element.hashValue
            }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MoreBytes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return MoreBytes.self
  }


  //Meta information declaration end

}

final class MoreBytesBuilder : GeneratedMessageBuilder {
  private var builderResult:MoreBytes

  required override init () {
     builderResult = MoreBytes()
     super.init()
  }
  var data:Array<Array<Byte>> {
       get {
           return builderResult.data
       }
       set (array) {
           builderResult.data = array
       }
  }
  func clearData() -> MoreBytesBuilder {
     builderResult.data.removeAll(keepCapacity: false)
     return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> MoreBytesBuilder {
    builderResult = MoreBytes()
    return self
  }
  override func clone() -> MoreBytesBuilder {
    return MoreBytes.builderWithPrototype(builderResult)
  }
  override func build() -> MoreBytes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> MoreBytes {
    var returnMe:MoreBytes = builderResult
    return returnMe
  }
  func mergeFrom(other:MoreBytes) -> MoreBytesBuilder {
    if (other == MoreBytes()) {
     return self
    }
    if !other.data.isEmpty {
        builderResult.data += other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->MoreBytesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MoreBytesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        data += [input.readData()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Int32Message : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:Int32 = Int32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeInt32(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeInt32Size(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Int32Message {
    return Int32Message.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Int32Message {
    return Int32Message.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Int32Message {
    return Int32Message.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Int32Message {
    return Int32Message.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Int32Message {
    return Int32Message.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Int32Message {
    return Int32Message.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> Int32MessageBuilder {
    return Int32MessageBuilder()
  }
  class func builderWithPrototype(prototype:Int32Message) -> Int32MessageBuilder {
    return Int32Message.builder().mergeFrom(prototype)
  }
  func builder() -> Int32MessageBuilder {
    return Int32Message.builder()
  }
  func toBuilder() -> Int32MessageBuilder {
    return Int32Message.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Int32Message"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Int32Message.self
  }


  //Meta information declaration end

}

final class Int32MessageBuilder : GeneratedMessageBuilder {
  private var builderResult:Int32Message

  required override init () {
     builderResult = Int32Message()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:Int32 {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> Int32MessageBuilder{
       builderResult.hasData = false
       builderResult.data = Int32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> Int32MessageBuilder {
    builderResult = Int32Message()
    return self
  }
  override func clone() -> Int32MessageBuilder {
    return Int32Message.builderWithPrototype(builderResult)
  }
  override func build() -> Int32Message {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Int32Message {
    var returnMe:Int32Message = builderResult
    return returnMe
  }
  func mergeFrom(other:Int32Message) -> Int32MessageBuilder {
    if (other == Int32Message()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->Int32MessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Int32MessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        data = input.readInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Uint32Message : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:UInt32 = UInt32(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeUInt32(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeUInt32Size(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Uint32Message {
    return Uint32Message.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Uint32Message {
    return Uint32Message.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Uint32Message {
    return Uint32Message.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Uint32Message {
    return Uint32Message.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Uint32Message {
    return Uint32Message.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Uint32Message {
    return Uint32Message.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> Uint32MessageBuilder {
    return Uint32MessageBuilder()
  }
  class func builderWithPrototype(prototype:Uint32Message) -> Uint32MessageBuilder {
    return Uint32Message.builder().mergeFrom(prototype)
  }
  func builder() -> Uint32MessageBuilder {
    return Uint32Message.builder()
  }
  func toBuilder() -> Uint32MessageBuilder {
    return Uint32Message.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Uint32Message"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Uint32Message.self
  }


  //Meta information declaration end

}

final class Uint32MessageBuilder : GeneratedMessageBuilder {
  private var builderResult:Uint32Message

  required override init () {
     builderResult = Uint32Message()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:UInt32 {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> Uint32MessageBuilder{
       builderResult.hasData = false
       builderResult.data = UInt32(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> Uint32MessageBuilder {
    builderResult = Uint32Message()
    return self
  }
  override func clone() -> Uint32MessageBuilder {
    return Uint32Message.builderWithPrototype(builderResult)
  }
  override func build() -> Uint32Message {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Uint32Message {
    var returnMe:Uint32Message = builderResult
    return returnMe
  }
  func mergeFrom(other:Uint32Message) -> Uint32MessageBuilder {
    if (other == Uint32Message()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->Uint32MessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Uint32MessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        data = input.readUInt32()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Int64Message : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:Int64 = Int64(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeInt64(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeInt64Size(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Int64Message {
    return Int64Message.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Int64Message {
    return Int64Message.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Int64Message {
    return Int64Message.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Int64Message {
    return Int64Message.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Int64Message {
    return Int64Message.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Int64Message {
    return Int64Message.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> Int64MessageBuilder {
    return Int64MessageBuilder()
  }
  class func builderWithPrototype(prototype:Int64Message) -> Int64MessageBuilder {
    return Int64Message.builder().mergeFrom(prototype)
  }
  func builder() -> Int64MessageBuilder {
    return Int64Message.builder()
  }
  func toBuilder() -> Int64MessageBuilder {
    return Int64Message.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Int64Message"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Int64Message.self
  }


  //Meta information declaration end

}

final class Int64MessageBuilder : GeneratedMessageBuilder {
  private var builderResult:Int64Message

  required override init () {
     builderResult = Int64Message()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:Int64 {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> Int64MessageBuilder{
       builderResult.hasData = false
       builderResult.data = Int64(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> Int64MessageBuilder {
    builderResult = Int64Message()
    return self
  }
  override func clone() -> Int64MessageBuilder {
    return Int64Message.builderWithPrototype(builderResult)
  }
  override func build() -> Int64Message {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Int64Message {
    var returnMe:Int64Message = builderResult
    return returnMe
  }
  func mergeFrom(other:Int64Message) -> Int64MessageBuilder {
    if (other == Int64Message()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->Int64MessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Int64MessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        data = input.readInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class Uint64Message : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:UInt64 = UInt64(0)

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeUInt64(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeUInt64Size(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> Uint64Message {
    return Uint64Message.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Uint64Message {
    return Uint64Message.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> Uint64Message {
    return Uint64Message.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Uint64Message {
    return Uint64Message.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> Uint64Message {
    return Uint64Message.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Uint64Message {
    return Uint64Message.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> Uint64MessageBuilder {
    return Uint64MessageBuilder()
  }
  class func builderWithPrototype(prototype:Uint64Message) -> Uint64MessageBuilder {
    return Uint64Message.builder().mergeFrom(prototype)
  }
  func builder() -> Uint64MessageBuilder {
    return Uint64Message.builder()
  }
  func toBuilder() -> Uint64MessageBuilder {
    return Uint64Message.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Uint64Message"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Uint64Message.self
  }


  //Meta information declaration end

}

final class Uint64MessageBuilder : GeneratedMessageBuilder {
  private var builderResult:Uint64Message

  required override init () {
     builderResult = Uint64Message()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:UInt64 {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> Uint64MessageBuilder{
       builderResult.hasData = false
       builderResult.data = UInt64(0)
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> Uint64MessageBuilder {
    builderResult = Uint64Message()
    return self
  }
  override func clone() -> Uint64MessageBuilder {
    return Uint64Message.builderWithPrototype(builderResult)
  }
  override func build() -> Uint64Message {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> Uint64Message {
    var returnMe:Uint64Message = builderResult
    return returnMe
  }
  func mergeFrom(other:Uint64Message) -> Uint64MessageBuilder {
    if (other == Uint64Message()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->Uint64MessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Uint64MessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        data = input.readUInt64()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class BoolMessage : GeneratedMessage {
  private(set) var hasData:Bool = false
  private(set) var data:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasData {
      output.writeBool(1, value:data)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasData {
      size += WireFormat.computeBoolSize(1, value:data)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> BoolMessage {
    return BoolMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> BoolMessage {
    return BoolMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> BoolMessage {
    return BoolMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->BoolMessage {
    return BoolMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> BoolMessage {
    return BoolMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BoolMessage {
    return BoolMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> BoolMessageBuilder {
    return BoolMessageBuilder()
  }
  class func builderWithPrototype(prototype:BoolMessage) -> BoolMessageBuilder {
    return BoolMessage.builder().mergeFrom(prototype)
  }
  func builder() -> BoolMessageBuilder {
    return BoolMessage.builder()
  }
  func toBuilder() -> BoolMessageBuilder {
    return BoolMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BoolMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BoolMessage.self
  }


  //Meta information declaration end

}

final class BoolMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:BoolMessage

  required override init () {
     builderResult = BoolMessage()
     super.init()
  }
  var hasData:Bool {
       get {
            return builderResult.hasData
       }
  }
  var data:Bool {
       get {
            return builderResult.data
       }
       set (value) {
           builderResult.hasData = true
           builderResult.data = value
       }
  }
  func clearData() -> BoolMessageBuilder{
       builderResult.hasData = false
       builderResult.data = false
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> BoolMessageBuilder {
    builderResult = BoolMessage()
    return self
  }
  override func clone() -> BoolMessageBuilder {
    return BoolMessage.builderWithPrototype(builderResult)
  }
  override func build() -> BoolMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> BoolMessage {
    var returnMe:BoolMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:BoolMessage) -> BoolMessageBuilder {
    if (other == BoolMessage()) {
     return self
    }
    if other.hasData {
         data = other.data
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->BoolMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BoolMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        data = input.readBool()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestOneof : GeneratedMessage {


  //Nested type declaration start

    final public class FooGroup : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      private(set) var hasB:Bool = false
      private(set) var b:String = ""

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(5, value:a)
        }
        if hasB {
          output.writeString(6, value:b)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(5, value:a)
        }
        if hasB {
          size += WireFormat.computeStringSize(6, value:b)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof.FooGroup {
        return TestOneof.FooGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestOneof.FooGroupBuilder {
        return TestOneof.FooGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestOneof.FooGroup) -> TestOneof.FooGroupBuilder {
        return TestOneof.FooGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestOneof.FooGroupBuilder {
        return TestOneof.FooGroup.builder()
      }
      func toBuilder() -> TestOneof.FooGroupBuilder {
        return TestOneof.FooGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        if hasB {
          output += "\(indent) b: \(b) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              if hasB {
                 hashCode = (hashCode &* 31) &+ b.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestOneof.FooGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestOneof.FooGroup.self
      }


      //Meta information declaration end

    }

    final class FooGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestOneof.FooGroup

      required override init () {
         builderResult = TestOneof.FooGroup()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestOneof.FooGroupBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      var hasB:Bool {
           get {
                return builderResult.hasB
           }
      }
      var b:String {
           get {
                return builderResult.b
           }
           set (value) {
               builderResult.hasB = true
               builderResult.b = value
           }
      }
      func clearB() -> TestOneof.FooGroupBuilder{
           builderResult.hasB = false
           builderResult.b = ""
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestOneof.FooGroupBuilder {
        builderResult = TestOneof.FooGroup()
        return self
      }
      override func clone() -> TestOneof.FooGroupBuilder {
        return TestOneof.FooGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestOneof.FooGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestOneof.FooGroup {
        var returnMe:TestOneof.FooGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestOneof.FooGroup) -> TestOneof.FooGroupBuilder {
        if (other == TestOneof.FooGroup()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        if other.hasB {
             b = other.b
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneof.FooGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof.FooGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 40 :
            a = input.readInt32()

          case 50 :
            b = input.readString()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //OneOf declaration start

  enum Foo {
    case FooOneOfNotSet

    func checkOneOfIsSet() -> Bool {
         switch self {
         case .FooOneOfNotSet:
              return false
         default:
              return true
         }
    }
    case FooInt(Int32)

    static func getFooInt(value:Foo) ->Int32? {
         switch value {
         case .FooInt(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooString(String)

    static func getFooString(value:Foo) ->String? {
         switch value {
         case .FooString(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooMessage(TestAllTypes)

    static func getFooMessage(value:Foo) ->TestAllTypes? {
         switch value {
         case .FooMessage(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooGroup(TestOneof.FooGroup)

    static func getFooGroup(value:Foo) ->TestOneof.FooGroup? {
         switch value {
         case .FooGroup(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
  }



  //OneOf declaration end

  private var storageFoo:TestOneof.Foo =  TestOneof.Foo.FooOneOfNotSet
  private(set) var hasFooInt:Bool {
        get {
             if TestOneof.Foo.getFooInt(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooInt:Int32!{
       get {
            return TestOneof.Foo.getFooInt(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof.Foo.FooInt(newvalue)
       }
  }
  private(set) var hasFooString:Bool {
        get {
             if TestOneof.Foo.getFooString(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooString:String!{
       get {
            return TestOneof.Foo.getFooString(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof.Foo.FooString(newvalue)
       }
  }
  private(set) var hasFooMessage:Bool {
        get {
             if TestOneof.Foo.getFooMessage(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooMessage:TestAllTypes!{
       get {
            return TestOneof.Foo.getFooMessage(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof.Foo.FooMessage(newvalue)
       }
  }
  private(set) var hasFooGroup:Bool {
        get {
             if TestOneof.Foo.getFooGroup(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooGroup:TestOneof.FooGroup!{
       get {
            return TestOneof.Foo.getFooGroup(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof.Foo.FooGroup(newvalue)
       }
  }
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasFooInt {
      output.writeInt32(1, value:fooInt)
    }
    if hasFooString {
      output.writeString(2, value:fooString)
    }
    if hasFooMessage {
      output.writeMessage(3, value:fooMessage)
    }
    if hasFooGroup {
      output.writeGroup(4, value:fooGroup)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasFooInt {
      size += WireFormat.computeInt32Size(1, value:fooInt)
    }
    if hasFooString {
      size += WireFormat.computeStringSize(2, value:fooString)
    }
    if hasFooMessage {
      size += WireFormat.computeMessageSize(3, value:fooMessage)
    }
    if hasFooGroup {
      size += WireFormat.computeGroupSize(4, value:fooGroup)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestOneof {
    return TestOneof.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneof {
    return TestOneof.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestOneof {
    return TestOneof.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneof {
    return TestOneof.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneof {
    return TestOneof.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof {
    return TestOneof.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestOneofBuilder {
    return TestOneofBuilder()
  }
  class func builderWithPrototype(prototype:TestOneof) -> TestOneofBuilder {
    return TestOneof.builder().mergeFrom(prototype)
  }
  func builder() -> TestOneofBuilder {
    return TestOneof.builder()
  }
  func toBuilder() -> TestOneofBuilder {
    return TestOneof.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasFooInt {
      output += "\(indent) fooInt: \(fooInt) \n"
    }
    if hasFooString {
      output += "\(indent) fooString: \(fooString) \n"
    }
    if hasFooMessage {
      output += "\(indent) fooMessage {\n"
      fooMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasFooGroup {
      output += "\(indent) fooGroup {\n"
      fooGroup.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFooInt {
             hashCode = (hashCode &* 31) &+ fooInt.hashValue
          }
          if hasFooString {
             hashCode = (hashCode &* 31) &+ fooString.hashValue
          }
          if hasFooMessage {
            hashCode = (hashCode &* 31) &+ fooMessage.hashValue
          }
          if hasFooGroup {
            hashCode = (hashCode &* 31) &+ fooGroup.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestOneof"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestOneof.self
  }


  //Meta information declaration end

}

final class TestOneofBuilder : GeneratedMessageBuilder {
  private var builderResult:TestOneof

  required override init () {
     builderResult = TestOneof()
     super.init()
  }
  var hasFooInt:Bool {
       get {
            return builderResult.hasFooInt
       }
  }
  var fooInt:Int32 {
       get {
            return builderResult.fooInt
       }
       set (value) {
           builderResult.hasFooInt = true
           builderResult.fooInt = value
       }
  }
  func clearFooInt() -> TestOneofBuilder{
       builderResult.hasFooInt = false
       builderResult.fooInt = Int32(0)
       return self
  }
  var hasFooString:Bool {
       get {
            return builderResult.hasFooString
       }
  }
  var fooString:String {
       get {
            return builderResult.fooString
       }
       set (value) {
           builderResult.hasFooString = true
           builderResult.fooString = value
       }
  }
  func clearFooString() -> TestOneofBuilder{
       builderResult.hasFooString = false
       builderResult.fooString = ""
       return self
  }
  var hasFooMessage:Bool {
       get {
           return builderResult.hasFooMessage
       }
  }
  var fooMessage:TestAllTypes {
       get {
           return builderResult.fooMessage
       }
       set (value) {
           builderResult.hasFooMessage = true
           builderResult.fooMessage = value
       }
  }
  func setFooMessageBuilder(builderForValue:TestAllTypesBuilder) -> TestOneofBuilder {
    fooMessage = builderForValue.build()
    return self
  }
  func mergeFooMessage(value:TestAllTypes) -> TestOneofBuilder {
    if (builderResult.hasFooMessage && builderResult.fooMessage != TestAllTypes()) {
      builderResult.fooMessage = TestAllTypes.builderWithPrototype(builderResult.fooMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooMessage = value
    }
    builderResult.hasFooMessage = true
    return self
  }
  func clearFooMessage() -> TestOneofBuilder {
    builderResult.hasFooMessage = false
    builderResult.fooMessage = TestAllTypes()
    return self
  }
  var hasFooGroup:Bool {
       get {
           return builderResult.hasFooGroup
       }
  }
  var fooGroup:TestOneof.FooGroup {
       get {
           return builderResult.fooGroup
       }
       set (value) {
           builderResult.hasFooGroup = true
           builderResult.fooGroup = value
       }
  }
  func setFooGroupBuilder(builderForValue:TestOneof.FooGroupBuilder) -> TestOneofBuilder {
    fooGroup = builderForValue.build()
    return self
  }
  func mergeFooGroup(value:TestOneof.FooGroup) -> TestOneofBuilder {
    if (builderResult.hasFooGroup && builderResult.fooGroup != TestOneof.FooGroup()) {
      builderResult.fooGroup = TestOneof.FooGroup.builderWithPrototype(builderResult.fooGroup).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooGroup = value
    }
    builderResult.hasFooGroup = true
    return self
  }
  func clearFooGroup() -> TestOneofBuilder {
    builderResult.hasFooGroup = false
    builderResult.fooGroup = TestOneof.FooGroup()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestOneofBuilder {
    builderResult = TestOneof()
    return self
  }
  override func clone() -> TestOneofBuilder {
    return TestOneof.builderWithPrototype(builderResult)
  }
  override func build() -> TestOneof {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestOneof {
    var returnMe:TestOneof = builderResult
    return returnMe
  }
  func mergeFrom(other:TestOneof) -> TestOneofBuilder {
    if (other == TestOneof()) {
     return self
    }
    if other.hasFooInt {
         fooInt = other.fooInt
    }
    if other.hasFooString {
         fooString = other.fooString
    }
    if (other.hasFooMessage) {
        mergeFooMessage(other.fooMessage)
    }
    if (other.hasFooGroup) {
        mergeFooGroup(other.fooGroup)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneofBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneofBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        fooInt = input.readInt32()

      case 18 :
        fooString = input.readString()

      case 26 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasFooMessage {
          subBuilder.mergeFrom(fooMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        fooMessage = subBuilder.buildPartial()

      case 35 :
        var subBuilder:TestOneof.FooGroupBuilder = TestOneof.FooGroup.builder()
        if hasFooGroup {
          subBuilder.mergeFrom(fooGroup)
        }
        input.readGroup(4, builder:subBuilder, extensionRegistry:extensionRegistry)
        fooGroup = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestOneofBackwardsCompatible : GeneratedMessage {


  //Nested type declaration start

    final public class FooGroup : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      private(set) var hasB:Bool = false
      private(set) var b:String = ""

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(5, value:a)
        }
        if hasB {
          output.writeString(6, value:b)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(5, value:a)
        }
        if hasB {
          size += WireFormat.computeStringSize(6, value:b)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible.FooGroup {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestOneofBackwardsCompatible.FooGroupBuilder {
        return TestOneofBackwardsCompatible.FooGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestOneofBackwardsCompatible.FooGroup) -> TestOneofBackwardsCompatible.FooGroupBuilder {
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestOneofBackwardsCompatible.FooGroupBuilder {
        return TestOneofBackwardsCompatible.FooGroup.builder()
      }
      func toBuilder() -> TestOneofBackwardsCompatible.FooGroupBuilder {
        return TestOneofBackwardsCompatible.FooGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        if hasB {
          output += "\(indent) b: \(b) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              if hasB {
                 hashCode = (hashCode &* 31) &+ b.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestOneofBackwardsCompatible.FooGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestOneofBackwardsCompatible.FooGroup.self
      }


      //Meta information declaration end

    }

    final class FooGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestOneofBackwardsCompatible.FooGroup

      required override init () {
         builderResult = TestOneofBackwardsCompatible.FooGroup()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestOneofBackwardsCompatible.FooGroupBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      var hasB:Bool {
           get {
                return builderResult.hasB
           }
      }
      var b:String {
           get {
                return builderResult.b
           }
           set (value) {
               builderResult.hasB = true
               builderResult.b = value
           }
      }
      func clearB() -> TestOneofBackwardsCompatible.FooGroupBuilder{
           builderResult.hasB = false
           builderResult.b = ""
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestOneofBackwardsCompatible.FooGroupBuilder {
        builderResult = TestOneofBackwardsCompatible.FooGroup()
        return self
      }
      override func clone() -> TestOneofBackwardsCompatible.FooGroupBuilder {
        return TestOneofBackwardsCompatible.FooGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestOneofBackwardsCompatible.FooGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestOneofBackwardsCompatible.FooGroup {
        var returnMe:TestOneofBackwardsCompatible.FooGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestOneofBackwardsCompatible.FooGroup) -> TestOneofBackwardsCompatible.FooGroupBuilder {
        if (other == TestOneofBackwardsCompatible.FooGroup()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        if other.hasB {
             b = other.b
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneofBackwardsCompatible.FooGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible.FooGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 40 :
            a = input.readInt32()

          case 50 :
            b = input.readString()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasFooInt:Bool = false
  private(set) var fooInt:Int32 = Int32(0)

  private(set) var hasFooString:Bool = false
  private(set) var fooString:String = ""

  private(set) var hasFooMessage:Bool = false
  private(set) var fooMessage:TestAllTypes = TestAllTypes()
  private(set) var hasFooGroup:Bool = false
  private(set) var fooGroup:TestOneofBackwardsCompatible.FooGroup = TestOneofBackwardsCompatible.FooGroup()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasFooInt {
      output.writeInt32(1, value:fooInt)
    }
    if hasFooString {
      output.writeString(2, value:fooString)
    }
    if hasFooMessage {
      output.writeMessage(3, value:fooMessage)
    }
    if hasFooGroup {
      output.writeGroup(4, value:fooGroup)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasFooInt {
      size += WireFormat.computeInt32Size(1, value:fooInt)
    }
    if hasFooString {
      size += WireFormat.computeStringSize(2, value:fooString)
    }
    if hasFooMessage {
      size += WireFormat.computeMessageSize(3, value:fooMessage)
    }
    if hasFooGroup {
      size += WireFormat.computeGroupSize(4, value:fooGroup)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestOneofBackwardsCompatibleBuilder {
    return TestOneofBackwardsCompatibleBuilder()
  }
  class func builderWithPrototype(prototype:TestOneofBackwardsCompatible) -> TestOneofBackwardsCompatibleBuilder {
    return TestOneofBackwardsCompatible.builder().mergeFrom(prototype)
  }
  func builder() -> TestOneofBackwardsCompatibleBuilder {
    return TestOneofBackwardsCompatible.builder()
  }
  func toBuilder() -> TestOneofBackwardsCompatibleBuilder {
    return TestOneofBackwardsCompatible.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasFooInt {
      output += "\(indent) fooInt: \(fooInt) \n"
    }
    if hasFooString {
      output += "\(indent) fooString: \(fooString) \n"
    }
    if hasFooMessage {
      output += "\(indent) fooMessage {\n"
      fooMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasFooGroup {
      output += "\(indent) fooGroup {\n"
      fooGroup.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFooInt {
             hashCode = (hashCode &* 31) &+ fooInt.hashValue
          }
          if hasFooString {
             hashCode = (hashCode &* 31) &+ fooString.hashValue
          }
          if hasFooMessage {
            hashCode = (hashCode &* 31) &+ fooMessage.hashValue
          }
          if hasFooGroup {
            hashCode = (hashCode &* 31) &+ fooGroup.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestOneofBackwardsCompatible"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestOneofBackwardsCompatible.self
  }


  //Meta information declaration end

}

final class TestOneofBackwardsCompatibleBuilder : GeneratedMessageBuilder {
  private var builderResult:TestOneofBackwardsCompatible

  required override init () {
     builderResult = TestOneofBackwardsCompatible()
     super.init()
  }
  var hasFooInt:Bool {
       get {
            return builderResult.hasFooInt
       }
  }
  var fooInt:Int32 {
       get {
            return builderResult.fooInt
       }
       set (value) {
           builderResult.hasFooInt = true
           builderResult.fooInt = value
       }
  }
  func clearFooInt() -> TestOneofBackwardsCompatibleBuilder{
       builderResult.hasFooInt = false
       builderResult.fooInt = Int32(0)
       return self
  }
  var hasFooString:Bool {
       get {
            return builderResult.hasFooString
       }
  }
  var fooString:String {
       get {
            return builderResult.fooString
       }
       set (value) {
           builderResult.hasFooString = true
           builderResult.fooString = value
       }
  }
  func clearFooString() -> TestOneofBackwardsCompatibleBuilder{
       builderResult.hasFooString = false
       builderResult.fooString = ""
       return self
  }
  var hasFooMessage:Bool {
       get {
           return builderResult.hasFooMessage
       }
  }
  var fooMessage:TestAllTypes {
       get {
           return builderResult.fooMessage
       }
       set (value) {
           builderResult.hasFooMessage = true
           builderResult.fooMessage = value
       }
  }
  func setFooMessageBuilder(builderForValue:TestAllTypesBuilder) -> TestOneofBackwardsCompatibleBuilder {
    fooMessage = builderForValue.build()
    return self
  }
  func mergeFooMessage(value:TestAllTypes) -> TestOneofBackwardsCompatibleBuilder {
    if (builderResult.hasFooMessage && builderResult.fooMessage != TestAllTypes()) {
      builderResult.fooMessage = TestAllTypes.builderWithPrototype(builderResult.fooMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooMessage = value
    }
    builderResult.hasFooMessage = true
    return self
  }
  func clearFooMessage() -> TestOneofBackwardsCompatibleBuilder {
    builderResult.hasFooMessage = false
    builderResult.fooMessage = TestAllTypes()
    return self
  }
  var hasFooGroup:Bool {
       get {
           return builderResult.hasFooGroup
       }
  }
  var fooGroup:TestOneofBackwardsCompatible.FooGroup {
       get {
           return builderResult.fooGroup
       }
       set (value) {
           builderResult.hasFooGroup = true
           builderResult.fooGroup = value
       }
  }
  func setFooGroupBuilder(builderForValue:TestOneofBackwardsCompatible.FooGroupBuilder) -> TestOneofBackwardsCompatibleBuilder {
    fooGroup = builderForValue.build()
    return self
  }
  func mergeFooGroup(value:TestOneofBackwardsCompatible.FooGroup) -> TestOneofBackwardsCompatibleBuilder {
    if (builderResult.hasFooGroup && builderResult.fooGroup != TestOneofBackwardsCompatible.FooGroup()) {
      builderResult.fooGroup = TestOneofBackwardsCompatible.FooGroup.builderWithPrototype(builderResult.fooGroup).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooGroup = value
    }
    builderResult.hasFooGroup = true
    return self
  }
  func clearFooGroup() -> TestOneofBackwardsCompatibleBuilder {
    builderResult.hasFooGroup = false
    builderResult.fooGroup = TestOneofBackwardsCompatible.FooGroup()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestOneofBackwardsCompatibleBuilder {
    builderResult = TestOneofBackwardsCompatible()
    return self
  }
  override func clone() -> TestOneofBackwardsCompatibleBuilder {
    return TestOneofBackwardsCompatible.builderWithPrototype(builderResult)
  }
  override func build() -> TestOneofBackwardsCompatible {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestOneofBackwardsCompatible {
    var returnMe:TestOneofBackwardsCompatible = builderResult
    return returnMe
  }
  func mergeFrom(other:TestOneofBackwardsCompatible) -> TestOneofBackwardsCompatibleBuilder {
    if (other == TestOneofBackwardsCompatible()) {
     return self
    }
    if other.hasFooInt {
         fooInt = other.fooInt
    }
    if other.hasFooString {
         fooString = other.fooString
    }
    if (other.hasFooMessage) {
        mergeFooMessage(other.fooMessage)
    }
    if (other.hasFooGroup) {
        mergeFooGroup(other.fooGroup)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneofBackwardsCompatibleBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatibleBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        fooInt = input.readInt32()

      case 18 :
        fooString = input.readString()

      case 26 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasFooMessage {
          subBuilder.mergeFrom(fooMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        fooMessage = subBuilder.buildPartial()

      case 35 :
        var subBuilder:TestOneofBackwardsCompatible.FooGroupBuilder = TestOneofBackwardsCompatible.FooGroup.builder()
        if hasFooGroup {
          subBuilder.mergeFrom(fooGroup)
        }
        input.readGroup(4, builder:subBuilder, extensionRegistry:extensionRegistry)
        fooGroup = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestOneof2 : GeneratedMessage {


  //Nested type declaration start

    final public class FooGroup : GeneratedMessage {
      private(set) var hasA:Bool = false
      private(set) var a:Int32 = Int32(0)

      private(set) var hasB:Bool = false
      private(set) var b:String = ""

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasA {
          output.writeInt32(9, value:a)
        }
        if hasB {
          output.writeString(10, value:b)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasA {
          size += WireFormat.computeInt32Size(9, value:a)
        }
        if hasB {
          size += WireFormat.computeStringSize(10, value:b)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2.FooGroup {
        return TestOneof2.FooGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestOneof2.FooGroupBuilder {
        return TestOneof2.FooGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestOneof2.FooGroup) -> TestOneof2.FooGroupBuilder {
        return TestOneof2.FooGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestOneof2.FooGroupBuilder {
        return TestOneof2.FooGroup.builder()
      }
      func toBuilder() -> TestOneof2.FooGroupBuilder {
        return TestOneof2.FooGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasA {
          output += "\(indent) a: \(a) \n"
        }
        if hasB {
          output += "\(indent) b: \(b) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasA {
                 hashCode = (hashCode &* 31) &+ a.hashValue
              }
              if hasB {
                 hashCode = (hashCode &* 31) &+ b.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestOneof2.FooGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestOneof2.FooGroup.self
      }


      //Meta information declaration end

    }

    final class FooGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestOneof2.FooGroup

      required override init () {
         builderResult = TestOneof2.FooGroup()
         super.init()
      }
      var hasA:Bool {
           get {
                return builderResult.hasA
           }
      }
      var a:Int32 {
           get {
                return builderResult.a
           }
           set (value) {
               builderResult.hasA = true
               builderResult.a = value
           }
      }
      func clearA() -> TestOneof2.FooGroupBuilder{
           builderResult.hasA = false
           builderResult.a = Int32(0)
           return self
      }
      var hasB:Bool {
           get {
                return builderResult.hasB
           }
      }
      var b:String {
           get {
                return builderResult.b
           }
           set (value) {
               builderResult.hasB = true
               builderResult.b = value
           }
      }
      func clearB() -> TestOneof2.FooGroupBuilder{
           builderResult.hasB = false
           builderResult.b = ""
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestOneof2.FooGroupBuilder {
        builderResult = TestOneof2.FooGroup()
        return self
      }
      override func clone() -> TestOneof2.FooGroupBuilder {
        return TestOneof2.FooGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestOneof2.FooGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestOneof2.FooGroup {
        var returnMe:TestOneof2.FooGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestOneof2.FooGroup) -> TestOneof2.FooGroupBuilder {
        if (other == TestOneof2.FooGroup()) {
         return self
        }
        if other.hasA {
             a = other.a
        }
        if other.hasB {
             b = other.b
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneof2.FooGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2.FooGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 72 :
            a = input.readInt32()

          case 82 :
            b = input.readString()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class NestedMessage : GeneratedMessage {
      private(set) var hasQuxInt:Bool = false
      private(set) var quxInt:Int64 = Int64(0)

      private(set) var corgeInt:Array<Int32> = Array<Int32>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasQuxInt {
          output.writeInt64(1, value:quxInt)
        }
        if !corgeInt.isEmpty {
          for value in corgeInt {
            output.writeInt32(2, value:value)
          }
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasQuxInt {
          size += WireFormat.computeInt64Size(1, value:quxInt)
        }
        var dataSizeCorgeInt:Int32 = 0
        for element in corgeInt {
            dataSizeCorgeInt += WireFormat.computeInt32SizeNoTag(element)
        }
        size += dataSizeCorgeInt
        size += 1 * Int32(corgeInt.count)
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2.NestedMessage {
        return TestOneof2.NestedMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestOneof2.NestedMessageBuilder {
        return TestOneof2.NestedMessageBuilder()
      }
      class func builderWithPrototype(prototype:TestOneof2.NestedMessage) -> TestOneof2.NestedMessageBuilder {
        return TestOneof2.NestedMessage.builder().mergeFrom(prototype)
      }
      func builder() -> TestOneof2.NestedMessageBuilder {
        return TestOneof2.NestedMessage.builder()
      }
      func toBuilder() -> TestOneof2.NestedMessageBuilder {
        return TestOneof2.NestedMessage.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasQuxInt {
          output += "\(indent) quxInt: \(quxInt) \n"
        }
        var corgeIntElementIndex:Int = 0
        for element in corgeInt  {
            output += "\(indent) corgeInt[\(corgeIntElementIndex)]: \(element)\n"
            corgeIntElementIndex++
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasQuxInt {
                 hashCode = (hashCode &* 31) &+ quxInt.hashValue
              }
              for element in corgeInt {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestOneof2.NestedMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestOneof2.NestedMessage.self
      }


      //Meta information declaration end

    }

    final class NestedMessageBuilder : GeneratedMessageBuilder {
      private var builderResult:TestOneof2.NestedMessage

      required override init () {
         builderResult = TestOneof2.NestedMessage()
         super.init()
      }
      var hasQuxInt:Bool {
           get {
                return builderResult.hasQuxInt
           }
      }
      var quxInt:Int64 {
           get {
                return builderResult.quxInt
           }
           set (value) {
               builderResult.hasQuxInt = true
               builderResult.quxInt = value
           }
      }
      func clearQuxInt() -> TestOneof2.NestedMessageBuilder{
           builderResult.hasQuxInt = false
           builderResult.quxInt = Int64(0)
           return self
      }
      var corgeInt:Array<Int32> {
           get {
               return builderResult.corgeInt
           }
           set (array) {
               builderResult.corgeInt = array
           }
      }
      func clearCorgeInt() -> TestOneof2.NestedMessageBuilder {
         builderResult.corgeInt.removeAll(keepCapacity: false)
         return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestOneof2.NestedMessageBuilder {
        builderResult = TestOneof2.NestedMessage()
        return self
      }
      override func clone() -> TestOneof2.NestedMessageBuilder {
        return TestOneof2.NestedMessage.builderWithPrototype(builderResult)
      }
      override func build() -> TestOneof2.NestedMessage {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestOneof2.NestedMessage {
        var returnMe:TestOneof2.NestedMessage = builderResult
        return returnMe
      }
      func mergeFrom(other:TestOneof2.NestedMessage) -> TestOneof2.NestedMessageBuilder {
        if (other == TestOneof2.NestedMessage()) {
         return self
        }
        if other.hasQuxInt {
             quxInt = other.quxInt
        }
        if !other.corgeInt.isEmpty {
            builderResult.corgeInt += other.corgeInt
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneof2.NestedMessageBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2.NestedMessageBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            quxInt = input.readInt64()

          case 16 :
            corgeInt += [input.readInt32()]

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //OneOf declaration start

  enum Foo {
    case FooOneOfNotSet

    func checkOneOfIsSet() -> Bool {
         switch self {
         case .FooOneOfNotSet:
              return false
         default:
              return true
         }
    }
    case FooInt(Int32)

    static func getFooInt(value:Foo) ->Int32? {
         switch value {
         case .FooInt(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooString(String)

    static func getFooString(value:Foo) ->String? {
         switch value {
         case .FooString(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooCord(String)

    static func getFooCord(value:Foo) ->String? {
         switch value {
         case .FooCord(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooStringPiece(String)

    static func getFooStringPiece(value:Foo) ->String? {
         switch value {
         case .FooStringPiece(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooBytes([Byte])

    static func getFooBytes(value:Foo) ->[Byte]? {
         switch value {
         case .FooBytes(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooEnum(TestOneof2.NestedEnum)

    static func getFooEnum(value:Foo) ->TestOneof2.NestedEnum? {
         switch value {
         case .FooEnum(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooMessage(TestOneof2.NestedMessage)

    static func getFooMessage(value:Foo) ->TestOneof2.NestedMessage? {
         switch value {
         case .FooMessage(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooGroup(TestOneof2.FooGroup)

    static func getFooGroup(value:Foo) ->TestOneof2.FooGroup? {
         switch value {
         case .FooGroup(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooLazyMessage(TestOneof2.NestedMessage)

    static func getFooLazyMessage(value:Foo) ->TestOneof2.NestedMessage? {
         switch value {
         case .FooLazyMessage(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
  }



  //OneOf declaration end

  private var storageFoo:TestOneof2.Foo =  TestOneof2.Foo.FooOneOfNotSet


  //OneOf declaration start

  enum Bar {
    case BarOneOfNotSet

    func checkOneOfIsSet() -> Bool {
         switch self {
         case .BarOneOfNotSet:
              return false
         default:
              return true
         }
    }
    case BarInt(Int32)

    static func getBarInt(value:Bar) ->Int32? {
         switch value {
         case .BarInt(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case BarString(String)

    static func getBarString(value:Bar) ->String? {
         switch value {
         case .BarString(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case BarCord(String)

    static func getBarCord(value:Bar) ->String? {
         switch value {
         case .BarCord(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case BarStringPiece(String)

    static func getBarStringPiece(value:Bar) ->String? {
         switch value {
         case .BarStringPiece(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case BarBytes([Byte])

    static func getBarBytes(value:Bar) ->[Byte]? {
         switch value {
         case .BarBytes(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case BarEnum(TestOneof2.NestedEnum)

    static func getBarEnum(value:Bar) ->TestOneof2.NestedEnum? {
         switch value {
         case .BarEnum(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
  }



  //OneOf declaration end

  private var storageBar:TestOneof2.Bar =  TestOneof2.Bar.BarOneOfNotSet


    //Enum type declaration start 

    enum NestedEnum:Int32 {
      case Foo = 1
      case Bar = 2
      case Baz = 3

      static func IsValidValue(value:NestedEnum) ->Bool {
        switch value {
          case .Foo, .Bar, .Baz:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var hasFooInt:Bool {
        get {
             if TestOneof2.Foo.getFooInt(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooInt:Int32!{
       get {
            return TestOneof2.Foo.getFooInt(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooInt(newvalue)
       }
  }
  private(set) var hasFooString:Bool {
        get {
             if TestOneof2.Foo.getFooString(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooString:String!{
       get {
            return TestOneof2.Foo.getFooString(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooString(newvalue)
       }
  }
  private(set) var hasFooCord:Bool {
        get {
             if TestOneof2.Foo.getFooCord(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooCord:String!{
       get {
            return TestOneof2.Foo.getFooCord(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooCord(newvalue)
       }
  }
  private(set) var hasFooStringPiece:Bool {
        get {
             if TestOneof2.Foo.getFooStringPiece(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooStringPiece:String!{
       get {
            return TestOneof2.Foo.getFooStringPiece(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooStringPiece(newvalue)
       }
  }
  private(set) var hasFooBytes:Bool {
        get {
             if TestOneof2.Foo.getFooBytes(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooBytes:Array<Byte>!{
       get {
            return TestOneof2.Foo.getFooBytes(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooBytes(newvalue)
       }
  }
  private(set) var hasFooEnum:Bool {
        get {
             if TestOneof2.Foo.getFooEnum(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooEnum:TestOneof2.NestedEnum!{
       get {
            return TestOneof2.Foo.getFooEnum(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooEnum(newvalue)
       }
  }
  private(set) var hasFooMessage:Bool {
        get {
             if TestOneof2.Foo.getFooMessage(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooMessage:TestOneof2.NestedMessage!{
       get {
            return TestOneof2.Foo.getFooMessage(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooMessage(newvalue)
       }
  }
  private(set) var hasFooGroup:Bool {
        get {
             if TestOneof2.Foo.getFooGroup(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooGroup:TestOneof2.FooGroup!{
       get {
            return TestOneof2.Foo.getFooGroup(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooGroup(newvalue)
       }
  }
  private(set) var hasFooLazyMessage:Bool {
        get {
             if TestOneof2.Foo.getFooLazyMessage(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooLazyMessage:TestOneof2.NestedMessage!{
       get {
            return TestOneof2.Foo.getFooLazyMessage(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestOneof2.Foo.FooLazyMessage(newvalue)
       }
  }
  private(set) var hasBarInt:Bool {
        get {
             if TestOneof2.Bar.getBarInt(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barInt:Int32!{
       get {
            return TestOneof2.Bar.getBarInt(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarInt(newvalue)
       }
  }
  private(set) var hasBarString:Bool {
        get {
             if TestOneof2.Bar.getBarString(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barString:String!{
       get {
            return TestOneof2.Bar.getBarString(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarString(newvalue)
       }
  }
  private(set) var hasBarCord:Bool {
        get {
             if TestOneof2.Bar.getBarCord(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barCord:String!{
       get {
            return TestOneof2.Bar.getBarCord(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarCord(newvalue)
       }
  }
  private(set) var hasBarStringPiece:Bool {
        get {
             if TestOneof2.Bar.getBarStringPiece(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barStringPiece:String!{
       get {
            return TestOneof2.Bar.getBarStringPiece(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarStringPiece(newvalue)
       }
  }
  private(set) var hasBarBytes:Bool {
        get {
             if TestOneof2.Bar.getBarBytes(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barBytes:Array<Byte>!{
       get {
            return TestOneof2.Bar.getBarBytes(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarBytes(newvalue)
       }
  }
  private(set) var hasBarEnum:Bool {
        get {
             if TestOneof2.Bar.getBarEnum(storageBar) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var barEnum:TestOneof2.NestedEnum!{
       get {
            return TestOneof2.Bar.getBarEnum(storageBar)
       }
       set (newvalue) {
            storageBar = TestOneof2.Bar.BarEnum(newvalue)
       }
  }
  private(set) var hasBazInt:Bool = false
  private(set) var bazInt:Int32 = Int32(0)

  private(set) var hasBazString:Bool = false
  private(set) var bazString:String = "BAZ"

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasFooInt {
      output.writeInt32(1, value:fooInt)
    }
    if hasFooString {
      output.writeString(2, value:fooString)
    }
    if hasFooCord {
      output.writeString(3, value:fooCord)
    }
    if hasFooStringPiece {
      output.writeString(4, value:fooStringPiece)
    }
    if hasFooBytes {
      output.writeData(5, value:fooBytes)
    }
    if hasFooEnum {
      output.writeEnum(6, value:fooEnum.rawValue)
    }
    if hasFooMessage {
      output.writeMessage(7, value:fooMessage)
    }
    if hasFooGroup {
      output.writeGroup(8, value:fooGroup)
    }
    if hasFooLazyMessage {
      output.writeMessage(11, value:fooLazyMessage)
    }
    if hasBarInt {
      output.writeInt32(12, value:barInt)
    }
    if hasBarString {
      output.writeString(13, value:barString)
    }
    if hasBarCord {
      output.writeString(14, value:barCord)
    }
    if hasBarStringPiece {
      output.writeString(15, value:barStringPiece)
    }
    if hasBarBytes {
      output.writeData(16, value:barBytes)
    }
    if hasBarEnum {
      output.writeEnum(17, value:barEnum.rawValue)
    }
    if hasBazInt {
      output.writeInt32(18, value:bazInt)
    }
    if hasBazString {
      output.writeString(19, value:bazString)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasFooInt {
      size += WireFormat.computeInt32Size(1, value:fooInt)
    }
    if hasFooString {
      size += WireFormat.computeStringSize(2, value:fooString)
    }
    if hasFooCord {
      size += WireFormat.computeStringSize(3, value:fooCord)
    }
    if hasFooStringPiece {
      size += WireFormat.computeStringSize(4, value:fooStringPiece)
    }
    if hasFooBytes {
      size += WireFormat.computeDataSize(5, value:fooBytes)
    }
    if (hasFooEnum) {
      size += WireFormat.computeEnumSize(6, value:fooEnum.rawValue)
    }
    if hasFooMessage {
      size += WireFormat.computeMessageSize(7, value:fooMessage)
    }
    if hasFooGroup {
      size += WireFormat.computeGroupSize(8, value:fooGroup)
    }
    if hasFooLazyMessage {
      size += WireFormat.computeMessageSize(11, value:fooLazyMessage)
    }
    if hasBarInt {
      size += WireFormat.computeInt32Size(12, value:barInt)
    }
    if hasBarString {
      size += WireFormat.computeStringSize(13, value:barString)
    }
    if hasBarCord {
      size += WireFormat.computeStringSize(14, value:barCord)
    }
    if hasBarStringPiece {
      size += WireFormat.computeStringSize(15, value:barStringPiece)
    }
    if hasBarBytes {
      size += WireFormat.computeDataSize(16, value:barBytes)
    }
    if (hasBarEnum) {
      size += WireFormat.computeEnumSize(17, value:barEnum.rawValue)
    }
    if hasBazInt {
      size += WireFormat.computeInt32Size(18, value:bazInt)
    }
    if hasBazString {
      size += WireFormat.computeStringSize(19, value:bazString)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestOneof2 {
    return TestOneof2.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOneof2 {
    return TestOneof2.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestOneof2 {
    return TestOneof2.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOneof2 {
    return TestOneof2.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestOneof2 {
    return TestOneof2.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2 {
    return TestOneof2.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestOneof2Builder {
    return TestOneof2Builder()
  }
  class func builderWithPrototype(prototype:TestOneof2) -> TestOneof2Builder {
    return TestOneof2.builder().mergeFrom(prototype)
  }
  func builder() -> TestOneof2Builder {
    return TestOneof2.builder()
  }
  func toBuilder() -> TestOneof2Builder {
    return TestOneof2.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasFooInt {
      output += "\(indent) fooInt: \(fooInt) \n"
    }
    if hasFooString {
      output += "\(indent) fooString: \(fooString) \n"
    }
    if hasFooCord {
      output += "\(indent) fooCord: \(fooCord) \n"
    }
    if hasFooStringPiece {
      output += "\(indent) fooStringPiece: \(fooStringPiece) \n"
    }
    if hasFooBytes {
      output += "\(indent) fooBytes: \(fooBytes) \n"
    }
    if (hasFooEnum) {
      output += "\(indent) fooEnum: \(fooEnum.rawValue)\n"
    }
    if hasFooMessage {
      output += "\(indent) fooMessage {\n"
      fooMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasFooGroup {
      output += "\(indent) fooGroup {\n"
      fooGroup.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasFooLazyMessage {
      output += "\(indent) fooLazyMessage {\n"
      fooLazyMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasBarInt {
      output += "\(indent) barInt: \(barInt) \n"
    }
    if hasBarString {
      output += "\(indent) barString: \(barString) \n"
    }
    if hasBarCord {
      output += "\(indent) barCord: \(barCord) \n"
    }
    if hasBarStringPiece {
      output += "\(indent) barStringPiece: \(barStringPiece) \n"
    }
    if hasBarBytes {
      output += "\(indent) barBytes: \(barBytes) \n"
    }
    if (hasBarEnum) {
      output += "\(indent) barEnum: \(barEnum.rawValue)\n"
    }
    if hasBazInt {
      output += "\(indent) bazInt: \(bazInt) \n"
    }
    if hasBazString {
      output += "\(indent) bazString: \(bazString) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFooInt {
             hashCode = (hashCode &* 31) &+ fooInt.hashValue
          }
          if hasFooString {
             hashCode = (hashCode &* 31) &+ fooString.hashValue
          }
          if hasFooCord {
             hashCode = (hashCode &* 31) &+ fooCord.hashValue
          }
          if hasFooStringPiece {
             hashCode = (hashCode &* 31) &+ fooStringPiece.hashValue
          }
          for value in fooBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasFooEnum {
             hashCode = (hashCode &* 31) &+ Int(fooEnum.rawValue)
          }
          if hasFooMessage {
            hashCode = (hashCode &* 31) &+ fooMessage.hashValue
          }
          if hasFooGroup {
            hashCode = (hashCode &* 31) &+ fooGroup.hashValue
          }
          if hasFooLazyMessage {
            hashCode = (hashCode &* 31) &+ fooLazyMessage.hashValue
          }
          if hasBarInt {
             hashCode = (hashCode &* 31) &+ barInt.hashValue
          }
          if hasBarString {
             hashCode = (hashCode &* 31) &+ barString.hashValue
          }
          if hasBarCord {
             hashCode = (hashCode &* 31) &+ barCord.hashValue
          }
          if hasBarStringPiece {
             hashCode = (hashCode &* 31) &+ barStringPiece.hashValue
          }
          for value in barBytes {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          if hasBarEnum {
             hashCode = (hashCode &* 31) &+ Int(barEnum.rawValue)
          }
          if hasBazInt {
             hashCode = (hashCode &* 31) &+ bazInt.hashValue
          }
          if hasBazString {
             hashCode = (hashCode &* 31) &+ bazString.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestOneof2"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestOneof2.self
  }


  //Meta information declaration end

}

final class TestOneof2Builder : GeneratedMessageBuilder {
  private var builderResult:TestOneof2

  required override init () {
     builderResult = TestOneof2()
     super.init()
  }
  var hasFooInt:Bool {
       get {
            return builderResult.hasFooInt
       }
  }
  var fooInt:Int32 {
       get {
            return builderResult.fooInt
       }
       set (value) {
           builderResult.hasFooInt = true
           builderResult.fooInt = value
       }
  }
  func clearFooInt() -> TestOneof2Builder{
       builderResult.hasFooInt = false
       builderResult.fooInt = Int32(0)
       return self
  }
  var hasFooString:Bool {
       get {
            return builderResult.hasFooString
       }
  }
  var fooString:String {
       get {
            return builderResult.fooString
       }
       set (value) {
           builderResult.hasFooString = true
           builderResult.fooString = value
       }
  }
  func clearFooString() -> TestOneof2Builder{
       builderResult.hasFooString = false
       builderResult.fooString = ""
       return self
  }
  var hasFooCord:Bool {
       get {
            return builderResult.hasFooCord
       }
  }
  var fooCord:String {
       get {
            return builderResult.fooCord
       }
       set (value) {
           builderResult.hasFooCord = true
           builderResult.fooCord = value
       }
  }
  func clearFooCord() -> TestOneof2Builder{
       builderResult.hasFooCord = false
       builderResult.fooCord = ""
       return self
  }
  var hasFooStringPiece:Bool {
       get {
            return builderResult.hasFooStringPiece
       }
  }
  var fooStringPiece:String {
       get {
            return builderResult.fooStringPiece
       }
       set (value) {
           builderResult.hasFooStringPiece = true
           builderResult.fooStringPiece = value
       }
  }
  func clearFooStringPiece() -> TestOneof2Builder{
       builderResult.hasFooStringPiece = false
       builderResult.fooStringPiece = ""
       return self
  }
  var hasFooBytes:Bool {
       get {
            return builderResult.hasFooBytes
       }
  }
  var fooBytes:Array<Byte> {
       get {
            return builderResult.fooBytes
       }
       set (value) {
           builderResult.hasFooBytes = true
           builderResult.fooBytes = value
       }
  }
  func clearFooBytes() -> TestOneof2Builder{
       builderResult.hasFooBytes = false
       builderResult.fooBytes = [Byte]()
       return self
  }
    var hasFooEnum:Bool{
        get {
            return builderResult.hasFooEnum
        }
    }
    var fooEnum:TestOneof2.NestedEnum {
        get {
            return builderResult.fooEnum
        }
        set (value) {
            builderResult.hasFooEnum = true
            builderResult.fooEnum = value
        }
    }
    func clearFooEnum() -> TestOneof2Builder {
       builderResult.hasFooEnum = false
       builderResult.fooEnum = .Foo
       return self
    }
  var hasFooMessage:Bool {
       get {
           return builderResult.hasFooMessage
       }
  }
  var fooMessage:TestOneof2.NestedMessage {
       get {
           return builderResult.fooMessage
       }
       set (value) {
           builderResult.hasFooMessage = true
           builderResult.fooMessage = value
       }
  }
  func setFooMessageBuilder(builderForValue:TestOneof2.NestedMessageBuilder) -> TestOneof2Builder {
    fooMessage = builderForValue.build()
    return self
  }
  func mergeFooMessage(value:TestOneof2.NestedMessage) -> TestOneof2Builder {
    if (builderResult.hasFooMessage && builderResult.fooMessage != TestOneof2.NestedMessage()) {
      builderResult.fooMessage = TestOneof2.NestedMessage.builderWithPrototype(builderResult.fooMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooMessage = value
    }
    builderResult.hasFooMessage = true
    return self
  }
  func clearFooMessage() -> TestOneof2Builder {
    builderResult.hasFooMessage = false
    builderResult.fooMessage = TestOneof2.NestedMessage()
    return self
  }
  var hasFooGroup:Bool {
       get {
           return builderResult.hasFooGroup
       }
  }
  var fooGroup:TestOneof2.FooGroup {
       get {
           return builderResult.fooGroup
       }
       set (value) {
           builderResult.hasFooGroup = true
           builderResult.fooGroup = value
       }
  }
  func setFooGroupBuilder(builderForValue:TestOneof2.FooGroupBuilder) -> TestOneof2Builder {
    fooGroup = builderForValue.build()
    return self
  }
  func mergeFooGroup(value:TestOneof2.FooGroup) -> TestOneof2Builder {
    if (builderResult.hasFooGroup && builderResult.fooGroup != TestOneof2.FooGroup()) {
      builderResult.fooGroup = TestOneof2.FooGroup.builderWithPrototype(builderResult.fooGroup).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooGroup = value
    }
    builderResult.hasFooGroup = true
    return self
  }
  func clearFooGroup() -> TestOneof2Builder {
    builderResult.hasFooGroup = false
    builderResult.fooGroup = TestOneof2.FooGroup()
    return self
  }
  var hasFooLazyMessage:Bool {
       get {
           return builderResult.hasFooLazyMessage
       }
  }
  var fooLazyMessage:TestOneof2.NestedMessage {
       get {
           return builderResult.fooLazyMessage
       }
       set (value) {
           builderResult.hasFooLazyMessage = true
           builderResult.fooLazyMessage = value
       }
  }
  func setFooLazyMessageBuilder(builderForValue:TestOneof2.NestedMessageBuilder) -> TestOneof2Builder {
    fooLazyMessage = builderForValue.build()
    return self
  }
  func mergeFooLazyMessage(value:TestOneof2.NestedMessage) -> TestOneof2Builder {
    if (builderResult.hasFooLazyMessage && builderResult.fooLazyMessage != TestOneof2.NestedMessage()) {
      builderResult.fooLazyMessage = TestOneof2.NestedMessage.builderWithPrototype(builderResult.fooLazyMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooLazyMessage = value
    }
    builderResult.hasFooLazyMessage = true
    return self
  }
  func clearFooLazyMessage() -> TestOneof2Builder {
    builderResult.hasFooLazyMessage = false
    builderResult.fooLazyMessage = TestOneof2.NestedMessage()
    return self
  }
  var hasBarInt:Bool {
       get {
            return builderResult.hasBarInt
       }
  }
  var barInt:Int32 {
       get {
            return builderResult.barInt
       }
       set (value) {
           builderResult.hasBarInt = true
           builderResult.barInt = value
       }
  }
  func clearBarInt() -> TestOneof2Builder{
       builderResult.hasBarInt = false
       builderResult.barInt = Int32(5)
       return self
  }
  var hasBarString:Bool {
       get {
            return builderResult.hasBarString
       }
  }
  var barString:String {
       get {
            return builderResult.barString
       }
       set (value) {
           builderResult.hasBarString = true
           builderResult.barString = value
       }
  }
  func clearBarString() -> TestOneof2Builder{
       builderResult.hasBarString = false
       builderResult.barString = "STRING"
       return self
  }
  var hasBarCord:Bool {
       get {
            return builderResult.hasBarCord
       }
  }
  var barCord:String {
       get {
            return builderResult.barCord
       }
       set (value) {
           builderResult.hasBarCord = true
           builderResult.barCord = value
       }
  }
  func clearBarCord() -> TestOneof2Builder{
       builderResult.hasBarCord = false
       builderResult.barCord = "CORD"
       return self
  }
  var hasBarStringPiece:Bool {
       get {
            return builderResult.hasBarStringPiece
       }
  }
  var barStringPiece:String {
       get {
            return builderResult.barStringPiece
       }
       set (value) {
           builderResult.hasBarStringPiece = true
           builderResult.barStringPiece = value
       }
  }
  func clearBarStringPiece() -> TestOneof2Builder{
       builderResult.hasBarStringPiece = false
       builderResult.barStringPiece = "SPIECE"
       return self
  }
  var hasBarBytes:Bool {
       get {
            return builderResult.hasBarBytes
       }
  }
  var barBytes:Array<Byte> {
       get {
            return builderResult.barBytes
       }
       set (value) {
           builderResult.hasBarBytes = true
           builderResult.barBytes = value
       }
  }
  func clearBarBytes() -> TestOneof2Builder{
       builderResult.hasBarBytes = false
       builderResult.barBytes = ([Byte]() + "BYTES".utf8)
       return self
  }
    var hasBarEnum:Bool{
        get {
            return builderResult.hasBarEnum
        }
    }
    var barEnum:TestOneof2.NestedEnum {
        get {
            return builderResult.barEnum
        }
        set (value) {
            builderResult.hasBarEnum = true
            builderResult.barEnum = value
        }
    }
    func clearBarEnum() -> TestOneof2Builder {
       builderResult.hasBarEnum = false
       builderResult.barEnum = .Bar
       return self
    }
  var hasBazInt:Bool {
       get {
            return builderResult.hasBazInt
       }
  }
  var bazInt:Int32 {
       get {
            return builderResult.bazInt
       }
       set (value) {
           builderResult.hasBazInt = true
           builderResult.bazInt = value
       }
  }
  func clearBazInt() -> TestOneof2Builder{
       builderResult.hasBazInt = false
       builderResult.bazInt = Int32(0)
       return self
  }
  var hasBazString:Bool {
       get {
            return builderResult.hasBazString
       }
  }
  var bazString:String {
       get {
            return builderResult.bazString
       }
       set (value) {
           builderResult.hasBazString = true
           builderResult.bazString = value
       }
  }
  func clearBazString() -> TestOneof2Builder{
       builderResult.hasBazString = false
       builderResult.bazString = "BAZ"
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestOneof2Builder {
    builderResult = TestOneof2()
    return self
  }
  override func clone() -> TestOneof2Builder {
    return TestOneof2.builderWithPrototype(builderResult)
  }
  override func build() -> TestOneof2 {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestOneof2 {
    var returnMe:TestOneof2 = builderResult
    return returnMe
  }
  func mergeFrom(other:TestOneof2) -> TestOneof2Builder {
    if (other == TestOneof2()) {
     return self
    }
    if other.hasFooInt {
         fooInt = other.fooInt
    }
    if other.hasFooString {
         fooString = other.fooString
    }
    if other.hasFooCord {
         fooCord = other.fooCord
    }
    if other.hasFooStringPiece {
         fooStringPiece = other.fooStringPiece
    }
    if other.hasFooBytes {
         fooBytes = other.fooBytes
    }
    if other.hasFooEnum {
         fooEnum = other.fooEnum
    }
    if (other.hasFooMessage) {
        mergeFooMessage(other.fooMessage)
    }
    if (other.hasFooGroup) {
        mergeFooGroup(other.fooGroup)
    }
    if (other.hasFooLazyMessage) {
        mergeFooLazyMessage(other.fooLazyMessage)
    }
    if other.hasBarInt {
         barInt = other.barInt
    }
    if other.hasBarString {
         barString = other.barString
    }
    if other.hasBarCord {
         barCord = other.barCord
    }
    if other.hasBarStringPiece {
         barStringPiece = other.barStringPiece
    }
    if other.hasBarBytes {
         barBytes = other.barBytes
    }
    if other.hasBarEnum {
         barEnum = other.barEnum
    }
    if other.hasBazInt {
         bazInt = other.bazInt
    }
    if other.hasBazString {
         bazString = other.bazString
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOneof2Builder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOneof2Builder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        fooInt = input.readInt32()

      case 18 :
        fooString = input.readString()

      case 26 :
        fooCord = input.readString()

      case 34 :
        fooStringPiece = input.readString()

      case 42 :
        fooBytes = input.readData()

      case 48 :
        var value = input.readEnum()
        var enumMergResult:TestOneof2.NestedEnum = TestOneof2.NestedEnum(rawValue:value)!
        if (TestOneof2.NestedEnum.IsValidValue(enumMergResult)) {
             fooEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(6, value:Int64(value))
        }

      case 58 :
        var subBuilder:TestOneof2.NestedMessageBuilder = TestOneof2.NestedMessage.builder()
        if hasFooMessage {
          subBuilder.mergeFrom(fooMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        fooMessage = subBuilder.buildPartial()

      case 67 :
        var subBuilder:TestOneof2.FooGroupBuilder = TestOneof2.FooGroup.builder()
        if hasFooGroup {
          subBuilder.mergeFrom(fooGroup)
        }
        input.readGroup(8, builder:subBuilder, extensionRegistry:extensionRegistry)
        fooGroup = subBuilder.buildPartial()

      case 90 :
        var subBuilder:TestOneof2.NestedMessageBuilder = TestOneof2.NestedMessage.builder()
        if hasFooLazyMessage {
          subBuilder.mergeFrom(fooLazyMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        fooLazyMessage = subBuilder.buildPartial()

      case 96 :
        barInt = input.readInt32()

      case 106 :
        barString = input.readString()

      case 114 :
        barCord = input.readString()

      case 122 :
        barStringPiece = input.readString()

      case 130 :
        barBytes = input.readData()

      case 136 :
        var value = input.readEnum()
        var enumMergResult:TestOneof2.NestedEnum = TestOneof2.NestedEnum(rawValue:value)!
        if (TestOneof2.NestedEnum.IsValidValue(enumMergResult)) {
             barEnum = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(17, value:Int64(value))
        }

      case 144 :
        bazInt = input.readInt32()

      case 154 :
        bazString = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestRequiredOneof : GeneratedMessage {


  //Nested type declaration start

    final public class NestedMessage : GeneratedMessage {
      private(set) var hasRequiredDouble:Bool = false
      private(set) var requiredDouble:Double = Double(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasRequiredDouble {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasRequiredDouble {
          output.writeDouble(1, value:requiredDouble)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasRequiredDouble {
          size += WireFormat.computeDoubleSize(1, value:requiredDouble)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOneof.NestedMessage {
        return TestRequiredOneof.NestedMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestRequiredOneof.NestedMessageBuilder {
        return TestRequiredOneof.NestedMessageBuilder()
      }
      class func builderWithPrototype(prototype:TestRequiredOneof.NestedMessage) -> TestRequiredOneof.NestedMessageBuilder {
        return TestRequiredOneof.NestedMessage.builder().mergeFrom(prototype)
      }
      func builder() -> TestRequiredOneof.NestedMessageBuilder {
        return TestRequiredOneof.NestedMessage.builder()
      }
      func toBuilder() -> TestRequiredOneof.NestedMessageBuilder {
        return TestRequiredOneof.NestedMessage.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasRequiredDouble {
          output += "\(indent) requiredDouble: \(requiredDouble) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasRequiredDouble {
                 hashCode = (hashCode &* 31) &+ requiredDouble.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestRequiredOneof.NestedMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestRequiredOneof.NestedMessage.self
      }


      //Meta information declaration end

    }

    final class NestedMessageBuilder : GeneratedMessageBuilder {
      private var builderResult:TestRequiredOneof.NestedMessage

      required override init () {
         builderResult = TestRequiredOneof.NestedMessage()
         super.init()
      }
      var hasRequiredDouble:Bool {
           get {
                return builderResult.hasRequiredDouble
           }
      }
      var requiredDouble:Double {
           get {
                return builderResult.requiredDouble
           }
           set (value) {
               builderResult.hasRequiredDouble = true
               builderResult.requiredDouble = value
           }
      }
      func clearRequiredDouble() -> TestRequiredOneof.NestedMessageBuilder{
           builderResult.hasRequiredDouble = false
           builderResult.requiredDouble = Double(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestRequiredOneof.NestedMessageBuilder {
        builderResult = TestRequiredOneof.NestedMessage()
        return self
      }
      override func clone() -> TestRequiredOneof.NestedMessageBuilder {
        return TestRequiredOneof.NestedMessage.builderWithPrototype(builderResult)
      }
      override func build() -> TestRequiredOneof.NestedMessage {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestRequiredOneof.NestedMessage {
        var returnMe:TestRequiredOneof.NestedMessage = builderResult
        return returnMe
      }
      func mergeFrom(other:TestRequiredOneof.NestedMessage) -> TestRequiredOneof.NestedMessageBuilder {
        if (other == TestRequiredOneof.NestedMessage()) {
         return self
        }
        if other.hasRequiredDouble {
             requiredDouble = other.requiredDouble
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRequiredOneof.NestedMessageBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOneof.NestedMessageBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 9 :
            requiredDouble = input.readDouble()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //OneOf declaration start

  enum Foo {
    case FooOneOfNotSet

    func checkOneOfIsSet() -> Bool {
         switch self {
         case .FooOneOfNotSet:
              return false
         default:
              return true
         }
    }
    case FooInt(Int32)

    static func getFooInt(value:Foo) ->Int32? {
         switch value {
         case .FooInt(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooString(String)

    static func getFooString(value:Foo) ->String? {
         switch value {
         case .FooString(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
    case FooMessage(TestRequiredOneof.NestedMessage)

    static func getFooMessage(value:Foo) ->TestRequiredOneof.NestedMessage? {
         switch value {
         case .FooMessage(let enumValue):
              return enumValue
         default:
              return nil
         }
    }
  }



  //OneOf declaration end

  private var storageFoo:TestRequiredOneof.Foo =  TestRequiredOneof.Foo.FooOneOfNotSet
  private(set) var hasFooInt:Bool {
        get {
             if TestRequiredOneof.Foo.getFooInt(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooInt:Int32!{
       get {
            return TestRequiredOneof.Foo.getFooInt(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestRequiredOneof.Foo.FooInt(newvalue)
       }
  }
  private(set) var hasFooString:Bool {
        get {
             if TestRequiredOneof.Foo.getFooString(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooString:String!{
       get {
            return TestRequiredOneof.Foo.getFooString(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestRequiredOneof.Foo.FooString(newvalue)
       }
  }
  private(set) var hasFooMessage:Bool {
        get {
             if TestRequiredOneof.Foo.getFooMessage(storageFoo) == nil {
                 return false
             }
             return true
        }
        set(newValue) {
        }
  }
  private(set) var fooMessage:TestRequiredOneof.NestedMessage!{
       get {
            return TestRequiredOneof.Foo.getFooMessage(storageFoo)
       }
       set (newvalue) {
            storageFoo = TestRequiredOneof.Foo.FooMessage(newvalue)
       }
  }
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasFooMessage {
     if !fooMessage.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasFooInt {
      output.writeInt32(1, value:fooInt)
    }
    if hasFooString {
      output.writeString(2, value:fooString)
    }
    if hasFooMessage {
      output.writeMessage(3, value:fooMessage)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasFooInt {
      size += WireFormat.computeInt32Size(1, value:fooInt)
    }
    if hasFooString {
      size += WireFormat.computeStringSize(2, value:fooString)
    }
    if hasFooMessage {
      size += WireFormat.computeMessageSize(3, value:fooMessage)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOneof {
    return TestRequiredOneof.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestRequiredOneofBuilder {
    return TestRequiredOneofBuilder()
  }
  class func builderWithPrototype(prototype:TestRequiredOneof) -> TestRequiredOneofBuilder {
    return TestRequiredOneof.builder().mergeFrom(prototype)
  }
  func builder() -> TestRequiredOneofBuilder {
    return TestRequiredOneof.builder()
  }
  func toBuilder() -> TestRequiredOneofBuilder {
    return TestRequiredOneof.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasFooInt {
      output += "\(indent) fooInt: \(fooInt) \n"
    }
    if hasFooString {
      output += "\(indent) fooString: \(fooString) \n"
    }
    if hasFooMessage {
      output += "\(indent) fooMessage {\n"
      fooMessage.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFooInt {
             hashCode = (hashCode &* 31) &+ fooInt.hashValue
          }
          if hasFooString {
             hashCode = (hashCode &* 31) &+ fooString.hashValue
          }
          if hasFooMessage {
            hashCode = (hashCode &* 31) &+ fooMessage.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestRequiredOneof"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestRequiredOneof.self
  }


  //Meta information declaration end

}

final class TestRequiredOneofBuilder : GeneratedMessageBuilder {
  private var builderResult:TestRequiredOneof

  required override init () {
     builderResult = TestRequiredOneof()
     super.init()
  }
  var hasFooInt:Bool {
       get {
            return builderResult.hasFooInt
       }
  }
  var fooInt:Int32 {
       get {
            return builderResult.fooInt
       }
       set (value) {
           builderResult.hasFooInt = true
           builderResult.fooInt = value
       }
  }
  func clearFooInt() -> TestRequiredOneofBuilder{
       builderResult.hasFooInt = false
       builderResult.fooInt = Int32(0)
       return self
  }
  var hasFooString:Bool {
       get {
            return builderResult.hasFooString
       }
  }
  var fooString:String {
       get {
            return builderResult.fooString
       }
       set (value) {
           builderResult.hasFooString = true
           builderResult.fooString = value
       }
  }
  func clearFooString() -> TestRequiredOneofBuilder{
       builderResult.hasFooString = false
       builderResult.fooString = ""
       return self
  }
  var hasFooMessage:Bool {
       get {
           return builderResult.hasFooMessage
       }
  }
  var fooMessage:TestRequiredOneof.NestedMessage {
       get {
           return builderResult.fooMessage
       }
       set (value) {
           builderResult.hasFooMessage = true
           builderResult.fooMessage = value
       }
  }
  func setFooMessageBuilder(builderForValue:TestRequiredOneof.NestedMessageBuilder) -> TestRequiredOneofBuilder {
    fooMessage = builderForValue.build()
    return self
  }
  func mergeFooMessage(value:TestRequiredOneof.NestedMessage) -> TestRequiredOneofBuilder {
    if (builderResult.hasFooMessage && builderResult.fooMessage != TestRequiredOneof.NestedMessage()) {
      builderResult.fooMessage = TestRequiredOneof.NestedMessage.builderWithPrototype(builderResult.fooMessage).mergeFrom(value).buildPartial()
    } else {
      builderResult.fooMessage = value
    }
    builderResult.hasFooMessage = true
    return self
  }
  func clearFooMessage() -> TestRequiredOneofBuilder {
    builderResult.hasFooMessage = false
    builderResult.fooMessage = TestRequiredOneof.NestedMessage()
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestRequiredOneofBuilder {
    builderResult = TestRequiredOneof()
    return self
  }
  override func clone() -> TestRequiredOneofBuilder {
    return TestRequiredOneof.builderWithPrototype(builderResult)
  }
  override func build() -> TestRequiredOneof {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestRequiredOneof {
    var returnMe:TestRequiredOneof = builderResult
    return returnMe
  }
  func mergeFrom(other:TestRequiredOneof) -> TestRequiredOneofBuilder {
    if (other == TestRequiredOneof()) {
     return self
    }
    if other.hasFooInt {
         fooInt = other.fooInt
    }
    if other.hasFooString {
         fooString = other.fooString
    }
    if (other.hasFooMessage) {
        mergeFooMessage(other.fooMessage)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRequiredOneofBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOneofBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        fooInt = input.readInt32()

      case 18 :
        fooString = input.readString()

      case 26 :
        var subBuilder:TestRequiredOneof.NestedMessageBuilder = TestRequiredOneof.NestedMessage.builder()
        if hasFooMessage {
          subBuilder.mergeFrom(fooMessage)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        fooMessage = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestPackedTypes : GeneratedMessage {
  private(set) var packedInt32:Array<Int32> = Array<Int32>()
  private var packedInt32MemoizedSerializedSize:Int32 = -1
  private(set) var packedInt64:Array<Int64> = Array<Int64>()
  private var packedInt64MemoizedSerializedSize:Int32 = -1
  private(set) var packedUint32:Array<UInt32> = Array<UInt32>()
  private var packedUint32MemoizedSerializedSize:Int32 = -1
  private(set) var packedUint64:Array<UInt64> = Array<UInt64>()
  private var packedUint64MemoizedSerializedSize:Int32 = -1
  private(set) var packedSint32:Array<Int32> = Array<Int32>()
  private var packedSint32MemoizedSerializedSize:Int32 = -1
  private(set) var packedSint64:Array<Int64> = Array<Int64>()
  private var packedSint64MemoizedSerializedSize:Int32 = -1
  private(set) var packedFixed32:Array<UInt32> = Array<UInt32>()
  private var packedFixed32MemoizedSerializedSize:Int32 = -1
  private(set) var packedFixed64:Array<UInt64> = Array<UInt64>()
  private var packedFixed64MemoizedSerializedSize:Int32 = -1
  private(set) var packedSfixed32:Array<Int32> = Array<Int32>()
  private var packedSfixed32MemoizedSerializedSize:Int32 = -1
  private(set) var packedSfixed64:Array<Int64> = Array<Int64>()
  private var packedSfixed64MemoizedSerializedSize:Int32 = -1
  private(set) var packedFloat:Array<Float> = Array<Float>()
  private var packedFloatMemoizedSerializedSize:Int32 = -1
  private(set) var packedDouble:Array<Double> = Array<Double>()
  private var packedDoubleMemoizedSerializedSize:Int32 = -1
  private(set) var packedBool:Array<Bool> = Array<Bool>()
  private var packedBoolMemoizedSerializedSize:Int32 = -1
  private var packedEnumMemoizedSerializedSize:Int32 = 0
  private(set) var packedEnum:Array<ForeignEnum> = Array<ForeignEnum>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if !packedInt32.isEmpty {
      output.writeRawVarint32(722)
      output.writeRawVarint32(packedInt32MemoizedSerializedSize)
      for value in packedInt32 {
        output.writeInt32NoTag(value)
      }
    }
    if !packedInt64.isEmpty {
      output.writeRawVarint32(730)
      output.writeRawVarint32(packedInt64MemoizedSerializedSize)
      for value in packedInt64 {
        output.writeInt64NoTag(value)
      }
    }
    if !packedUint32.isEmpty {
      output.writeRawVarint32(738)
      output.writeRawVarint32(packedUint32MemoizedSerializedSize)
      for value in packedUint32 {
        output.writeUInt32NoTag(value)
      }
    }
    if !packedUint64.isEmpty {
      output.writeRawVarint32(746)
      output.writeRawVarint32(packedUint64MemoizedSerializedSize)
      for value in packedUint64 {
        output.writeUInt64NoTag(value)
      }
    }
    if !packedSint32.isEmpty {
      output.writeRawVarint32(754)
      output.writeRawVarint32(packedSint32MemoizedSerializedSize)
      for value in packedSint32 {
        output.writeSInt32NoTag(value)
      }
    }
    if !packedSint64.isEmpty {
      output.writeRawVarint32(762)
      output.writeRawVarint32(packedSint64MemoizedSerializedSize)
      for value in packedSint64 {
        output.writeSInt64NoTag(value)
      }
    }
    if !packedFixed32.isEmpty {
      output.writeRawVarint32(770)
      output.writeRawVarint32(packedFixed32MemoizedSerializedSize)
      for value in packedFixed32 {
        output.writeFixed32NoTag(value)
      }
    }
    if !packedFixed64.isEmpty {
      output.writeRawVarint32(778)
      output.writeRawVarint32(packedFixed64MemoizedSerializedSize)
      for value in packedFixed64 {
        output.writeFixed64NoTag(value)
      }
    }
    if !packedSfixed32.isEmpty {
      output.writeRawVarint32(786)
      output.writeRawVarint32(packedSfixed32MemoizedSerializedSize)
      for value in packedSfixed32 {
        output.writeSFixed32NoTag(value)
      }
    }
    if !packedSfixed64.isEmpty {
      output.writeRawVarint32(794)
      output.writeRawVarint32(packedSfixed64MemoizedSerializedSize)
      for value in packedSfixed64 {
        output.writeSFixed64NoTag(value)
      }
    }
    if !packedFloat.isEmpty {
      output.writeRawVarint32(802)
      output.writeRawVarint32(packedFloatMemoizedSerializedSize)
      for value in packedFloat {
        output.writeFloatNoTag(value)
      }
    }
    if !packedDouble.isEmpty {
      output.writeRawVarint32(810)
      output.writeRawVarint32(packedDoubleMemoizedSerializedSize)
      for value in packedDouble {
        output.writeDoubleNoTag(value)
      }
    }
    if !packedBool.isEmpty {
      output.writeRawVarint32(818)
      output.writeRawVarint32(packedBoolMemoizedSerializedSize)
      for value in packedBool {
        output.writeBoolNoTag(value)
      }
    }
    if !packedEnum.isEmpty {
      output.writeRawVarint32(826)
      output.writeRawVarint32(packedEnumMemoizedSerializedSize)
    }
    for value in packedEnum {
        output.writeEnumNoTag(value.rawValue)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    var dataSizePackedInt32:Int32 = 0
    for element in packedInt32 {
        dataSizePackedInt32 += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizePackedInt32
    if !packedInt32.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedInt32)
    }
    packedInt32MemoizedSerializedSize = dataSizePackedInt32
    var dataSizePackedInt64:Int32 = 0
    for element in packedInt64 {
        dataSizePackedInt64 += WireFormat.computeInt64SizeNoTag(element)
    }
    size += dataSizePackedInt64
    if !packedInt64.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedInt64)
    }
    packedInt64MemoizedSerializedSize = dataSizePackedInt64
    var dataSizePackedUint32:Int32 = 0
    for element in packedUint32 {
        dataSizePackedUint32 += WireFormat.computeUInt32SizeNoTag(element)
    }
    size += dataSizePackedUint32
    if !packedUint32.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedUint32)
    }
    packedUint32MemoizedSerializedSize = dataSizePackedUint32
    var dataSizePackedUint64:Int32 = 0
    for element in packedUint64 {
        dataSizePackedUint64 += WireFormat.computeUInt64SizeNoTag(element)
    }
    size += dataSizePackedUint64
    if !packedUint64.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedUint64)
    }
    packedUint64MemoizedSerializedSize = dataSizePackedUint64
    var dataSizePackedSint32:Int32 = 0
    for element in packedSint32 {
        dataSizePackedSint32 += WireFormat.computeSInt32SizeNoTag(element)
    }
    size += dataSizePackedSint32
    if !packedSint32.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedSint32)
    }
    packedSint32MemoizedSerializedSize = dataSizePackedSint32
    var dataSizePackedSint64:Int32 = 0
    for element in packedSint64 {
        dataSizePackedSint64 += WireFormat.computeSInt64SizeNoTag(element)
    }
    size += dataSizePackedSint64
    if !packedSint64.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedSint64)
    }
    packedSint64MemoizedSerializedSize = dataSizePackedSint64
    var dataSizePackedFixed32:Int32 = 0
    dataSizePackedFixed32 = 4 * Int32(packedFixed32.count)
    size += dataSizePackedFixed32
    if !packedFixed32.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedFixed32)
    }
    packedFixed32MemoizedSerializedSize = dataSizePackedFixed32
    var dataSizePackedFixed64:Int32 = 0
    dataSizePackedFixed64 = 8 * Int32(packedFixed64.count)
    size += dataSizePackedFixed64
    if !packedFixed64.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedFixed64)
    }
    packedFixed64MemoizedSerializedSize = dataSizePackedFixed64
    var dataSizePackedSfixed32:Int32 = 0
    dataSizePackedSfixed32 = 4 * Int32(packedSfixed32.count)
    size += dataSizePackedSfixed32
    if !packedSfixed32.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedSfixed32)
    }
    packedSfixed32MemoizedSerializedSize = dataSizePackedSfixed32
    var dataSizePackedSfixed64:Int32 = 0
    dataSizePackedSfixed64 = 8 * Int32(packedSfixed64.count)
    size += dataSizePackedSfixed64
    if !packedSfixed64.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedSfixed64)
    }
    packedSfixed64MemoizedSerializedSize = dataSizePackedSfixed64
    var dataSizePackedFloat:Int32 = 0
    dataSizePackedFloat = 4 * Int32(packedFloat.count)
    size += dataSizePackedFloat
    if !packedFloat.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedFloat)
    }
    packedFloatMemoizedSerializedSize = dataSizePackedFloat
    var dataSizePackedDouble:Int32 = 0
    dataSizePackedDouble = 8 * Int32(packedDouble.count)
    size += dataSizePackedDouble
    if !packedDouble.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedDouble)
    }
    packedDoubleMemoizedSerializedSize = dataSizePackedDouble
    var dataSizePackedBool:Int32 = 0
    dataSizePackedBool = 1 * Int32(packedBool.count)
    size += dataSizePackedBool
    if !packedBool.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedBool)
    }
    packedBoolMemoizedSerializedSize = dataSizePackedBool
    var dataSizepackedEnum:Int32 = 0
    for value in packedEnum {
        dataSizepackedEnum += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizepackedEnum
    if !packedEnum.isEmpty {
      size += 2
      size += WireFormat.computeRawVarint32Size(dataSizepackedEnum)
    }
    packedEnumMemoizedSerializedSize = dataSizepackedEnum
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestPackedTypes {
    return TestPackedTypes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestPackedTypes {
    return TestPackedTypes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestPackedTypes {
    return TestPackedTypes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestPackedTypes {
    return TestPackedTypes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestPackedTypes {
    return TestPackedTypes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestPackedTypes {
    return TestPackedTypes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestPackedTypesBuilder {
    return TestPackedTypesBuilder()
  }
  class func builderWithPrototype(prototype:TestPackedTypes) -> TestPackedTypesBuilder {
    return TestPackedTypes.builder().mergeFrom(prototype)
  }
  func builder() -> TestPackedTypesBuilder {
    return TestPackedTypes.builder()
  }
  func toBuilder() -> TestPackedTypesBuilder {
    return TestPackedTypes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var packedInt32ElementIndex:Int = 0
    for element in packedInt32  {
        output += "\(indent) packedInt32[\(packedInt32ElementIndex)]: \(element)\n"
        packedInt32ElementIndex++
    }
    var packedInt64ElementIndex:Int = 0
    for element in packedInt64  {
        output += "\(indent) packedInt64[\(packedInt64ElementIndex)]: \(element)\n"
        packedInt64ElementIndex++
    }
    var packedUint32ElementIndex:Int = 0
    for element in packedUint32  {
        output += "\(indent) packedUint32[\(packedUint32ElementIndex)]: \(element)\n"
        packedUint32ElementIndex++
    }
    var packedUint64ElementIndex:Int = 0
    for element in packedUint64  {
        output += "\(indent) packedUint64[\(packedUint64ElementIndex)]: \(element)\n"
        packedUint64ElementIndex++
    }
    var packedSint32ElementIndex:Int = 0
    for element in packedSint32  {
        output += "\(indent) packedSint32[\(packedSint32ElementIndex)]: \(element)\n"
        packedSint32ElementIndex++
    }
    var packedSint64ElementIndex:Int = 0
    for element in packedSint64  {
        output += "\(indent) packedSint64[\(packedSint64ElementIndex)]: \(element)\n"
        packedSint64ElementIndex++
    }
    var packedFixed32ElementIndex:Int = 0
    for element in packedFixed32  {
        output += "\(indent) packedFixed32[\(packedFixed32ElementIndex)]: \(element)\n"
        packedFixed32ElementIndex++
    }
    var packedFixed64ElementIndex:Int = 0
    for element in packedFixed64  {
        output += "\(indent) packedFixed64[\(packedFixed64ElementIndex)]: \(element)\n"
        packedFixed64ElementIndex++
    }
    var packedSfixed32ElementIndex:Int = 0
    for element in packedSfixed32  {
        output += "\(indent) packedSfixed32[\(packedSfixed32ElementIndex)]: \(element)\n"
        packedSfixed32ElementIndex++
    }
    var packedSfixed64ElementIndex:Int = 0
    for element in packedSfixed64  {
        output += "\(indent) packedSfixed64[\(packedSfixed64ElementIndex)]: \(element)\n"
        packedSfixed64ElementIndex++
    }
    var packedFloatElementIndex:Int = 0
    for element in packedFloat  {
        output += "\(indent) packedFloat[\(packedFloatElementIndex)]: \(element)\n"
        packedFloatElementIndex++
    }
    var packedDoubleElementIndex:Int = 0
    for element in packedDouble  {
        output += "\(indent) packedDouble[\(packedDoubleElementIndex)]: \(element)\n"
        packedDoubleElementIndex++
    }
    var packedBoolElementIndex:Int = 0
    for element in packedBool  {
        output += "\(indent) packedBool[\(packedBoolElementIndex)]: \(element)\n"
        packedBoolElementIndex++
    }
    var packedEnumElementIndex:Int = 0
    for element in packedEnum {
        output += "\(indent) packedEnum[\(packedEnumElementIndex)]: \(element.rawValue)"
        packedEnumElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in packedInt32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedInt64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedUint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedUint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedSint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedSint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedFixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedFixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedSfixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedSfixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedFloat {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedDouble {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedBool {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedEnum {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestPackedTypes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestPackedTypes.self
  }


  //Meta information declaration end

}

final class TestPackedTypesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestPackedTypes

  required override init () {
     builderResult = TestPackedTypes()
     super.init()
  }
  var packedInt32:Array<Int32> {
       get {
           return builderResult.packedInt32
       }
       set (array) {
           builderResult.packedInt32 = array
       }
  }
  func clearPackedInt32() -> TestPackedTypesBuilder {
     builderResult.packedInt32.removeAll(keepCapacity: false)
     return self
  }
  var packedInt64:Array<Int64> {
       get {
           return builderResult.packedInt64
       }
       set (array) {
           builderResult.packedInt64 = array
       }
  }
  func clearPackedInt64() -> TestPackedTypesBuilder {
     builderResult.packedInt64.removeAll(keepCapacity: false)
     return self
  }
  var packedUint32:Array<UInt32> {
       get {
           return builderResult.packedUint32
       }
       set (array) {
           builderResult.packedUint32 = array
       }
  }
  func clearPackedUint32() -> TestPackedTypesBuilder {
     builderResult.packedUint32.removeAll(keepCapacity: false)
     return self
  }
  var packedUint64:Array<UInt64> {
       get {
           return builderResult.packedUint64
       }
       set (array) {
           builderResult.packedUint64 = array
       }
  }
  func clearPackedUint64() -> TestPackedTypesBuilder {
     builderResult.packedUint64.removeAll(keepCapacity: false)
     return self
  }
  var packedSint32:Array<Int32> {
       get {
           return builderResult.packedSint32
       }
       set (array) {
           builderResult.packedSint32 = array
       }
  }
  func clearPackedSint32() -> TestPackedTypesBuilder {
     builderResult.packedSint32.removeAll(keepCapacity: false)
     return self
  }
  var packedSint64:Array<Int64> {
       get {
           return builderResult.packedSint64
       }
       set (array) {
           builderResult.packedSint64 = array
       }
  }
  func clearPackedSint64() -> TestPackedTypesBuilder {
     builderResult.packedSint64.removeAll(keepCapacity: false)
     return self
  }
  var packedFixed32:Array<UInt32> {
       get {
           return builderResult.packedFixed32
       }
       set (array) {
           builderResult.packedFixed32 = array
       }
  }
  func clearPackedFixed32() -> TestPackedTypesBuilder {
     builderResult.packedFixed32.removeAll(keepCapacity: false)
     return self
  }
  var packedFixed64:Array<UInt64> {
       get {
           return builderResult.packedFixed64
       }
       set (array) {
           builderResult.packedFixed64 = array
       }
  }
  func clearPackedFixed64() -> TestPackedTypesBuilder {
     builderResult.packedFixed64.removeAll(keepCapacity: false)
     return self
  }
  var packedSfixed32:Array<Int32> {
       get {
           return builderResult.packedSfixed32
       }
       set (array) {
           builderResult.packedSfixed32 = array
       }
  }
  func clearPackedSfixed32() -> TestPackedTypesBuilder {
     builderResult.packedSfixed32.removeAll(keepCapacity: false)
     return self
  }
  var packedSfixed64:Array<Int64> {
       get {
           return builderResult.packedSfixed64
       }
       set (array) {
           builderResult.packedSfixed64 = array
       }
  }
  func clearPackedSfixed64() -> TestPackedTypesBuilder {
     builderResult.packedSfixed64.removeAll(keepCapacity: false)
     return self
  }
  var packedFloat:Array<Float> {
       get {
           return builderResult.packedFloat
       }
       set (array) {
           builderResult.packedFloat = array
       }
  }
  func clearPackedFloat() -> TestPackedTypesBuilder {
     builderResult.packedFloat.removeAll(keepCapacity: false)
     return self
  }
  var packedDouble:Array<Double> {
       get {
           return builderResult.packedDouble
       }
       set (array) {
           builderResult.packedDouble = array
       }
  }
  func clearPackedDouble() -> TestPackedTypesBuilder {
     builderResult.packedDouble.removeAll(keepCapacity: false)
     return self
  }
  var packedBool:Array<Bool> {
       get {
           return builderResult.packedBool
       }
       set (array) {
           builderResult.packedBool = array
       }
  }
  func clearPackedBool() -> TestPackedTypesBuilder {
     builderResult.packedBool.removeAll(keepCapacity: false)
     return self
  }
  var packedEnum:Array<ForeignEnum> {
      get {
          return builderResult.packedEnum
      }
      set (value) {
          builderResult.packedEnum += value
      }
  }
  func clearPackedEnum() -> TestPackedTypesBuilder {
    builderResult.packedEnum.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestPackedTypesBuilder {
    builderResult = TestPackedTypes()
    return self
  }
  override func clone() -> TestPackedTypesBuilder {
    return TestPackedTypes.builderWithPrototype(builderResult)
  }
  override func build() -> TestPackedTypes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestPackedTypes {
    var returnMe:TestPackedTypes = builderResult
    return returnMe
  }
  func mergeFrom(other:TestPackedTypes) -> TestPackedTypesBuilder {
    if (other == TestPackedTypes()) {
     return self
    }
    if !other.packedInt32.isEmpty {
        builderResult.packedInt32 += other.packedInt32
    }
    if !other.packedInt64.isEmpty {
        builderResult.packedInt64 += other.packedInt64
    }
    if !other.packedUint32.isEmpty {
        builderResult.packedUint32 += other.packedUint32
    }
    if !other.packedUint64.isEmpty {
        builderResult.packedUint64 += other.packedUint64
    }
    if !other.packedSint32.isEmpty {
        builderResult.packedSint32 += other.packedSint32
    }
    if !other.packedSint64.isEmpty {
        builderResult.packedSint64 += other.packedSint64
    }
    if !other.packedFixed32.isEmpty {
        builderResult.packedFixed32 += other.packedFixed32
    }
    if !other.packedFixed64.isEmpty {
        builderResult.packedFixed64 += other.packedFixed64
    }
    if !other.packedSfixed32.isEmpty {
        builderResult.packedSfixed32 += other.packedSfixed32
    }
    if !other.packedSfixed64.isEmpty {
        builderResult.packedSfixed64 += other.packedSfixed64
    }
    if !other.packedFloat.isEmpty {
        builderResult.packedFloat += other.packedFloat
    }
    if !other.packedDouble.isEmpty {
        builderResult.packedDouble += other.packedDouble
    }
    if !other.packedBool.isEmpty {
        builderResult.packedBool += other.packedBool
    }
    if !other.packedEnum.isEmpty {
       builderResult.packedEnum += other.packedEnum
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestPackedTypesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestPackedTypesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 722 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedInt32 += [input.readInt32()]
        }
        input.popLimit(limit)

      case 730 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedInt64 += [input.readInt64()]
        }
        input.popLimit(limit)

      case 738 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedUint32 += [input.readUInt32()]
        }
        input.popLimit(limit)

      case 746 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedUint64 += [input.readUInt64()]
        }
        input.popLimit(limit)

      case 754 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedSint32 += [input.readSInt32()]
        }
        input.popLimit(limit)

      case 762 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedSint64 += [input.readSInt64()]
        }
        input.popLimit(limit)

      case 770 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedFixed32 += [input.readFixed32()]
        }
        input.popLimit(limit)

      case 778 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedFixed64 += [input.readFixed64()]
        }
        input.popLimit(limit)

      case 786 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedSfixed32 += [input.readSFixed32()]
        }
        input.popLimit(limit)

      case 794 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedSfixed64 += [input.readSFixed64()]
        }
        input.popLimit(limit)

      case 802 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedFloat += [input.readFloat()]
        }
        input.popLimit(limit)

      case 810 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedDouble += [input.readDouble()]
        }
        input.popLimit(limit)

      case 818 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedBool += [input.readBool()]
        }
        input.popLimit(limit)

      case 826 :
        var length:Int32 = input.readRawVarint32()
        var oldLimit:Int32 = input.pushLimit(length)
        while input.bytesUntilLimit() > 0 {
        var value:ForeignEnum = ForeignEnum(rawValue:input.readEnum())!
        if ForeignEnum.IsValidValue(value) {
             builderResult.packedEnum += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(103, value:Int64(value.rawValue))
        }
        }
        input.popLimit(oldLimit)

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestUnpackedTypes : GeneratedMessage {
  private(set) var unpackedInt32:Array<Int32> = Array<Int32>()
  private(set) var unpackedInt64:Array<Int64> = Array<Int64>()
  private(set) var unpackedUint32:Array<UInt32> = Array<UInt32>()
  private(set) var unpackedUint64:Array<UInt64> = Array<UInt64>()
  private(set) var unpackedSint32:Array<Int32> = Array<Int32>()
  private(set) var unpackedSint64:Array<Int64> = Array<Int64>()
  private(set) var unpackedFixed32:Array<UInt32> = Array<UInt32>()
  private(set) var unpackedFixed64:Array<UInt64> = Array<UInt64>()
  private(set) var unpackedSfixed32:Array<Int32> = Array<Int32>()
  private(set) var unpackedSfixed64:Array<Int64> = Array<Int64>()
  private(set) var unpackedFloat:Array<Float> = Array<Float>()
  private(set) var unpackedDouble:Array<Double> = Array<Double>()
  private(set) var unpackedBool:Array<Bool> = Array<Bool>()
  private var unpackedEnumMemoizedSerializedSize:Int32 = 0
  private(set) var unpackedEnum:Array<ForeignEnum> = Array<ForeignEnum>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if !unpackedInt32.isEmpty {
      for value in unpackedInt32 {
        output.writeInt32(90, value:value)
      }
    }
    if !unpackedInt64.isEmpty {
      for value in unpackedInt64 {
        output.writeInt64(91, value:value)
      }
    }
    if !unpackedUint32.isEmpty {
      for value in unpackedUint32 {
        output.writeUInt32(92, value:value)
      }
    }
    if !unpackedUint64.isEmpty {
      for value in unpackedUint64 {
        output.writeUInt64(93, value:value)
      }
    }
    if !unpackedSint32.isEmpty {
      for value in unpackedSint32 {
        output.writeSInt32(94, value:value)
      }
    }
    if !unpackedSint64.isEmpty {
      for value in unpackedSint64 {
        output.writeSInt64(95, value:value)
      }
    }
    if !unpackedFixed32.isEmpty {
      for value in unpackedFixed32 {
        output.writeFixed32(96, value:value)
      }
    }
    if !unpackedFixed64.isEmpty {
      for value in unpackedFixed64 {
        output.writeFixed64(97, value:value)
      }
    }
    if !unpackedSfixed32.isEmpty {
      for value in unpackedSfixed32 {
        output.writeSFixed32(98, value:value)
      }
    }
    if !unpackedSfixed64.isEmpty {
      for value in unpackedSfixed64 {
        output.writeSFixed64(99, value:value)
      }
    }
    if !unpackedFloat.isEmpty {
      for value in unpackedFloat {
        output.writeFloat(100, value:value)
      }
    }
    if !unpackedDouble.isEmpty {
      for value in unpackedDouble {
        output.writeDouble(101, value:value)
      }
    }
    if !unpackedBool.isEmpty {
      for value in unpackedBool {
        output.writeBool(102, value:value)
      }
    }
    for value in unpackedEnum {
        output.writeEnum(103, value:value.rawValue)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    var dataSizeUnpackedInt32:Int32 = 0
    for element in unpackedInt32 {
        dataSizeUnpackedInt32 += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizeUnpackedInt32
    size += 2 * Int32(unpackedInt32.count)
    var dataSizeUnpackedInt64:Int32 = 0
    for element in unpackedInt64 {
        dataSizeUnpackedInt64 += WireFormat.computeInt64SizeNoTag(element)
    }
    size += dataSizeUnpackedInt64
    size += 2 * Int32(unpackedInt64.count)
    var dataSizeUnpackedUint32:Int32 = 0
    for element in unpackedUint32 {
        dataSizeUnpackedUint32 += WireFormat.computeUInt32SizeNoTag(element)
    }
    size += dataSizeUnpackedUint32
    size += 2 * Int32(unpackedUint32.count)
    var dataSizeUnpackedUint64:Int32 = 0
    for element in unpackedUint64 {
        dataSizeUnpackedUint64 += WireFormat.computeUInt64SizeNoTag(element)
    }
    size += dataSizeUnpackedUint64
    size += 2 * Int32(unpackedUint64.count)
    var dataSizeUnpackedSint32:Int32 = 0
    for element in unpackedSint32 {
        dataSizeUnpackedSint32 += WireFormat.computeSInt32SizeNoTag(element)
    }
    size += dataSizeUnpackedSint32
    size += 2 * Int32(unpackedSint32.count)
    var dataSizeUnpackedSint64:Int32 = 0
    for element in unpackedSint64 {
        dataSizeUnpackedSint64 += WireFormat.computeSInt64SizeNoTag(element)
    }
    size += dataSizeUnpackedSint64
    size += 2 * Int32(unpackedSint64.count)
    var dataSizeUnpackedFixed32:Int32 = 0
    dataSizeUnpackedFixed32 = 4 * Int32(unpackedFixed32.count)
    size += dataSizeUnpackedFixed32
    size += 2 * Int32(unpackedFixed32.count)
    var dataSizeUnpackedFixed64:Int32 = 0
    dataSizeUnpackedFixed64 = 8 * Int32(unpackedFixed64.count)
    size += dataSizeUnpackedFixed64
    size += 2 * Int32(unpackedFixed64.count)
    var dataSizeUnpackedSfixed32:Int32 = 0
    dataSizeUnpackedSfixed32 = 4 * Int32(unpackedSfixed32.count)
    size += dataSizeUnpackedSfixed32
    size += 2 * Int32(unpackedSfixed32.count)
    var dataSizeUnpackedSfixed64:Int32 = 0
    dataSizeUnpackedSfixed64 = 8 * Int32(unpackedSfixed64.count)
    size += dataSizeUnpackedSfixed64
    size += 2 * Int32(unpackedSfixed64.count)
    var dataSizeUnpackedFloat:Int32 = 0
    dataSizeUnpackedFloat = 4 * Int32(unpackedFloat.count)
    size += dataSizeUnpackedFloat
    size += 2 * Int32(unpackedFloat.count)
    var dataSizeUnpackedDouble:Int32 = 0
    dataSizeUnpackedDouble = 8 * Int32(unpackedDouble.count)
    size += dataSizeUnpackedDouble
    size += 2 * Int32(unpackedDouble.count)
    var dataSizeUnpackedBool:Int32 = 0
    dataSizeUnpackedBool = 1 * Int32(unpackedBool.count)
    size += dataSizeUnpackedBool
    size += 2 * Int32(unpackedBool.count)
    var dataSizeunpackedEnum:Int32 = 0
    for value in unpackedEnum {
        dataSizeunpackedEnum += WireFormat.computeEnumSizeNoTag(value.rawValue)
    }
    size += dataSizeunpackedEnum
    size += (2 * Int32(unpackedEnum.count))
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestUnpackedTypes {
    return TestUnpackedTypes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestUnpackedTypesBuilder {
    return TestUnpackedTypesBuilder()
  }
  class func builderWithPrototype(prototype:TestUnpackedTypes) -> TestUnpackedTypesBuilder {
    return TestUnpackedTypes.builder().mergeFrom(prototype)
  }
  func builder() -> TestUnpackedTypesBuilder {
    return TestUnpackedTypes.builder()
  }
  func toBuilder() -> TestUnpackedTypesBuilder {
    return TestUnpackedTypes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var unpackedInt32ElementIndex:Int = 0
    for element in unpackedInt32  {
        output += "\(indent) unpackedInt32[\(unpackedInt32ElementIndex)]: \(element)\n"
        unpackedInt32ElementIndex++
    }
    var unpackedInt64ElementIndex:Int = 0
    for element in unpackedInt64  {
        output += "\(indent) unpackedInt64[\(unpackedInt64ElementIndex)]: \(element)\n"
        unpackedInt64ElementIndex++
    }
    var unpackedUint32ElementIndex:Int = 0
    for element in unpackedUint32  {
        output += "\(indent) unpackedUint32[\(unpackedUint32ElementIndex)]: \(element)\n"
        unpackedUint32ElementIndex++
    }
    var unpackedUint64ElementIndex:Int = 0
    for element in unpackedUint64  {
        output += "\(indent) unpackedUint64[\(unpackedUint64ElementIndex)]: \(element)\n"
        unpackedUint64ElementIndex++
    }
    var unpackedSint32ElementIndex:Int = 0
    for element in unpackedSint32  {
        output += "\(indent) unpackedSint32[\(unpackedSint32ElementIndex)]: \(element)\n"
        unpackedSint32ElementIndex++
    }
    var unpackedSint64ElementIndex:Int = 0
    for element in unpackedSint64  {
        output += "\(indent) unpackedSint64[\(unpackedSint64ElementIndex)]: \(element)\n"
        unpackedSint64ElementIndex++
    }
    var unpackedFixed32ElementIndex:Int = 0
    for element in unpackedFixed32  {
        output += "\(indent) unpackedFixed32[\(unpackedFixed32ElementIndex)]: \(element)\n"
        unpackedFixed32ElementIndex++
    }
    var unpackedFixed64ElementIndex:Int = 0
    for element in unpackedFixed64  {
        output += "\(indent) unpackedFixed64[\(unpackedFixed64ElementIndex)]: \(element)\n"
        unpackedFixed64ElementIndex++
    }
    var unpackedSfixed32ElementIndex:Int = 0
    for element in unpackedSfixed32  {
        output += "\(indent) unpackedSfixed32[\(unpackedSfixed32ElementIndex)]: \(element)\n"
        unpackedSfixed32ElementIndex++
    }
    var unpackedSfixed64ElementIndex:Int = 0
    for element in unpackedSfixed64  {
        output += "\(indent) unpackedSfixed64[\(unpackedSfixed64ElementIndex)]: \(element)\n"
        unpackedSfixed64ElementIndex++
    }
    var unpackedFloatElementIndex:Int = 0
    for element in unpackedFloat  {
        output += "\(indent) unpackedFloat[\(unpackedFloatElementIndex)]: \(element)\n"
        unpackedFloatElementIndex++
    }
    var unpackedDoubleElementIndex:Int = 0
    for element in unpackedDouble  {
        output += "\(indent) unpackedDouble[\(unpackedDoubleElementIndex)]: \(element)\n"
        unpackedDoubleElementIndex++
    }
    var unpackedBoolElementIndex:Int = 0
    for element in unpackedBool  {
        output += "\(indent) unpackedBool[\(unpackedBoolElementIndex)]: \(element)\n"
        unpackedBoolElementIndex++
    }
    var unpackedEnumElementIndex:Int = 0
    for element in unpackedEnum {
        output += "\(indent) unpackedEnum[\(unpackedEnumElementIndex)]: \(element.rawValue)"
        unpackedEnumElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in unpackedInt32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedInt64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedUint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedUint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedSint32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedSint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedFixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedFixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedSfixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedSfixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedFloat {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedDouble {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedBool {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in unpackedEnum {
              hashCode = (hashCode &* 31) &+ Int(element.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestUnpackedTypes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestUnpackedTypes.self
  }


  //Meta information declaration end

}

final class TestUnpackedTypesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestUnpackedTypes

  required override init () {
     builderResult = TestUnpackedTypes()
     super.init()
  }
  var unpackedInt32:Array<Int32> {
       get {
           return builderResult.unpackedInt32
       }
       set (array) {
           builderResult.unpackedInt32 = array
       }
  }
  func clearUnpackedInt32() -> TestUnpackedTypesBuilder {
     builderResult.unpackedInt32.removeAll(keepCapacity: false)
     return self
  }
  var unpackedInt64:Array<Int64> {
       get {
           return builderResult.unpackedInt64
       }
       set (array) {
           builderResult.unpackedInt64 = array
       }
  }
  func clearUnpackedInt64() -> TestUnpackedTypesBuilder {
     builderResult.unpackedInt64.removeAll(keepCapacity: false)
     return self
  }
  var unpackedUint32:Array<UInt32> {
       get {
           return builderResult.unpackedUint32
       }
       set (array) {
           builderResult.unpackedUint32 = array
       }
  }
  func clearUnpackedUint32() -> TestUnpackedTypesBuilder {
     builderResult.unpackedUint32.removeAll(keepCapacity: false)
     return self
  }
  var unpackedUint64:Array<UInt64> {
       get {
           return builderResult.unpackedUint64
       }
       set (array) {
           builderResult.unpackedUint64 = array
       }
  }
  func clearUnpackedUint64() -> TestUnpackedTypesBuilder {
     builderResult.unpackedUint64.removeAll(keepCapacity: false)
     return self
  }
  var unpackedSint32:Array<Int32> {
       get {
           return builderResult.unpackedSint32
       }
       set (array) {
           builderResult.unpackedSint32 = array
       }
  }
  func clearUnpackedSint32() -> TestUnpackedTypesBuilder {
     builderResult.unpackedSint32.removeAll(keepCapacity: false)
     return self
  }
  var unpackedSint64:Array<Int64> {
       get {
           return builderResult.unpackedSint64
       }
       set (array) {
           builderResult.unpackedSint64 = array
       }
  }
  func clearUnpackedSint64() -> TestUnpackedTypesBuilder {
     builderResult.unpackedSint64.removeAll(keepCapacity: false)
     return self
  }
  var unpackedFixed32:Array<UInt32> {
       get {
           return builderResult.unpackedFixed32
       }
       set (array) {
           builderResult.unpackedFixed32 = array
       }
  }
  func clearUnpackedFixed32() -> TestUnpackedTypesBuilder {
     builderResult.unpackedFixed32.removeAll(keepCapacity: false)
     return self
  }
  var unpackedFixed64:Array<UInt64> {
       get {
           return builderResult.unpackedFixed64
       }
       set (array) {
           builderResult.unpackedFixed64 = array
       }
  }
  func clearUnpackedFixed64() -> TestUnpackedTypesBuilder {
     builderResult.unpackedFixed64.removeAll(keepCapacity: false)
     return self
  }
  var unpackedSfixed32:Array<Int32> {
       get {
           return builderResult.unpackedSfixed32
       }
       set (array) {
           builderResult.unpackedSfixed32 = array
       }
  }
  func clearUnpackedSfixed32() -> TestUnpackedTypesBuilder {
     builderResult.unpackedSfixed32.removeAll(keepCapacity: false)
     return self
  }
  var unpackedSfixed64:Array<Int64> {
       get {
           return builderResult.unpackedSfixed64
       }
       set (array) {
           builderResult.unpackedSfixed64 = array
       }
  }
  func clearUnpackedSfixed64() -> TestUnpackedTypesBuilder {
     builderResult.unpackedSfixed64.removeAll(keepCapacity: false)
     return self
  }
  var unpackedFloat:Array<Float> {
       get {
           return builderResult.unpackedFloat
       }
       set (array) {
           builderResult.unpackedFloat = array
       }
  }
  func clearUnpackedFloat() -> TestUnpackedTypesBuilder {
     builderResult.unpackedFloat.removeAll(keepCapacity: false)
     return self
  }
  var unpackedDouble:Array<Double> {
       get {
           return builderResult.unpackedDouble
       }
       set (array) {
           builderResult.unpackedDouble = array
       }
  }
  func clearUnpackedDouble() -> TestUnpackedTypesBuilder {
     builderResult.unpackedDouble.removeAll(keepCapacity: false)
     return self
  }
  var unpackedBool:Array<Bool> {
       get {
           return builderResult.unpackedBool
       }
       set (array) {
           builderResult.unpackedBool = array
       }
  }
  func clearUnpackedBool() -> TestUnpackedTypesBuilder {
     builderResult.unpackedBool.removeAll(keepCapacity: false)
     return self
  }
  var unpackedEnum:Array<ForeignEnum> {
      get {
          return builderResult.unpackedEnum
      }
      set (value) {
          builderResult.unpackedEnum += value
      }
  }
  func clearUnpackedEnum() -> TestUnpackedTypesBuilder {
    builderResult.unpackedEnum.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestUnpackedTypesBuilder {
    builderResult = TestUnpackedTypes()
    return self
  }
  override func clone() -> TestUnpackedTypesBuilder {
    return TestUnpackedTypes.builderWithPrototype(builderResult)
  }
  override func build() -> TestUnpackedTypes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestUnpackedTypes {
    var returnMe:TestUnpackedTypes = builderResult
    return returnMe
  }
  func mergeFrom(other:TestUnpackedTypes) -> TestUnpackedTypesBuilder {
    if (other == TestUnpackedTypes()) {
     return self
    }
    if !other.unpackedInt32.isEmpty {
        builderResult.unpackedInt32 += other.unpackedInt32
    }
    if !other.unpackedInt64.isEmpty {
        builderResult.unpackedInt64 += other.unpackedInt64
    }
    if !other.unpackedUint32.isEmpty {
        builderResult.unpackedUint32 += other.unpackedUint32
    }
    if !other.unpackedUint64.isEmpty {
        builderResult.unpackedUint64 += other.unpackedUint64
    }
    if !other.unpackedSint32.isEmpty {
        builderResult.unpackedSint32 += other.unpackedSint32
    }
    if !other.unpackedSint64.isEmpty {
        builderResult.unpackedSint64 += other.unpackedSint64
    }
    if !other.unpackedFixed32.isEmpty {
        builderResult.unpackedFixed32 += other.unpackedFixed32
    }
    if !other.unpackedFixed64.isEmpty {
        builderResult.unpackedFixed64 += other.unpackedFixed64
    }
    if !other.unpackedSfixed32.isEmpty {
        builderResult.unpackedSfixed32 += other.unpackedSfixed32
    }
    if !other.unpackedSfixed64.isEmpty {
        builderResult.unpackedSfixed64 += other.unpackedSfixed64
    }
    if !other.unpackedFloat.isEmpty {
        builderResult.unpackedFloat += other.unpackedFloat
    }
    if !other.unpackedDouble.isEmpty {
        builderResult.unpackedDouble += other.unpackedDouble
    }
    if !other.unpackedBool.isEmpty {
        builderResult.unpackedBool += other.unpackedBool
    }
    if !other.unpackedEnum.isEmpty {
       builderResult.unpackedEnum += other.unpackedEnum
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestUnpackedTypesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestUnpackedTypesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 720 :
        unpackedInt32 += [input.readInt32()]

      case 728 :
        unpackedInt64 += [input.readInt64()]

      case 736 :
        unpackedUint32 += [input.readUInt32()]

      case 744 :
        unpackedUint64 += [input.readUInt64()]

      case 752 :
        unpackedSint32 += [input.readSInt32()]

      case 760 :
        unpackedSint64 += [input.readSInt64()]

      case 773 :
        unpackedFixed32 += [input.readFixed32()]

      case 777 :
        unpackedFixed64 += [input.readFixed64()]

      case 789 :
        unpackedSfixed32 += [input.readSFixed32()]

      case 793 :
        unpackedSfixed64 += [input.readSFixed64()]

      case 805 :
        unpackedFloat += [input.readFloat()]

      case 809 :
        unpackedDouble += [input.readDouble()]

      case 816 :
        unpackedBool += [input.readBool()]

      case 824 :
        var value:ForeignEnum = ForeignEnum(rawValue:input.readEnum())!
        if ForeignEnum.IsValidValue(value) {
             builderResult.unpackedEnum += [value]
        } else {
             unknownFieldsBuilder.mergeVarintField(103, value:Int64(value.rawValue))
        }

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestPackedExtensions : ExtendableMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestPackedExtensions {
    return TestPackedExtensions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestPackedExtensionsBuilder {
    return TestPackedExtensionsBuilder()
  }
  class func builderWithPrototype(prototype:TestPackedExtensions) -> TestPackedExtensionsBuilder {
    return TestPackedExtensions.builder().mergeFrom(prototype)
  }
  func builder() -> TestPackedExtensionsBuilder {
    return TestPackedExtensions.builder()
  }
  func toBuilder() -> TestPackedExtensionsBuilder {
    return TestPackedExtensions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(1), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestPackedExtensions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestPackedExtensions.self
  }


  //Meta information declaration end

}

final class TestPackedExtensionsBuilder : ExtendableMessageBuilder {
  private var builderResult:TestPackedExtensions

  required override init () {
     builderResult = TestPackedExtensions()
     super.init()
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestPackedExtensionsBuilder {
    builderResult = TestPackedExtensions()
    return self
  }
  override func clone() -> TestPackedExtensionsBuilder {
    return TestPackedExtensions.builderWithPrototype(builderResult)
  }
  override func build() -> TestPackedExtensions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestPackedExtensions {
    var returnMe:TestPackedExtensions = builderResult
    return returnMe
  }
  func mergeFrom(other:TestPackedExtensions) -> TestPackedExtensionsBuilder {
    if (other == TestPackedExtensions()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestPackedExtensionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestPackedExtensionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestUnpackedExtensions : ExtendableMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestUnpackedExtensions {
    return TestUnpackedExtensions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestUnpackedExtensionsBuilder {
    return TestUnpackedExtensionsBuilder()
  }
  class func builderWithPrototype(prototype:TestUnpackedExtensions) -> TestUnpackedExtensionsBuilder {
    return TestUnpackedExtensions.builder().mergeFrom(prototype)
  }
  func builder() -> TestUnpackedExtensionsBuilder {
    return TestUnpackedExtensions.builder()
  }
  func toBuilder() -> TestUnpackedExtensionsBuilder {
    return TestUnpackedExtensions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(1), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestUnpackedExtensions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestUnpackedExtensions.self
  }


  //Meta information declaration end

}

final class TestUnpackedExtensionsBuilder : ExtendableMessageBuilder {
  private var builderResult:TestUnpackedExtensions

  required override init () {
     builderResult = TestUnpackedExtensions()
     super.init()
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestUnpackedExtensionsBuilder {
    builderResult = TestUnpackedExtensions()
    return self
  }
  override func clone() -> TestUnpackedExtensionsBuilder {
    return TestUnpackedExtensions.builderWithPrototype(builderResult)
  }
  override func build() -> TestUnpackedExtensions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestUnpackedExtensions {
    var returnMe:TestUnpackedExtensions = builderResult
    return returnMe
  }
  func mergeFrom(other:TestUnpackedExtensions) -> TestUnpackedExtensionsBuilder {
    if (other == TestUnpackedExtensions()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestUnpackedExtensionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestUnpackedExtensionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestDynamicExtensions : GeneratedMessage {


  //Nested type declaration start

    final public class DynamicMessageType : GeneratedMessage {
      private(set) var hasDynamicField:Bool = false
      private(set) var dynamicField:Int32 = Int32(0)

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasDynamicField {
          output.writeInt32(2100, value:dynamicField)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasDynamicField {
          size += WireFormat.computeInt32Size(2100, value:dynamicField)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions.DynamicMessageType {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        return TestDynamicExtensions.DynamicMessageTypeBuilder()
      }
      class func builderWithPrototype(prototype:TestDynamicExtensions.DynamicMessageType) -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFrom(prototype)
      }
      func builder() -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        return TestDynamicExtensions.DynamicMessageType.builder()
      }
      func toBuilder() -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        return TestDynamicExtensions.DynamicMessageType.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasDynamicField {
          output += "\(indent) dynamicField: \(dynamicField) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasDynamicField {
                 hashCode = (hashCode &* 31) &+ dynamicField.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestDynamicExtensions.DynamicMessageType"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestDynamicExtensions.DynamicMessageType.self
      }


      //Meta information declaration end

    }

    final class DynamicMessageTypeBuilder : GeneratedMessageBuilder {
      private var builderResult:TestDynamicExtensions.DynamicMessageType

      required override init () {
         builderResult = TestDynamicExtensions.DynamicMessageType()
         super.init()
      }
      var hasDynamicField:Bool {
           get {
                return builderResult.hasDynamicField
           }
      }
      var dynamicField:Int32 {
           get {
                return builderResult.dynamicField
           }
           set (value) {
               builderResult.hasDynamicField = true
               builderResult.dynamicField = value
           }
      }
      func clearDynamicField() -> TestDynamicExtensions.DynamicMessageTypeBuilder{
           builderResult.hasDynamicField = false
           builderResult.dynamicField = Int32(0)
           return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        builderResult = TestDynamicExtensions.DynamicMessageType()
        return self
      }
      override func clone() -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        return TestDynamicExtensions.DynamicMessageType.builderWithPrototype(builderResult)
      }
      override func build() -> TestDynamicExtensions.DynamicMessageType {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestDynamicExtensions.DynamicMessageType {
        var returnMe:TestDynamicExtensions.DynamicMessageType = builderResult
        return returnMe
      }
      func mergeFrom(other:TestDynamicExtensions.DynamicMessageType) -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        if (other == TestDynamicExtensions.DynamicMessageType()) {
         return self
        }
        if other.hasDynamicField {
             dynamicField = other.dynamicField
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDynamicExtensions.DynamicMessageTypeBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions.DynamicMessageTypeBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 16800 :
            dynamicField = input.readInt32()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



    //Enum type declaration start 

    enum DynamicEnumType:Int32 {
      case DynamicFoo = 2200
      case DynamicBar = 2201
      case DynamicBaz = 2202

      static func IsValidValue(value:DynamicEnumType) ->Bool {
        switch value {
          case .DynamicFoo, .DynamicBar, .DynamicBaz:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var hasScalarExtension:Bool = false
  private(set) var scalarExtension:UInt32 = UInt32(0)

  private(set) var enumExtension:ForeignEnum = ForeignEnum.ForeignFoo
  private(set) var hasEnumExtension:Bool = false
  private(set) var dynamicEnumExtension:TestDynamicExtensions.DynamicEnumType = TestDynamicExtensions.DynamicEnumType.DynamicFoo
  private(set) var hasDynamicEnumExtension:Bool = false
  private(set) var hasMessageExtension:Bool = false
  private(set) var messageExtension:ForeignMessage = ForeignMessage()
  private(set) var hasDynamicMessageExtension:Bool = false
  private(set) var dynamicMessageExtension:TestDynamicExtensions.DynamicMessageType = TestDynamicExtensions.DynamicMessageType()
  private(set) var repeatedExtension:Array<String> = Array<String>()
  private(set) var packedExtension:Array<Int32> = Array<Int32>()
  private var packedExtensionMemoizedSerializedSize:Int32 = -1
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasScalarExtension {
      output.writeFixed32(2000, value:scalarExtension)
    }
    if hasEnumExtension {
      output.writeEnum(2001, value:enumExtension.rawValue)
    }
    if hasDynamicEnumExtension {
      output.writeEnum(2002, value:dynamicEnumExtension.rawValue)
    }
    if hasMessageExtension {
      output.writeMessage(2003, value:messageExtension)
    }
    if hasDynamicMessageExtension {
      output.writeMessage(2004, value:dynamicMessageExtension)
    }
    if !repeatedExtension.isEmpty {
      for value in repeatedExtension {
        output.writeString(2005, value:value)
      }
    }
    if !packedExtension.isEmpty {
      output.writeRawVarint32(16050)
      output.writeRawVarint32(packedExtensionMemoizedSerializedSize)
      for value in packedExtension {
        output.writeSInt32NoTag(value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasScalarExtension {
      size += WireFormat.computeFixed32Size(2000, value:scalarExtension)
    }
    if (hasEnumExtension) {
      size += WireFormat.computeEnumSize(2001, value:enumExtension.rawValue)
    }
    if (hasDynamicEnumExtension) {
      size += WireFormat.computeEnumSize(2002, value:dynamicEnumExtension.rawValue)
    }
    if hasMessageExtension {
      size += WireFormat.computeMessageSize(2003, value:messageExtension)
    }
    if hasDynamicMessageExtension {
      size += WireFormat.computeMessageSize(2004, value:dynamicMessageExtension)
    }
    var dataSizeRepeatedExtension:Int32 = 0
    for element in repeatedExtension {
        dataSizeRepeatedExtension += WireFormat.computeStringSizeNoTag(element)
    }
    size += dataSizeRepeatedExtension
    size += 2 * Int32(repeatedExtension.count)
    var dataSizePackedExtension:Int32 = 0
    for element in packedExtension {
        dataSizePackedExtension += WireFormat.computeSInt32SizeNoTag(element)
    }
    size += dataSizePackedExtension
    if !packedExtension.isEmpty {
      size += 2
      size += WireFormat.computeInt32SizeNoTag(dataSizePackedExtension)
    }
    packedExtensionMemoizedSerializedSize = dataSizePackedExtension
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions {
    return TestDynamicExtensions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestDynamicExtensionsBuilder {
    return TestDynamicExtensionsBuilder()
  }
  class func builderWithPrototype(prototype:TestDynamicExtensions) -> TestDynamicExtensionsBuilder {
    return TestDynamicExtensions.builder().mergeFrom(prototype)
  }
  func builder() -> TestDynamicExtensionsBuilder {
    return TestDynamicExtensions.builder()
  }
  func toBuilder() -> TestDynamicExtensionsBuilder {
    return TestDynamicExtensions.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasScalarExtension {
      output += "\(indent) scalarExtension: \(scalarExtension) \n"
    }
    if (hasEnumExtension) {
      output += "\(indent) enumExtension: \(enumExtension.rawValue)\n"
    }
    if (hasDynamicEnumExtension) {
      output += "\(indent) dynamicEnumExtension: \(dynamicEnumExtension.rawValue)\n"
    }
    if hasMessageExtension {
      output += "\(indent) messageExtension {\n"
      messageExtension.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasDynamicMessageExtension {
      output += "\(indent) dynamicMessageExtension {\n"
      dynamicMessageExtension.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var repeatedExtensionElementIndex:Int = 0
    for element in repeatedExtension  {
        output += "\(indent) repeatedExtension[\(repeatedExtensionElementIndex)]: \(element)\n"
        repeatedExtensionElementIndex++
    }
    var packedExtensionElementIndex:Int = 0
    for element in packedExtension  {
        output += "\(indent) packedExtension[\(packedExtensionElementIndex)]: \(element)\n"
        packedExtensionElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasScalarExtension {
             hashCode = (hashCode &* 31) &+ scalarExtension.hashValue
          }
          if hasEnumExtension {
             hashCode = (hashCode &* 31) &+ Int(enumExtension.rawValue)
          }
          if hasDynamicEnumExtension {
             hashCode = (hashCode &* 31) &+ Int(dynamicEnumExtension.rawValue)
          }
          if hasMessageExtension {
            hashCode = (hashCode &* 31) &+ messageExtension.hashValue
          }
          if hasDynamicMessageExtension {
            hashCode = (hashCode &* 31) &+ dynamicMessageExtension.hashValue
          }
          for element in repeatedExtension {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in packedExtension {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestDynamicExtensions"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestDynamicExtensions.self
  }


  //Meta information declaration end

}

final class TestDynamicExtensionsBuilder : GeneratedMessageBuilder {
  private var builderResult:TestDynamicExtensions

  required override init () {
     builderResult = TestDynamicExtensions()
     super.init()
  }
  var hasScalarExtension:Bool {
       get {
            return builderResult.hasScalarExtension
       }
  }
  var scalarExtension:UInt32 {
       get {
            return builderResult.scalarExtension
       }
       set (value) {
           builderResult.hasScalarExtension = true
           builderResult.scalarExtension = value
       }
  }
  func clearScalarExtension() -> TestDynamicExtensionsBuilder{
       builderResult.hasScalarExtension = false
       builderResult.scalarExtension = UInt32(0)
       return self
  }
    var hasEnumExtension:Bool{
        get {
            return builderResult.hasEnumExtension
        }
    }
    var enumExtension:ForeignEnum {
        get {
            return builderResult.enumExtension
        }
        set (value) {
            builderResult.hasEnumExtension = true
            builderResult.enumExtension = value
        }
    }
    func clearEnumExtension() -> TestDynamicExtensionsBuilder {
       builderResult.hasEnumExtension = false
       builderResult.enumExtension = .ForeignFoo
       return self
    }
    var hasDynamicEnumExtension:Bool{
        get {
            return builderResult.hasDynamicEnumExtension
        }
    }
    var dynamicEnumExtension:TestDynamicExtensions.DynamicEnumType {
        get {
            return builderResult.dynamicEnumExtension
        }
        set (value) {
            builderResult.hasDynamicEnumExtension = true
            builderResult.dynamicEnumExtension = value
        }
    }
    func clearDynamicEnumExtension() -> TestDynamicExtensionsBuilder {
       builderResult.hasDynamicEnumExtension = false
       builderResult.dynamicEnumExtension = .DynamicFoo
       return self
    }
  var hasMessageExtension:Bool {
       get {
           return builderResult.hasMessageExtension
       }
  }
  var messageExtension:ForeignMessage {
       get {
           return builderResult.messageExtension
       }
       set (value) {
           builderResult.hasMessageExtension = true
           builderResult.messageExtension = value
       }
  }
  func setMessageExtensionBuilder(builderForValue:ForeignMessageBuilder) -> TestDynamicExtensionsBuilder {
    messageExtension = builderForValue.build()
    return self
  }
  func mergeMessageExtension(value:ForeignMessage) -> TestDynamicExtensionsBuilder {
    if (builderResult.hasMessageExtension && builderResult.messageExtension != ForeignMessage()) {
      builderResult.messageExtension = ForeignMessage.builderWithPrototype(builderResult.messageExtension).mergeFrom(value).buildPartial()
    } else {
      builderResult.messageExtension = value
    }
    builderResult.hasMessageExtension = true
    return self
  }
  func clearMessageExtension() -> TestDynamicExtensionsBuilder {
    builderResult.hasMessageExtension = false
    builderResult.messageExtension = ForeignMessage()
    return self
  }
  var hasDynamicMessageExtension:Bool {
       get {
           return builderResult.hasDynamicMessageExtension
       }
  }
  var dynamicMessageExtension:TestDynamicExtensions.DynamicMessageType {
       get {
           return builderResult.dynamicMessageExtension
       }
       set (value) {
           builderResult.hasDynamicMessageExtension = true
           builderResult.dynamicMessageExtension = value
       }
  }
  func setDynamicMessageExtensionBuilder(builderForValue:TestDynamicExtensions.DynamicMessageTypeBuilder) -> TestDynamicExtensionsBuilder {
    dynamicMessageExtension = builderForValue.build()
    return self
  }
  func mergeDynamicMessageExtension(value:TestDynamicExtensions.DynamicMessageType) -> TestDynamicExtensionsBuilder {
    if (builderResult.hasDynamicMessageExtension && builderResult.dynamicMessageExtension != TestDynamicExtensions.DynamicMessageType()) {
      builderResult.dynamicMessageExtension = TestDynamicExtensions.DynamicMessageType.builderWithPrototype(builderResult.dynamicMessageExtension).mergeFrom(value).buildPartial()
    } else {
      builderResult.dynamicMessageExtension = value
    }
    builderResult.hasDynamicMessageExtension = true
    return self
  }
  func clearDynamicMessageExtension() -> TestDynamicExtensionsBuilder {
    builderResult.hasDynamicMessageExtension = false
    builderResult.dynamicMessageExtension = TestDynamicExtensions.DynamicMessageType()
    return self
  }
  var repeatedExtension:Array<String> {
       get {
           return builderResult.repeatedExtension
       }
       set (array) {
           builderResult.repeatedExtension = array
       }
  }
  func clearRepeatedExtension() -> TestDynamicExtensionsBuilder {
     builderResult.repeatedExtension.removeAll(keepCapacity: false)
     return self
  }
  var packedExtension:Array<Int32> {
       get {
           return builderResult.packedExtension
       }
       set (array) {
           builderResult.packedExtension = array
       }
  }
  func clearPackedExtension() -> TestDynamicExtensionsBuilder {
     builderResult.packedExtension.removeAll(keepCapacity: false)
     return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestDynamicExtensionsBuilder {
    builderResult = TestDynamicExtensions()
    return self
  }
  override func clone() -> TestDynamicExtensionsBuilder {
    return TestDynamicExtensions.builderWithPrototype(builderResult)
  }
  override func build() -> TestDynamicExtensions {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestDynamicExtensions {
    var returnMe:TestDynamicExtensions = builderResult
    return returnMe
  }
  func mergeFrom(other:TestDynamicExtensions) -> TestDynamicExtensionsBuilder {
    if (other == TestDynamicExtensions()) {
     return self
    }
    if other.hasScalarExtension {
         scalarExtension = other.scalarExtension
    }
    if other.hasEnumExtension {
         enumExtension = other.enumExtension
    }
    if other.hasDynamicEnumExtension {
         dynamicEnumExtension = other.dynamicEnumExtension
    }
    if (other.hasMessageExtension) {
        mergeMessageExtension(other.messageExtension)
    }
    if (other.hasDynamicMessageExtension) {
        mergeDynamicMessageExtension(other.dynamicMessageExtension)
    }
    if !other.repeatedExtension.isEmpty {
        builderResult.repeatedExtension += other.repeatedExtension
    }
    if !other.packedExtension.isEmpty {
        builderResult.packedExtension += other.packedExtension
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestDynamicExtensionsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensionsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 16005 :
        scalarExtension = input.readFixed32()

      case 16008 :
        var value = input.readEnum()
        var enumMergResult:ForeignEnum = ForeignEnum(rawValue:value)!
        if (ForeignEnum.IsValidValue(enumMergResult)) {
             enumExtension = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(2001, value:Int64(value))
        }

      case 16016 :
        var value = input.readEnum()
        var enumMergResult:TestDynamicExtensions.DynamicEnumType = TestDynamicExtensions.DynamicEnumType(rawValue:value)!
        if (TestDynamicExtensions.DynamicEnumType.IsValidValue(enumMergResult)) {
             dynamicEnumExtension = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(2002, value:Int64(value))
        }

      case 16026 :
        var subBuilder:ForeignMessageBuilder = ForeignMessage.builder()
        if hasMessageExtension {
          subBuilder.mergeFrom(messageExtension)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        messageExtension = subBuilder.buildPartial()

      case 16034 :
        var subBuilder:TestDynamicExtensions.DynamicMessageTypeBuilder = TestDynamicExtensions.DynamicMessageType.builder()
        if hasDynamicMessageExtension {
          subBuilder.mergeFrom(dynamicMessageExtension)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        dynamicMessageExtension = subBuilder.buildPartial()

      case 16042 :
        repeatedExtension += [input.readString()]

      case 16050 :
        var length:Int32 = input.readRawVarint32()
        var limit:Int32 = input.pushLimit(length)
        while (input.bytesUntilLimit() > 0) {
          builderResult.packedExtension += [input.readSInt32()]
        }
        input.popLimit(limit)

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestRepeatedScalarDifferentTagSizes : GeneratedMessage {
  private(set) var repeatedFixed32:Array<UInt32> = Array<UInt32>()
  private(set) var repeatedInt32:Array<Int32> = Array<Int32>()
  private(set) var repeatedFixed64:Array<UInt64> = Array<UInt64>()
  private(set) var repeatedInt64:Array<Int64> = Array<Int64>()
  private(set) var repeatedFloat:Array<Float> = Array<Float>()
  private(set) var repeatedUint64:Array<UInt64> = Array<UInt64>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if !repeatedFixed32.isEmpty {
      for value in repeatedFixed32 {
        output.writeFixed32(12, value:value)
      }
    }
    if !repeatedInt32.isEmpty {
      for value in repeatedInt32 {
        output.writeInt32(13, value:value)
      }
    }
    if !repeatedFixed64.isEmpty {
      for value in repeatedFixed64 {
        output.writeFixed64(2046, value:value)
      }
    }
    if !repeatedInt64.isEmpty {
      for value in repeatedInt64 {
        output.writeInt64(2047, value:value)
      }
    }
    if !repeatedFloat.isEmpty {
      for value in repeatedFloat {
        output.writeFloat(262142, value:value)
      }
    }
    if !repeatedUint64.isEmpty {
      for value in repeatedUint64 {
        output.writeUInt64(262143, value:value)
      }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    var dataSizeRepeatedFixed32:Int32 = 0
    dataSizeRepeatedFixed32 = 4 * Int32(repeatedFixed32.count)
    size += dataSizeRepeatedFixed32
    size += 1 * Int32(repeatedFixed32.count)
    var dataSizeRepeatedInt32:Int32 = 0
    for element in repeatedInt32 {
        dataSizeRepeatedInt32 += WireFormat.computeInt32SizeNoTag(element)
    }
    size += dataSizeRepeatedInt32
    size += 1 * Int32(repeatedInt32.count)
    var dataSizeRepeatedFixed64:Int32 = 0
    dataSizeRepeatedFixed64 = 8 * Int32(repeatedFixed64.count)
    size += dataSizeRepeatedFixed64
    size += 2 * Int32(repeatedFixed64.count)
    var dataSizeRepeatedInt64:Int32 = 0
    for element in repeatedInt64 {
        dataSizeRepeatedInt64 += WireFormat.computeInt64SizeNoTag(element)
    }
    size += dataSizeRepeatedInt64
    size += 2 * Int32(repeatedInt64.count)
    var dataSizeRepeatedFloat:Int32 = 0
    dataSizeRepeatedFloat = 4 * Int32(repeatedFloat.count)
    size += dataSizeRepeatedFloat
    size += 3 * Int32(repeatedFloat.count)
    var dataSizeRepeatedUint64:Int32 = 0
    for element in repeatedUint64 {
        dataSizeRepeatedUint64 += WireFormat.computeUInt64SizeNoTag(element)
    }
    size += dataSizeRepeatedUint64
    size += 3 * Int32(repeatedUint64.count)
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestRepeatedScalarDifferentTagSizesBuilder {
    return TestRepeatedScalarDifferentTagSizesBuilder()
  }
  class func builderWithPrototype(prototype:TestRepeatedScalarDifferentTagSizes) -> TestRepeatedScalarDifferentTagSizesBuilder {
    return TestRepeatedScalarDifferentTagSizes.builder().mergeFrom(prototype)
  }
  func builder() -> TestRepeatedScalarDifferentTagSizesBuilder {
    return TestRepeatedScalarDifferentTagSizes.builder()
  }
  func toBuilder() -> TestRepeatedScalarDifferentTagSizesBuilder {
    return TestRepeatedScalarDifferentTagSizes.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    var repeatedFixed32ElementIndex:Int = 0
    for element in repeatedFixed32  {
        output += "\(indent) repeatedFixed32[\(repeatedFixed32ElementIndex)]: \(element)\n"
        repeatedFixed32ElementIndex++
    }
    var repeatedInt32ElementIndex:Int = 0
    for element in repeatedInt32  {
        output += "\(indent) repeatedInt32[\(repeatedInt32ElementIndex)]: \(element)\n"
        repeatedInt32ElementIndex++
    }
    var repeatedFixed64ElementIndex:Int = 0
    for element in repeatedFixed64  {
        output += "\(indent) repeatedFixed64[\(repeatedFixed64ElementIndex)]: \(element)\n"
        repeatedFixed64ElementIndex++
    }
    var repeatedInt64ElementIndex:Int = 0
    for element in repeatedInt64  {
        output += "\(indent) repeatedInt64[\(repeatedInt64ElementIndex)]: \(element)\n"
        repeatedInt64ElementIndex++
    }
    var repeatedFloatElementIndex:Int = 0
    for element in repeatedFloat  {
        output += "\(indent) repeatedFloat[\(repeatedFloatElementIndex)]: \(element)\n"
        repeatedFloatElementIndex++
    }
    var repeatedUint64ElementIndex:Int = 0
    for element in repeatedUint64  {
        output += "\(indent) repeatedUint64[\(repeatedUint64ElementIndex)]: \(element)\n"
        repeatedUint64ElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for element in repeatedFixed32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedInt32 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedFixed64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedInt64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedFloat {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          for element in repeatedUint64 {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestRepeatedScalarDifferentTagSizes"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestRepeatedScalarDifferentTagSizes.self
  }


  //Meta information declaration end

}

final class TestRepeatedScalarDifferentTagSizesBuilder : GeneratedMessageBuilder {
  private var builderResult:TestRepeatedScalarDifferentTagSizes

  required override init () {
     builderResult = TestRepeatedScalarDifferentTagSizes()
     super.init()
  }
  var repeatedFixed32:Array<UInt32> {
       get {
           return builderResult.repeatedFixed32
       }
       set (array) {
           builderResult.repeatedFixed32 = array
       }
  }
  func clearRepeatedFixed32() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedFixed32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedInt32:Array<Int32> {
       get {
           return builderResult.repeatedInt32
       }
       set (array) {
           builderResult.repeatedInt32 = array
       }
  }
  func clearRepeatedInt32() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedInt32.removeAll(keepCapacity: false)
     return self
  }
  var repeatedFixed64:Array<UInt64> {
       get {
           return builderResult.repeatedFixed64
       }
       set (array) {
           builderResult.repeatedFixed64 = array
       }
  }
  func clearRepeatedFixed64() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedFixed64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedInt64:Array<Int64> {
       get {
           return builderResult.repeatedInt64
       }
       set (array) {
           builderResult.repeatedInt64 = array
       }
  }
  func clearRepeatedInt64() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedInt64.removeAll(keepCapacity: false)
     return self
  }
  var repeatedFloat:Array<Float> {
       get {
           return builderResult.repeatedFloat
       }
       set (array) {
           builderResult.repeatedFloat = array
       }
  }
  func clearRepeatedFloat() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedFloat.removeAll(keepCapacity: false)
     return self
  }
  var repeatedUint64:Array<UInt64> {
       get {
           return builderResult.repeatedUint64
       }
       set (array) {
           builderResult.repeatedUint64 = array
       }
  }
  func clearRepeatedUint64() -> TestRepeatedScalarDifferentTagSizesBuilder {
     builderResult.repeatedUint64.removeAll(keepCapacity: false)
     return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestRepeatedScalarDifferentTagSizesBuilder {
    builderResult = TestRepeatedScalarDifferentTagSizes()
    return self
  }
  override func clone() -> TestRepeatedScalarDifferentTagSizesBuilder {
    return TestRepeatedScalarDifferentTagSizes.builderWithPrototype(builderResult)
  }
  override func build() -> TestRepeatedScalarDifferentTagSizes {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestRepeatedScalarDifferentTagSizes {
    var returnMe:TestRepeatedScalarDifferentTagSizes = builderResult
    return returnMe
  }
  func mergeFrom(other:TestRepeatedScalarDifferentTagSizes) -> TestRepeatedScalarDifferentTagSizesBuilder {
    if (other == TestRepeatedScalarDifferentTagSizes()) {
     return self
    }
    if !other.repeatedFixed32.isEmpty {
        builderResult.repeatedFixed32 += other.repeatedFixed32
    }
    if !other.repeatedInt32.isEmpty {
        builderResult.repeatedInt32 += other.repeatedInt32
    }
    if !other.repeatedFixed64.isEmpty {
        builderResult.repeatedFixed64 += other.repeatedFixed64
    }
    if !other.repeatedInt64.isEmpty {
        builderResult.repeatedInt64 += other.repeatedInt64
    }
    if !other.repeatedFloat.isEmpty {
        builderResult.repeatedFloat += other.repeatedFloat
    }
    if !other.repeatedUint64.isEmpty {
        builderResult.repeatedUint64 += other.repeatedUint64
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRepeatedScalarDifferentTagSizesBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRepeatedScalarDifferentTagSizesBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 101 :
        repeatedFixed32 += [input.readFixed32()]

      case 104 :
        repeatedInt32 += [input.readInt32()]

      case 16369 :
        repeatedFixed64 += [input.readFixed64()]

      case 16376 :
        repeatedInt64 += [input.readInt64()]

      case 2097141 :
        repeatedFloat += [input.readFloat()]

      case 2097144 :
        repeatedUint64 += [input.readUInt64()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestParsingMerge : ExtendableMessage {


  //Nested type declaration start

    final public class RepeatedFieldsGenerator : GeneratedMessage {


      //Nested type declaration start

        final public class Group1 : GeneratedMessage {
          private(set) var hasField1:Bool = false
          private(set) var field1:TestAllTypes = TestAllTypes()
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasField1 {
              output.writeMessage(11, value:field1)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasField1 {
              size += WireFormat.computeMessageSize(11, value:field1)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          class func parseFromData(data:[Byte]) -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromData(data).build()
          }
          class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromInputStream(input).build()
          }
          class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromCodedInputStream(input).build()
          }
          class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          class func builder() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1Builder()
          }
          class func builderWithPrototype(prototype:TestParsingMerge.RepeatedFieldsGenerator.Group1) -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder().mergeFrom(prototype)
          }
          func builder() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builder()
          }
          func toBuilder() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builderWithPrototype(self)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasField1 {
              output += "\(indent) field1 {\n"
              field1.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasField1 {
                    hashCode = (hashCode &* 31) &+ field1.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "TestParsingMerge.RepeatedFieldsGenerator.Group1"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return TestParsingMerge.RepeatedFieldsGenerator.Group1.self
          }


          //Meta information declaration end

        }

        final class Group1Builder : GeneratedMessageBuilder {
          private var builderResult:TestParsingMerge.RepeatedFieldsGenerator.Group1

          required override init () {
             builderResult = TestParsingMerge.RepeatedFieldsGenerator.Group1()
             super.init()
          }
          var hasField1:Bool {
               get {
                   return builderResult.hasField1
               }
          }
          var field1:TestAllTypes {
               get {
                   return builderResult.field1
               }
               set (value) {
                   builderResult.hasField1 = true
                   builderResult.field1 = value
               }
          }
          func setField1Builder(builderForValue:TestAllTypesBuilder) -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            field1 = builderForValue.build()
            return self
          }
          func mergeField1(value:TestAllTypes) -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            if (builderResult.hasField1 && builderResult.field1 != TestAllTypes()) {
              builderResult.field1 = TestAllTypes.builderWithPrototype(builderResult.field1).mergeFrom(value).buildPartial()
            } else {
              builderResult.field1 = value
            }
            builderResult.hasField1 = true
            return self
          }
          func clearField1() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            builderResult.hasField1 = false
            builderResult.field1 = TestAllTypes()
            return self
          }
          override var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override func clear() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            builderResult = TestParsingMerge.RepeatedFieldsGenerator.Group1()
            return self
          }
          override func clone() -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group1.builderWithPrototype(builderResult)
          }
          override func build() -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
               checkInitialized()
               return buildPartial()
          }
          func buildPartial() -> TestParsingMerge.RepeatedFieldsGenerator.Group1 {
            var returnMe:TestParsingMerge.RepeatedFieldsGenerator.Group1 = builderResult
            return returnMe
          }
          func mergeFrom(other:TestParsingMerge.RepeatedFieldsGenerator.Group1) -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            if (other == TestParsingMerge.RepeatedFieldsGenerator.Group1()) {
             return self
            }
            if (other.hasField1) {
                mergeField1(other.field1)
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group1Builder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 90 :
                var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
                if hasField1 {
                  subBuilder.mergeFrom(field1)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                field1 = subBuilder.buildPartial()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end



      //Nested type declaration start

        final public class Group2 : GeneratedMessage {
          private(set) var hasField1:Bool = false
          private(set) var field1:TestAllTypes = TestAllTypes()
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasField1 {
              output.writeMessage(21, value:field1)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasField1 {
              size += WireFormat.computeMessageSize(21, value:field1)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          class func parseFromData(data:[Byte]) -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromData(data).build()
          }
          class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromInputStream(input).build()
          }
          class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromCodedInputStream(input).build()
          }
          class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          class func builder() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2Builder()
          }
          class func builderWithPrototype(prototype:TestParsingMerge.RepeatedFieldsGenerator.Group2) -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder().mergeFrom(prototype)
          }
          func builder() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builder()
          }
          func toBuilder() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builderWithPrototype(self)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasField1 {
              output += "\(indent) field1 {\n"
              field1.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasField1 {
                    hashCode = (hashCode &* 31) &+ field1.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "TestParsingMerge.RepeatedFieldsGenerator.Group2"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return TestParsingMerge.RepeatedFieldsGenerator.Group2.self
          }


          //Meta information declaration end

        }

        final class Group2Builder : GeneratedMessageBuilder {
          private var builderResult:TestParsingMerge.RepeatedFieldsGenerator.Group2

          required override init () {
             builderResult = TestParsingMerge.RepeatedFieldsGenerator.Group2()
             super.init()
          }
          var hasField1:Bool {
               get {
                   return builderResult.hasField1
               }
          }
          var field1:TestAllTypes {
               get {
                   return builderResult.field1
               }
               set (value) {
                   builderResult.hasField1 = true
                   builderResult.field1 = value
               }
          }
          func setField1Builder(builderForValue:TestAllTypesBuilder) -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            field1 = builderForValue.build()
            return self
          }
          func mergeField1(value:TestAllTypes) -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            if (builderResult.hasField1 && builderResult.field1 != TestAllTypes()) {
              builderResult.field1 = TestAllTypes.builderWithPrototype(builderResult.field1).mergeFrom(value).buildPartial()
            } else {
              builderResult.field1 = value
            }
            builderResult.hasField1 = true
            return self
          }
          func clearField1() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            builderResult.hasField1 = false
            builderResult.field1 = TestAllTypes()
            return self
          }
          override var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override func clear() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            builderResult = TestParsingMerge.RepeatedFieldsGenerator.Group2()
            return self
          }
          override func clone() -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            return TestParsingMerge.RepeatedFieldsGenerator.Group2.builderWithPrototype(builderResult)
          }
          override func build() -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
               checkInitialized()
               return buildPartial()
          }
          func buildPartial() -> TestParsingMerge.RepeatedFieldsGenerator.Group2 {
            var returnMe:TestParsingMerge.RepeatedFieldsGenerator.Group2 = builderResult
            return returnMe
          }
          func mergeFrom(other:TestParsingMerge.RepeatedFieldsGenerator.Group2) -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            if (other == TestParsingMerge.RepeatedFieldsGenerator.Group2()) {
             return self
            }
            if (other.hasField1) {
                mergeField1(other.field1)
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator.Group2Builder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 170 :
                var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
                if hasField1 {
                  subBuilder.mergeFrom(field1)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                field1 = subBuilder.buildPartial()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end

      private(set) var field1:Array<TestAllTypes>  = Array<TestAllTypes>()
      private(set) var field2:Array<TestAllTypes>  = Array<TestAllTypes>()
      private(set) var field3:Array<TestAllTypes>  = Array<TestAllTypes>()
      private(set) var group1:Array<TestParsingMerge.RepeatedFieldsGenerator.Group1>  = Array<TestParsingMerge.RepeatedFieldsGenerator.Group1>()
      private(set) var group2:Array<TestParsingMerge.RepeatedFieldsGenerator.Group2>  = Array<TestParsingMerge.RepeatedFieldsGenerator.Group2>()
      private(set) var ext1:Array<TestAllTypes>  = Array<TestAllTypes>()
      private(set) var ext2:Array<TestAllTypes>  = Array<TestAllTypes>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        for element in field1 {
            output.writeMessage(1, value:element)
        }
        for element in field2 {
            output.writeMessage(2, value:element)
        }
        for element in field3 {
            output.writeMessage(3, value:element)
        }
        for element in group1 {
            output.writeGroup(10, value:element)
        }
        for element in group2 {
            output.writeGroup(20, value:element)
        }
        for element in ext1 {
            output.writeMessage(1000, value:element)
        }
        for element in ext2 {
            output.writeMessage(1001, value:element)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        for element in field1 {
            size += WireFormat.computeMessageSize(1, value:element)
        }
        for element in field2 {
            size += WireFormat.computeMessageSize(2, value:element)
        }
        for element in field3 {
            size += WireFormat.computeMessageSize(3, value:element)
        }
        for element in group1 {
            size += WireFormat.computeGroupSize(10, value:element)
        }
        for element in group2 {
            size += WireFormat.computeGroupSize(20, value:element)
        }
        for element in ext1 {
            size += WireFormat.computeMessageSize(1000, value:element)
        }
        for element in ext2 {
            size += WireFormat.computeMessageSize(1001, value:element)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        return TestParsingMerge.RepeatedFieldsGeneratorBuilder()
      }
      class func builderWithPrototype(prototype:TestParsingMerge.RepeatedFieldsGenerator) -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFrom(prototype)
      }
      func builder() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        return TestParsingMerge.RepeatedFieldsGenerator.builder()
      }
      func toBuilder() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        return TestParsingMerge.RepeatedFieldsGenerator.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        var field1ElementIndex:Int = 0
        for element in field1 {
            output += "\(indent) field1[\(field1ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            field1ElementIndex++
        }
        var field2ElementIndex:Int = 0
        for element in field2 {
            output += "\(indent) field2[\(field2ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            field2ElementIndex++
        }
        var field3ElementIndex:Int = 0
        for element in field3 {
            output += "\(indent) field3[\(field3ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            field3ElementIndex++
        }
        var group1ElementIndex:Int = 0
        for element in group1 {
            output += "\(indent) group1[\(group1ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            group1ElementIndex++
        }
        var group2ElementIndex:Int = 0
        for element in group2 {
            output += "\(indent) group2[\(group2ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            group2ElementIndex++
        }
        var ext1ElementIndex:Int = 0
        for element in ext1 {
            output += "\(indent) ext1[\(ext1ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            ext1ElementIndex++
        }
        var ext2ElementIndex:Int = 0
        for element in ext2 {
            output += "\(indent) ext2[\(ext2ElementIndex)] {\n"
            element.writeDescriptionTo(&output, indent:"\(indent)  ")
            output += "\(indent)}\n"
            ext2ElementIndex++
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for element in field1 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in field2 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in field3 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in group1 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in group2 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in ext1 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              for element in ext2 {
                  hashCode = (hashCode &* 31) &+ element.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestParsingMerge.RepeatedFieldsGenerator"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestParsingMerge.RepeatedFieldsGenerator.self
      }


      //Meta information declaration end

    }

    final class RepeatedFieldsGeneratorBuilder : GeneratedMessageBuilder {
      private var builderResult:TestParsingMerge.RepeatedFieldsGenerator

      required override init () {
         builderResult = TestParsingMerge.RepeatedFieldsGenerator()
         super.init()
      }
      var field1:Array<TestAllTypes> {
           get {
               return builderResult.field1
           }
           set (value) {
               builderResult.field1 = value
           }
      }
      func clearField1() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.field1.removeAll(keepCapacity: false)
        return self
      }
      var field2:Array<TestAllTypes> {
           get {
               return builderResult.field2
           }
           set (value) {
               builderResult.field2 = value
           }
      }
      func clearField2() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.field2.removeAll(keepCapacity: false)
        return self
      }
      var field3:Array<TestAllTypes> {
           get {
               return builderResult.field3
           }
           set (value) {
               builderResult.field3 = value
           }
      }
      func clearField3() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.field3.removeAll(keepCapacity: false)
        return self
      }
      var group1:Array<TestParsingMerge.RepeatedFieldsGenerator.Group1> {
           get {
               return builderResult.group1
           }
           set (value) {
               builderResult.group1 = value
           }
      }
      func clearGroup1() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.group1.removeAll(keepCapacity: false)
        return self
      }
      var group2:Array<TestParsingMerge.RepeatedFieldsGenerator.Group2> {
           get {
               return builderResult.group2
           }
           set (value) {
               builderResult.group2 = value
           }
      }
      func clearGroup2() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.group2.removeAll(keepCapacity: false)
        return self
      }
      var ext1:Array<TestAllTypes> {
           get {
               return builderResult.ext1
           }
           set (value) {
               builderResult.ext1 = value
           }
      }
      func clearExt1() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.ext1.removeAll(keepCapacity: false)
        return self
      }
      var ext2:Array<TestAllTypes> {
           get {
               return builderResult.ext2
           }
           set (value) {
               builderResult.ext2 = value
           }
      }
      func clearExt2() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult.ext2.removeAll(keepCapacity: false)
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        builderResult = TestParsingMerge.RepeatedFieldsGenerator()
        return self
      }
      override func clone() -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        return TestParsingMerge.RepeatedFieldsGenerator.builderWithPrototype(builderResult)
      }
      override func build() -> TestParsingMerge.RepeatedFieldsGenerator {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestParsingMerge.RepeatedFieldsGenerator {
        var returnMe:TestParsingMerge.RepeatedFieldsGenerator = builderResult
        return returnMe
      }
      func mergeFrom(other:TestParsingMerge.RepeatedFieldsGenerator) -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        if (other == TestParsingMerge.RepeatedFieldsGenerator()) {
         return self
        }
        if !other.field1.isEmpty  {
           builderResult.field1 += other.field1
        }
        if !other.field2.isEmpty  {
           builderResult.field2 += other.field2
        }
        if !other.field3.isEmpty  {
           builderResult.field3 += other.field3
        }
        if !other.group1.isEmpty  {
           builderResult.group1 += other.group1
        }
        if !other.group2.isEmpty  {
           builderResult.group2 += other.group2
        }
        if !other.ext1.isEmpty  {
           builderResult.ext1 += other.ext1
        }
        if !other.ext2.isEmpty  {
           builderResult.ext2 += other.ext2
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMerge.RepeatedFieldsGeneratorBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGeneratorBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 10 :
            var subBuilder = TestAllTypes.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            field1 += [subBuilder.buildPartial()]

          case 18 :
            var subBuilder = TestAllTypes.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            field2 += [subBuilder.buildPartial()]

          case 26 :
            var subBuilder = TestAllTypes.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            field3 += [subBuilder.buildPartial()]

          case 83 :
            var subBuilder = TestParsingMerge.RepeatedFieldsGenerator.Group1.builder()
            input.readGroup(10,builder:subBuilder,extensionRegistry:extensionRegistry)
            group1 += [subBuilder.buildPartial()]

          case 163 :
            var subBuilder = TestParsingMerge.RepeatedFieldsGenerator.Group2.builder()
            input.readGroup(20,builder:subBuilder,extensionRegistry:extensionRegistry)
            group2 += [subBuilder.buildPartial()]

          case 8002 :
            var subBuilder = TestAllTypes.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            ext1 += [subBuilder.buildPartial()]

          case 8010 :
            var subBuilder = TestAllTypes.builder()
            input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            ext2 += [subBuilder.buildPartial()]

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class OptionalGroup : GeneratedMessage {
      private(set) var hasOptionalGroupAllTypes:Bool = false
      private(set) var optionalGroupAllTypes:TestAllTypes = TestAllTypes()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasOptionalGroupAllTypes {
          output.writeMessage(11, value:optionalGroupAllTypes)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasOptionalGroupAllTypes {
          size += WireFormat.computeMessageSize(11, value:optionalGroupAllTypes)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.OptionalGroup {
        return TestParsingMerge.OptionalGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestParsingMerge.OptionalGroupBuilder {
        return TestParsingMerge.OptionalGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestParsingMerge.OptionalGroup) -> TestParsingMerge.OptionalGroupBuilder {
        return TestParsingMerge.OptionalGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestParsingMerge.OptionalGroupBuilder {
        return TestParsingMerge.OptionalGroup.builder()
      }
      func toBuilder() -> TestParsingMerge.OptionalGroupBuilder {
        return TestParsingMerge.OptionalGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasOptionalGroupAllTypes {
          output += "\(indent) optionalGroupAllTypes {\n"
          optionalGroupAllTypes.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent) }\n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasOptionalGroupAllTypes {
                hashCode = (hashCode &* 31) &+ optionalGroupAllTypes.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestParsingMerge.OptionalGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestParsingMerge.OptionalGroup.self
      }


      //Meta information declaration end

    }

    final class OptionalGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestParsingMerge.OptionalGroup

      required override init () {
         builderResult = TestParsingMerge.OptionalGroup()
         super.init()
      }
      var hasOptionalGroupAllTypes:Bool {
           get {
               return builderResult.hasOptionalGroupAllTypes
           }
      }
      var optionalGroupAllTypes:TestAllTypes {
           get {
               return builderResult.optionalGroupAllTypes
           }
           set (value) {
               builderResult.hasOptionalGroupAllTypes = true
               builderResult.optionalGroupAllTypes = value
           }
      }
      func setOptionalGroupAllTypesBuilder(builderForValue:TestAllTypesBuilder) -> TestParsingMerge.OptionalGroupBuilder {
        optionalGroupAllTypes = builderForValue.build()
        return self
      }
      func mergeOptionalGroupAllTypes(value:TestAllTypes) -> TestParsingMerge.OptionalGroupBuilder {
        if (builderResult.hasOptionalGroupAllTypes && builderResult.optionalGroupAllTypes != TestAllTypes()) {
          builderResult.optionalGroupAllTypes = TestAllTypes.builderWithPrototype(builderResult.optionalGroupAllTypes).mergeFrom(value).buildPartial()
        } else {
          builderResult.optionalGroupAllTypes = value
        }
        builderResult.hasOptionalGroupAllTypes = true
        return self
      }
      func clearOptionalGroupAllTypes() -> TestParsingMerge.OptionalGroupBuilder {
        builderResult.hasOptionalGroupAllTypes = false
        builderResult.optionalGroupAllTypes = TestAllTypes()
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestParsingMerge.OptionalGroupBuilder {
        builderResult = TestParsingMerge.OptionalGroup()
        return self
      }
      override func clone() -> TestParsingMerge.OptionalGroupBuilder {
        return TestParsingMerge.OptionalGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestParsingMerge.OptionalGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestParsingMerge.OptionalGroup {
        var returnMe:TestParsingMerge.OptionalGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestParsingMerge.OptionalGroup) -> TestParsingMerge.OptionalGroupBuilder {
        if (other == TestParsingMerge.OptionalGroup()) {
         return self
        }
        if (other.hasOptionalGroupAllTypes) {
            mergeOptionalGroupAllTypes(other.optionalGroupAllTypes)
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMerge.OptionalGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.OptionalGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 90 :
            var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
            if hasOptionalGroupAllTypes {
              subBuilder.mergeFrom(optionalGroupAllTypes)
            }
            input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            optionalGroupAllTypes = subBuilder.buildPartial()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class RepeatedGroup : GeneratedMessage {
      private(set) var hasRepeatedGroupAllTypes:Bool = false
      private(set) var repeatedGroupAllTypes:TestAllTypes = TestAllTypes()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasRepeatedGroupAllTypes {
          output.writeMessage(21, value:repeatedGroupAllTypes)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasRepeatedGroupAllTypes {
          size += WireFormat.computeMessageSize(21, value:repeatedGroupAllTypes)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedGroup {
        return TestParsingMerge.RepeatedGroup.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestParsingMerge.RepeatedGroupBuilder {
        return TestParsingMerge.RepeatedGroupBuilder()
      }
      class func builderWithPrototype(prototype:TestParsingMerge.RepeatedGroup) -> TestParsingMerge.RepeatedGroupBuilder {
        return TestParsingMerge.RepeatedGroup.builder().mergeFrom(prototype)
      }
      func builder() -> TestParsingMerge.RepeatedGroupBuilder {
        return TestParsingMerge.RepeatedGroup.builder()
      }
      func toBuilder() -> TestParsingMerge.RepeatedGroupBuilder {
        return TestParsingMerge.RepeatedGroup.builderWithPrototype(self)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasRepeatedGroupAllTypes {
          output += "\(indent) repeatedGroupAllTypes {\n"
          repeatedGroupAllTypes.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent) }\n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasRepeatedGroupAllTypes {
                hashCode = (hashCode &* 31) &+ repeatedGroupAllTypes.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "TestParsingMerge.RepeatedGroup"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return TestParsingMerge.RepeatedGroup.self
      }


      //Meta information declaration end

    }

    final class RepeatedGroupBuilder : GeneratedMessageBuilder {
      private var builderResult:TestParsingMerge.RepeatedGroup

      required override init () {
         builderResult = TestParsingMerge.RepeatedGroup()
         super.init()
      }
      var hasRepeatedGroupAllTypes:Bool {
           get {
               return builderResult.hasRepeatedGroupAllTypes
           }
      }
      var repeatedGroupAllTypes:TestAllTypes {
           get {
               return builderResult.repeatedGroupAllTypes
           }
           set (value) {
               builderResult.hasRepeatedGroupAllTypes = true
               builderResult.repeatedGroupAllTypes = value
           }
      }
      func setRepeatedGroupAllTypesBuilder(builderForValue:TestAllTypesBuilder) -> TestParsingMerge.RepeatedGroupBuilder {
        repeatedGroupAllTypes = builderForValue.build()
        return self
      }
      func mergeRepeatedGroupAllTypes(value:TestAllTypes) -> TestParsingMerge.RepeatedGroupBuilder {
        if (builderResult.hasRepeatedGroupAllTypes && builderResult.repeatedGroupAllTypes != TestAllTypes()) {
          builderResult.repeatedGroupAllTypes = TestAllTypes.builderWithPrototype(builderResult.repeatedGroupAllTypes).mergeFrom(value).buildPartial()
        } else {
          builderResult.repeatedGroupAllTypes = value
        }
        builderResult.hasRepeatedGroupAllTypes = true
        return self
      }
      func clearRepeatedGroupAllTypes() -> TestParsingMerge.RepeatedGroupBuilder {
        builderResult.hasRepeatedGroupAllTypes = false
        builderResult.repeatedGroupAllTypes = TestAllTypes()
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override func clear() -> TestParsingMerge.RepeatedGroupBuilder {
        builderResult = TestParsingMerge.RepeatedGroup()
        return self
      }
      override func clone() -> TestParsingMerge.RepeatedGroupBuilder {
        return TestParsingMerge.RepeatedGroup.builderWithPrototype(builderResult)
      }
      override func build() -> TestParsingMerge.RepeatedGroup {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestParsingMerge.RepeatedGroup {
        var returnMe:TestParsingMerge.RepeatedGroup = builderResult
        return returnMe
      }
      func mergeFrom(other:TestParsingMerge.RepeatedGroup) -> TestParsingMerge.RepeatedGroupBuilder {
        if (other == TestParsingMerge.RepeatedGroup()) {
         return self
        }
        if (other.hasRepeatedGroupAllTypes) {
            mergeRepeatedGroupAllTypes(other.repeatedGroupAllTypes)
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMerge.RepeatedGroupBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedGroupBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 170 :
            var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
            if hasRepeatedGroupAllTypes {
              subBuilder.mergeFrom(repeatedGroupAllTypes)
            }
            input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            repeatedGroupAllTypes = subBuilder.buildPartial()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  private(set) var hasRequiredAllTypes:Bool = false
  private(set) var requiredAllTypes:TestAllTypes = TestAllTypes()
  private(set) var hasOptionalAllTypes:Bool = false
  private(set) var optionalAllTypes:TestAllTypes = TestAllTypes()
  private(set) var hasOptionalGroup:Bool = false
  private(set) var optionalGroup:TestParsingMerge.OptionalGroup = TestParsingMerge.OptionalGroup()
  class func optionalExt() -> ConcreateExtensionField {
       return TestParsingMergeoptionalExt
  }
  class func repeatedExt() -> ConcreateExtensionField {
       return TestParsingMergerepeatedExt
  }
  private(set) var repeatedAllTypes:Array<TestAllTypes>  = Array<TestAllTypes>()
  private(set) var repeatedGroup:Array<TestParsingMerge.RepeatedGroup>  = Array<TestParsingMerge.RepeatedGroup>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasRequiredAllTypes {
      return false
    }
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasRequiredAllTypes {
      output.writeMessage(1, value:requiredAllTypes)
    }
    if hasOptionalAllTypes {
      output.writeMessage(2, value:optionalAllTypes)
    }
    for element in repeatedAllTypes {
        output.writeMessage(3, value:element)
    }
    if hasOptionalGroup {
      output.writeGroup(10, value:optionalGroup)
    }
    for element in repeatedGroup {
        output.writeGroup(20, value:element)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasRequiredAllTypes {
      size += WireFormat.computeMessageSize(1, value:requiredAllTypes)
    }
    if hasOptionalAllTypes {
      size += WireFormat.computeMessageSize(2, value:optionalAllTypes)
    }
    for element in repeatedAllTypes {
        size += WireFormat.computeMessageSize(3, value:element)
    }
    if hasOptionalGroup {
      size += WireFormat.computeGroupSize(10, value:optionalGroup)
    }
    for element in repeatedGroup {
        size += WireFormat.computeGroupSize(20, value:element)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestParsingMerge {
    return TestParsingMerge.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestParsingMerge {
    return TestParsingMerge.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestParsingMerge {
    return TestParsingMerge.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestParsingMerge {
    return TestParsingMerge.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestParsingMerge {
    return TestParsingMerge.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMerge {
    return TestParsingMerge.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestParsingMergeBuilder {
    return TestParsingMergeBuilder()
  }
  class func builderWithPrototype(prototype:TestParsingMerge) -> TestParsingMergeBuilder {
    return TestParsingMerge.builder().mergeFrom(prototype)
  }
  func builder() -> TestParsingMergeBuilder {
    return TestParsingMerge.builder()
  }
  func toBuilder() -> TestParsingMergeBuilder {
    return TestParsingMerge.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasRequiredAllTypes {
      output += "\(indent) requiredAllTypes {\n"
      requiredAllTypes.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasOptionalAllTypes {
      output += "\(indent) optionalAllTypes {\n"
      optionalAllTypes.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var repeatedAllTypesElementIndex:Int = 0
    for element in repeatedAllTypes {
        output += "\(indent) repeatedAllTypes[\(repeatedAllTypesElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedAllTypesElementIndex++
    }
    if hasOptionalGroup {
      output += "\(indent) optionalGroup {\n"
      optionalGroup.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var repeatedGroupElementIndex:Int = 0
    for element in repeatedGroup {
        output += "\(indent) repeatedGroup[\(repeatedGroupElementIndex)] {\n"
        element.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        repeatedGroupElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequiredAllTypes {
            hashCode = (hashCode &* 31) &+ requiredAllTypes.hashValue
          }
          if hasOptionalAllTypes {
            hashCode = (hashCode &* 31) &+ optionalAllTypes.hashValue
          }
          for element in repeatedAllTypes {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          if hasOptionalGroup {
            hashCode = (hashCode &* 31) &+ optionalGroup.hashValue
          }
          for element in repeatedGroup {
              hashCode = (hashCode &* 31) &+ element.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestParsingMerge"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestParsingMerge.self
  }


  //Meta information declaration end

}

final class TestParsingMergeBuilder : ExtendableMessageBuilder {
  private var builderResult:TestParsingMerge

  required override init () {
     builderResult = TestParsingMerge()
     super.init()
  }
  var hasRequiredAllTypes:Bool {
       get {
           return builderResult.hasRequiredAllTypes
       }
  }
  var requiredAllTypes:TestAllTypes {
       get {
           return builderResult.requiredAllTypes
       }
       set (value) {
           builderResult.hasRequiredAllTypes = true
           builderResult.requiredAllTypes = value
       }
  }
  func setRequiredAllTypesBuilder(builderForValue:TestAllTypesBuilder) -> TestParsingMergeBuilder {
    requiredAllTypes = builderForValue.build()
    return self
  }
  func mergeRequiredAllTypes(value:TestAllTypes) -> TestParsingMergeBuilder {
    if (builderResult.hasRequiredAllTypes && builderResult.requiredAllTypes != TestAllTypes()) {
      builderResult.requiredAllTypes = TestAllTypes.builderWithPrototype(builderResult.requiredAllTypes).mergeFrom(value).buildPartial()
    } else {
      builderResult.requiredAllTypes = value
    }
    builderResult.hasRequiredAllTypes = true
    return self
  }
  func clearRequiredAllTypes() -> TestParsingMergeBuilder {
    builderResult.hasRequiredAllTypes = false
    builderResult.requiredAllTypes = TestAllTypes()
    return self
  }
  var hasOptionalAllTypes:Bool {
       get {
           return builderResult.hasOptionalAllTypes
       }
  }
  var optionalAllTypes:TestAllTypes {
       get {
           return builderResult.optionalAllTypes
       }
       set (value) {
           builderResult.hasOptionalAllTypes = true
           builderResult.optionalAllTypes = value
       }
  }
  func setOptionalAllTypesBuilder(builderForValue:TestAllTypesBuilder) -> TestParsingMergeBuilder {
    optionalAllTypes = builderForValue.build()
    return self
  }
  func mergeOptionalAllTypes(value:TestAllTypes) -> TestParsingMergeBuilder {
    if (builderResult.hasOptionalAllTypes && builderResult.optionalAllTypes != TestAllTypes()) {
      builderResult.optionalAllTypes = TestAllTypes.builderWithPrototype(builderResult.optionalAllTypes).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalAllTypes = value
    }
    builderResult.hasOptionalAllTypes = true
    return self
  }
  func clearOptionalAllTypes() -> TestParsingMergeBuilder {
    builderResult.hasOptionalAllTypes = false
    builderResult.optionalAllTypes = TestAllTypes()
    return self
  }
  var repeatedAllTypes:Array<TestAllTypes> {
       get {
           return builderResult.repeatedAllTypes
       }
       set (value) {
           builderResult.repeatedAllTypes = value
       }
  }
  func clearRepeatedAllTypes() -> TestParsingMergeBuilder {
    builderResult.repeatedAllTypes.removeAll(keepCapacity: false)
    return self
  }
  var hasOptionalGroup:Bool {
       get {
           return builderResult.hasOptionalGroup
       }
  }
  var optionalGroup:TestParsingMerge.OptionalGroup {
       get {
           return builderResult.optionalGroup
       }
       set (value) {
           builderResult.hasOptionalGroup = true
           builderResult.optionalGroup = value
       }
  }
  func setOptionalGroupBuilder(builderForValue:TestParsingMerge.OptionalGroupBuilder) -> TestParsingMergeBuilder {
    optionalGroup = builderForValue.build()
    return self
  }
  func mergeOptionalGroup(value:TestParsingMerge.OptionalGroup) -> TestParsingMergeBuilder {
    if (builderResult.hasOptionalGroup && builderResult.optionalGroup != TestParsingMerge.OptionalGroup()) {
      builderResult.optionalGroup = TestParsingMerge.OptionalGroup.builderWithPrototype(builderResult.optionalGroup).mergeFrom(value).buildPartial()
    } else {
      builderResult.optionalGroup = value
    }
    builderResult.hasOptionalGroup = true
    return self
  }
  func clearOptionalGroup() -> TestParsingMergeBuilder {
    builderResult.hasOptionalGroup = false
    builderResult.optionalGroup = TestParsingMerge.OptionalGroup()
    return self
  }
  var repeatedGroup:Array<TestParsingMerge.RepeatedGroup> {
       get {
           return builderResult.repeatedGroup
       }
       set (value) {
           builderResult.repeatedGroup = value
       }
  }
  func clearRepeatedGroup() -> TestParsingMergeBuilder {
    builderResult.repeatedGroup.removeAll(keepCapacity: false)
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  override func clear() -> TestParsingMergeBuilder {
    builderResult = TestParsingMerge()
    return self
  }
  override func clone() -> TestParsingMergeBuilder {
    return TestParsingMerge.builderWithPrototype(builderResult)
  }
  override func build() -> TestParsingMerge {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestParsingMerge {
    var returnMe:TestParsingMerge = builderResult
    return returnMe
  }
  func mergeFrom(other:TestParsingMerge) -> TestParsingMergeBuilder {
    if (other == TestParsingMerge()) {
     return self
    }
    if (other.hasRequiredAllTypes) {
        mergeRequiredAllTypes(other.requiredAllTypes)
    }
    if (other.hasOptionalAllTypes) {
        mergeOptionalAllTypes(other.optionalAllTypes)
    }
    if !other.repeatedAllTypes.isEmpty  {
       builderResult.repeatedAllTypes += other.repeatedAllTypes
    }
    if (other.hasOptionalGroup) {
        mergeOptionalGroup(other.optionalGroup)
    }
    if !other.repeatedGroup.isEmpty  {
       builderResult.repeatedGroup += other.repeatedGroup
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestParsingMergeBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestParsingMergeBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasRequiredAllTypes {
          subBuilder.mergeFrom(requiredAllTypes)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        requiredAllTypes = subBuilder.buildPartial()

      case 18 :
        var subBuilder:TestAllTypesBuilder = TestAllTypes.builder()
        if hasOptionalAllTypes {
          subBuilder.mergeFrom(optionalAllTypes)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        optionalAllTypes = subBuilder.buildPartial()

      case 26 :
        var subBuilder = TestAllTypes.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        repeatedAllTypes += [subBuilder.buildPartial()]

      case 83 :
        var subBuilder:TestParsingMerge.OptionalGroupBuilder = TestParsingMerge.OptionalGroup.builder()
        if hasOptionalGroup {
          subBuilder.mergeFrom(optionalGroup)
        }
        input.readGroup(10, builder:subBuilder, extensionRegistry:extensionRegistry)
        optionalGroup = subBuilder.buildPartial()

      case 163 :
        var subBuilder = TestParsingMerge.RepeatedGroup.builder()
        input.readGroup(20,builder:subBuilder,extensionRegistry:extensionRegistry)
        repeatedGroup += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class TestCommentInjectionMessage : GeneratedMessage {
  private(set) var hasA:Bool = false
  private(set) var a:String = "*/ <- Neither should this."

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasA {
      output.writeString(1, value:a)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasA {
      size += WireFormat.computeStringSize(1, value:a)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestCommentInjectionMessage {
    return TestCommentInjectionMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestCommentInjectionMessageBuilder {
    return TestCommentInjectionMessageBuilder()
  }
  class func builderWithPrototype(prototype:TestCommentInjectionMessage) -> TestCommentInjectionMessageBuilder {
    return TestCommentInjectionMessage.builder().mergeFrom(prototype)
  }
  func builder() -> TestCommentInjectionMessageBuilder {
    return TestCommentInjectionMessage.builder()
  }
  func toBuilder() -> TestCommentInjectionMessageBuilder {
    return TestCommentInjectionMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasA {
      output += "\(indent) a: \(a) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasA {
             hashCode = (hashCode &* 31) &+ a.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "TestCommentInjectionMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return TestCommentInjectionMessage.self
  }


  //Meta information declaration end

}

final class TestCommentInjectionMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:TestCommentInjectionMessage

  required override init () {
     builderResult = TestCommentInjectionMessage()
     super.init()
  }
  var hasA:Bool {
       get {
            return builderResult.hasA
       }
  }
  var a:String {
       get {
            return builderResult.a
       }
       set (value) {
           builderResult.hasA = true
           builderResult.a = value
       }
  }
  func clearA() -> TestCommentInjectionMessageBuilder{
       builderResult.hasA = false
       builderResult.a = "*/ <- Neither should this."
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> TestCommentInjectionMessageBuilder {
    builderResult = TestCommentInjectionMessage()
    return self
  }
  override func clone() -> TestCommentInjectionMessageBuilder {
    return TestCommentInjectionMessage.builderWithPrototype(builderResult)
  }
  override func build() -> TestCommentInjectionMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestCommentInjectionMessage {
    var returnMe:TestCommentInjectionMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:TestCommentInjectionMessage) -> TestCommentInjectionMessageBuilder {
    if (other == TestCommentInjectionMessage()) {
     return self
    }
    if other.hasA {
         a = other.a
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestCommentInjectionMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestCommentInjectionMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        a = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FooRequest : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FooRequest {
    return FooRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FooRequest {
    return FooRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FooRequest {
    return FooRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FooRequest {
    return FooRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FooRequest {
    return FooRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooRequest {
    return FooRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FooRequestBuilder {
    return FooRequestBuilder()
  }
  class func builderWithPrototype(prototype:FooRequest) -> FooRequestBuilder {
    return FooRequest.builder().mergeFrom(prototype)
  }
  func builder() -> FooRequestBuilder {
    return FooRequest.builder()
  }
  func toBuilder() -> FooRequestBuilder {
    return FooRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FooRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FooRequest.self
  }


  //Meta information declaration end

}

final class FooRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:FooRequest

  required override init () {
     builderResult = FooRequest()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FooRequestBuilder {
    builderResult = FooRequest()
    return self
  }
  override func clone() -> FooRequestBuilder {
    return FooRequest.builderWithPrototype(builderResult)
  }
  override func build() -> FooRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FooRequest {
    var returnMe:FooRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:FooRequest) -> FooRequestBuilder {
    if (other == FooRequest()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FooRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FooResponse : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FooResponse {
    return FooResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FooResponse {
    return FooResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FooResponse {
    return FooResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FooResponse {
    return FooResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FooResponse {
    return FooResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooResponse {
    return FooResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FooResponseBuilder {
    return FooResponseBuilder()
  }
  class func builderWithPrototype(prototype:FooResponse) -> FooResponseBuilder {
    return FooResponse.builder().mergeFrom(prototype)
  }
  func builder() -> FooResponseBuilder {
    return FooResponse.builder()
  }
  func toBuilder() -> FooResponseBuilder {
    return FooResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FooResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FooResponse.self
  }


  //Meta information declaration end

}

final class FooResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:FooResponse

  required override init () {
     builderResult = FooResponse()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FooResponseBuilder {
    builderResult = FooResponse()
    return self
  }
  override func clone() -> FooResponseBuilder {
    return FooResponse.builderWithPrototype(builderResult)
  }
  override func build() -> FooResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FooResponse {
    var returnMe:FooResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:FooResponse) -> FooResponseBuilder {
    if (other == FooResponse()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FooResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FooClientMessage : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FooClientMessage {
    return FooClientMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FooClientMessage {
    return FooClientMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FooClientMessage {
    return FooClientMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FooClientMessage {
    return FooClientMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FooClientMessage {
    return FooClientMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooClientMessage {
    return FooClientMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FooClientMessageBuilder {
    return FooClientMessageBuilder()
  }
  class func builderWithPrototype(prototype:FooClientMessage) -> FooClientMessageBuilder {
    return FooClientMessage.builder().mergeFrom(prototype)
  }
  func builder() -> FooClientMessageBuilder {
    return FooClientMessage.builder()
  }
  func toBuilder() -> FooClientMessageBuilder {
    return FooClientMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FooClientMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FooClientMessage.self
  }


  //Meta information declaration end

}

final class FooClientMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:FooClientMessage

  required override init () {
     builderResult = FooClientMessage()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FooClientMessageBuilder {
    builderResult = FooClientMessage()
    return self
  }
  override func clone() -> FooClientMessageBuilder {
    return FooClientMessage.builderWithPrototype(builderResult)
  }
  override func build() -> FooClientMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FooClientMessage {
    var returnMe:FooClientMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:FooClientMessage) -> FooClientMessageBuilder {
    if (other == FooClientMessage()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FooClientMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooClientMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class FooServerMessage : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> FooServerMessage {
    return FooServerMessage.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> FooServerMessage {
    return FooServerMessage.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> FooServerMessage {
    return FooServerMessage.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FooServerMessage {
    return FooServerMessage.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> FooServerMessage {
    return FooServerMessage.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooServerMessage {
    return FooServerMessage.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> FooServerMessageBuilder {
    return FooServerMessageBuilder()
  }
  class func builderWithPrototype(prototype:FooServerMessage) -> FooServerMessageBuilder {
    return FooServerMessage.builder().mergeFrom(prototype)
  }
  func builder() -> FooServerMessageBuilder {
    return FooServerMessage.builder()
  }
  func toBuilder() -> FooServerMessageBuilder {
    return FooServerMessage.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "FooServerMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return FooServerMessage.self
  }


  //Meta information declaration end

}

final class FooServerMessageBuilder : GeneratedMessageBuilder {
  private var builderResult:FooServerMessage

  required override init () {
     builderResult = FooServerMessage()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> FooServerMessageBuilder {
    builderResult = FooServerMessage()
    return self
  }
  override func clone() -> FooServerMessageBuilder {
    return FooServerMessage.builderWithPrototype(builderResult)
  }
  override func build() -> FooServerMessage {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> FooServerMessage {
    var returnMe:FooServerMessage = builderResult
    return returnMe
  }
  func mergeFrom(other:FooServerMessage) -> FooServerMessageBuilder {
    if (other == FooServerMessage()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->FooServerMessageBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FooServerMessageBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class BarRequest : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> BarRequest {
    return BarRequest.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> BarRequest {
    return BarRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> BarRequest {
    return BarRequest.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->BarRequest {
    return BarRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> BarRequest {
    return BarRequest.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BarRequest {
    return BarRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> BarRequestBuilder {
    return BarRequestBuilder()
  }
  class func builderWithPrototype(prototype:BarRequest) -> BarRequestBuilder {
    return BarRequest.builder().mergeFrom(prototype)
  }
  func builder() -> BarRequestBuilder {
    return BarRequest.builder()
  }
  func toBuilder() -> BarRequestBuilder {
    return BarRequest.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BarRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BarRequest.self
  }


  //Meta information declaration end

}

final class BarRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:BarRequest

  required override init () {
     builderResult = BarRequest()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> BarRequestBuilder {
    builderResult = BarRequest()
    return self
  }
  override func clone() -> BarRequestBuilder {
    return BarRequest.builderWithPrototype(builderResult)
  }
  override func build() -> BarRequest {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> BarRequest {
    var returnMe:BarRequest = builderResult
    return returnMe
  }
  func mergeFrom(other:BarRequest) -> BarRequestBuilder {
    if (other == BarRequest()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->BarRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BarRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class BarResponse : GeneratedMessage {
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> BarResponse {
    return BarResponse.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> BarResponse {
    return BarResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> BarResponse {
    return BarResponse.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->BarResponse {
    return BarResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> BarResponse {
    return BarResponse.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BarResponse {
    return BarResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> BarResponseBuilder {
    return BarResponseBuilder()
  }
  class func builderWithPrototype(prototype:BarResponse) -> BarResponseBuilder {
    return BarResponse.builder().mergeFrom(prototype)
  }
  func builder() -> BarResponseBuilder {
    return BarResponse.builder()
  }
  func toBuilder() -> BarResponseBuilder {
    return BarResponse.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BarResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return BarResponse.self
  }


  //Meta information declaration end

}

final class BarResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:BarResponse

  required override init () {
     builderResult = BarResponse()
     super.init()
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> BarResponseBuilder {
    builderResult = BarResponse()
    return self
  }
  override func clone() -> BarResponseBuilder {
    return BarResponse.builderWithPrototype(builderResult)
  }
  override func build() -> BarResponse {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> BarResponse {
    var returnMe:BarResponse = builderResult
    return returnMe
  }
  func mergeFrom(other:BarResponse) -> BarResponseBuilder {
    if (other == BarResponse()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->BarResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> BarResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension TestAllTypes.NestedMessage {
    class func parseFromNSData(data:NSData) -> TestAllTypes.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.NestedMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestAllTypes.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.NestedMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestAllTypes.OptionalGroup {
    class func parseFromNSData(data:NSData) -> TestAllTypes.OptionalGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.OptionalGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestAllTypes.OptionalGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.OptionalGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestAllTypes.RepeatedGroup {
    class func parseFromNSData(data:NSData) -> TestAllTypes.RepeatedGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.RepeatedGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestAllTypes.RepeatedGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.RepeatedGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestAllTypes {
    class func parseFromNSData(data:NSData) -> TestAllTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestAllTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllTypes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension NestedTestAllTypes {
    class func parseFromNSData(data:NSData) -> NestedTestAllTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return NestedTestAllTypes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> NestedTestAllTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return NestedTestAllTypes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDeprecatedFields {
    class func parseFromNSData(data:NSData) -> TestDeprecatedFields {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDeprecatedFields.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDeprecatedFields {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDeprecatedFields.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension ForeignMessage {
    class func parseFromNSData(data:NSData) -> ForeignMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ForeignMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ForeignMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ForeignMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestAllExtensions {
    class func parseFromNSData(data:NSData) -> TestAllExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllExtensions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestAllExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestAllExtensions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension OptionalGroup_extension {
    class func parseFromNSData(data:NSData) -> OptionalGroup_extension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OptionalGroup_extension.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> OptionalGroup_extension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OptionalGroup_extension.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension RepeatedGroup_extension {
    class func parseFromNSData(data:NSData) -> RepeatedGroup_extension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return RepeatedGroup_extension.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> RepeatedGroup_extension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return RepeatedGroup_extension.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestNestedExtension {
    class func parseFromNSData(data:NSData) -> TestNestedExtension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedExtension.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestNestedExtension {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedExtension.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRequired {
    class func parseFromNSData(data:NSData) -> TestRequired {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequired.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRequired {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequired.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRequiredForeign {
    class func parseFromNSData(data:NSData) -> TestRequiredForeign {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredForeign.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRequiredForeign {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredForeign.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestForeignNested {
    class func parseFromNSData(data:NSData) -> TestForeignNested {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestForeignNested.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestForeignNested {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestForeignNested.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestEmptyMessage {
    class func parseFromNSData(data:NSData) -> TestEmptyMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEmptyMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestEmptyMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEmptyMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestEmptyMessageWithExtensions {
    class func parseFromNSData(data:NSData) -> TestEmptyMessageWithExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEmptyMessageWithExtensions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestEmptyMessageWithExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEmptyMessageWithExtensions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestMultipleExtensionRanges {
    class func parseFromNSData(data:NSData) -> TestMultipleExtensionRanges {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMultipleExtensionRanges.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestMultipleExtensionRanges {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMultipleExtensionRanges.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestReallyLargeTagNumber {
    class func parseFromNSData(data:NSData) -> TestReallyLargeTagNumber {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestReallyLargeTagNumber.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestReallyLargeTagNumber {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestReallyLargeTagNumber.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRecursiveMessage {
    class func parseFromNSData(data:NSData) -> TestRecursiveMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRecursiveMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRecursiveMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRecursiveMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestMutualRecursionA {
    class func parseFromNSData(data:NSData) -> TestMutualRecursionA {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMutualRecursionA.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionA {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMutualRecursionA.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestMutualRecursionB {
    class func parseFromNSData(data:NSData) -> TestMutualRecursionB {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMutualRecursionB.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestMutualRecursionB {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestMutualRecursionB.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDupFieldNumber.Foo {
    class func parseFromNSData(data:NSData) -> TestDupFieldNumber.Foo {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.Foo.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Foo {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.Foo.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDupFieldNumber.Bar {
    class func parseFromNSData(data:NSData) -> TestDupFieldNumber.Bar {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.Bar.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber.Bar {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.Bar.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDupFieldNumber {
    class func parseFromNSData(data:NSData) -> TestDupFieldNumber {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDupFieldNumber {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDupFieldNumber.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestEagerMessage {
    class func parseFromNSData(data:NSData) -> TestEagerMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEagerMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestEagerMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestEagerMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestLazyMessage {
    class func parseFromNSData(data:NSData) -> TestLazyMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestLazyMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestLazyMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestLazyMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestNestedMessageHasBits.NestedMessage {
    class func parseFromNSData(data:NSData) -> TestNestedMessageHasBits.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedMessageHasBits.NestedMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestNestedMessageHasBits {
    class func parseFromNSData(data:NSData) -> TestNestedMessageHasBits {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedMessageHasBits.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestNestedMessageHasBits {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestNestedMessageHasBits.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestCamelCaseFieldNames {
    class func parseFromNSData(data:NSData) -> TestCamelCaseFieldNames {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestCamelCaseFieldNames.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestCamelCaseFieldNames {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestCamelCaseFieldNames.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestFieldOrderings {
    class func parseFromNSData(data:NSData) -> TestFieldOrderings {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestFieldOrderings.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestFieldOrderings {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestFieldOrderings.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestExtremeDefaultValues {
    class func parseFromNSData(data:NSData) -> TestExtremeDefaultValues {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestExtremeDefaultValues.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestExtremeDefaultValues {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestExtremeDefaultValues.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension SparseEnumMessage {
    class func parseFromNSData(data:NSData) -> SparseEnumMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SparseEnumMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> SparseEnumMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return SparseEnumMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension OneString {
    class func parseFromNSData(data:NSData) -> OneString {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OneString.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> OneString {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OneString.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MoreString {
    class func parseFromNSData(data:NSData) -> MoreString {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MoreString.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MoreString {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MoreString.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension OneBytes {
    class func parseFromNSData(data:NSData) -> OneBytes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OneBytes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> OneBytes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return OneBytes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension MoreBytes {
    class func parseFromNSData(data:NSData) -> MoreBytes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MoreBytes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> MoreBytes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return MoreBytes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Int32Message {
    class func parseFromNSData(data:NSData) -> Int32Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Int32Message.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Int32Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Int32Message.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Uint32Message {
    class func parseFromNSData(data:NSData) -> Uint32Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Uint32Message.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Uint32Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Uint32Message.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Int64Message {
    class func parseFromNSData(data:NSData) -> Int64Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Int64Message.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Int64Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Int64Message.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension Uint64Message {
    class func parseFromNSData(data:NSData) -> Uint64Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Uint64Message.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Uint64Message {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Uint64Message.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension BoolMessage {
    class func parseFromNSData(data:NSData) -> BoolMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BoolMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> BoolMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BoolMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneof.FooGroup {
    class func parseFromNSData(data:NSData) -> TestOneof.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof.FooGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneof.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof.FooGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneof {
    class func parseFromNSData(data:NSData) -> TestOneof {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneof {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneofBackwardsCompatible.FooGroup {
    class func parseFromNSData(data:NSData) -> TestOneofBackwardsCompatible.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneofBackwardsCompatible.FooGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneofBackwardsCompatible {
    class func parseFromNSData(data:NSData) -> TestOneofBackwardsCompatible {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneofBackwardsCompatible.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneofBackwardsCompatible {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneofBackwardsCompatible.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneof2.FooGroup {
    class func parseFromNSData(data:NSData) -> TestOneof2.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.FooGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneof2.FooGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.FooGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneof2.NestedMessage {
    class func parseFromNSData(data:NSData) -> TestOneof2.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.NestedMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneof2.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.NestedMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestOneof2 {
    class func parseFromNSData(data:NSData) -> TestOneof2 {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestOneof2 {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestOneof2.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRequiredOneof.NestedMessage {
    class func parseFromNSData(data:NSData) -> TestRequiredOneof.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredOneof.NestedMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRequiredOneof.NestedMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredOneof.NestedMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRequiredOneof {
    class func parseFromNSData(data:NSData) -> TestRequiredOneof {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredOneof.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRequiredOneof {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRequiredOneof.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestPackedTypes {
    class func parseFromNSData(data:NSData) -> TestPackedTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestPackedTypes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestPackedTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestPackedTypes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestUnpackedTypes {
    class func parseFromNSData(data:NSData) -> TestUnpackedTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestUnpackedTypes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestUnpackedTypes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestUnpackedTypes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestPackedExtensions {
    class func parseFromNSData(data:NSData) -> TestPackedExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestPackedExtensions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestPackedExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestPackedExtensions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestUnpackedExtensions {
    class func parseFromNSData(data:NSData) -> TestUnpackedExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestUnpackedExtensions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestUnpackedExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestUnpackedExtensions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDynamicExtensions.DynamicMessageType {
    class func parseFromNSData(data:NSData) -> TestDynamicExtensions.DynamicMessageType {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions.DynamicMessageType {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDynamicExtensions.DynamicMessageType.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestDynamicExtensions {
    class func parseFromNSData(data:NSData) -> TestDynamicExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDynamicExtensions.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestDynamicExtensions {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestDynamicExtensions.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestRepeatedScalarDifferentTagSizes {
    class func parseFromNSData(data:NSData) -> TestRepeatedScalarDifferentTagSizes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRepeatedScalarDifferentTagSizes.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestRepeatedScalarDifferentTagSizes {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestRepeatedScalarDifferentTagSizes.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestParsingMerge.RepeatedFieldsGenerator {
    class func parseFromNSData(data:NSData) -> TestParsingMerge.RepeatedFieldsGenerator {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedFieldsGenerator {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.RepeatedFieldsGenerator.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestParsingMerge.OptionalGroup {
    class func parseFromNSData(data:NSData) -> TestParsingMerge.OptionalGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.OptionalGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.OptionalGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.OptionalGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestParsingMerge.RepeatedGroup {
    class func parseFromNSData(data:NSData) -> TestParsingMerge.RepeatedGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.RepeatedGroup.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestParsingMerge.RepeatedGroup {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.RepeatedGroup.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestParsingMerge {
    class func parseFromNSData(data:NSData) -> TestParsingMerge {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestParsingMerge {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestParsingMerge.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension TestCommentInjectionMessage {
    class func parseFromNSData(data:NSData) -> TestCommentInjectionMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestCommentInjectionMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> TestCommentInjectionMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return TestCommentInjectionMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FooRequest {
    class func parseFromNSData(data:NSData) -> FooRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FooRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FooResponse {
    class func parseFromNSData(data:NSData) -> FooResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FooResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FooClientMessage {
    class func parseFromNSData(data:NSData) -> FooClientMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooClientMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FooClientMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooClientMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension FooServerMessage {
    class func parseFromNSData(data:NSData) -> FooServerMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooServerMessage.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> FooServerMessage {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return FooServerMessage.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension BarRequest {
    class func parseFromNSData(data:NSData) -> BarRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BarRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> BarRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BarRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension BarResponse {
    class func parseFromNSData(data:NSData) -> BarResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BarResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> BarResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return BarResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
